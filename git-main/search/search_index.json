{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ROSflight","text":"<p>The ROS2 updates for ROSflight are still under development. Please use with discretion.</p>"},{"location":"#what-is-rosflight","title":"What is ROSflight?","text":"<p>ROSflight is a lean and adaptable autopilot system designed from the ground up with researchers in mind. Its purpose is to enable researchers to quickly and easily try out new ideas with minimal effort. Some of ROSflight's key feature are:</p> <ul> <li>Lightweight, modular, and well documented code that is easy to understand and modify.</li> <li>Most of the autopilot exists on a Linux computer rather than a microcontroller, enabling easier development with increased capabilities.</li> <li>Seamless switching between simulation and hardware: no part of the autopilot knows if it is running in simulation or not.</li> <li>Built on a ROS2 framework, allowing easy integration with ROS2 based projects.</li> </ul> <p>See the user guide for more details on ROSflight.</p>"},{"location":"#why-rosflight","title":"Why ROSflight?","text":"<p>There are a lot of excellent autopilots out there with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Existing autopilots commonly used by researchers tend to have massive codebases under constant development that run primarily on microcontrollers.</p> <p>This presents a number of problems. First, we are limited in our ability to understand and control everything occurring within the autonomy stack, making much of the autopilot an untouchable black box. Second, we are limited to the abilities of microcontrollers and can't take advantage of the more powerful hardware and software that can be found on Linux computers. Third, maintaining up-to-date support for software or hardware projects becomes a lot of work as things are frequently changing.</p> <p>ROSflight is intended to fix these problems by being a lightweight, modular, and well documented codebase that offloads as much as possible to a ROS2 based framework running on a Linux computer.</p>"},{"location":"#our-vision","title":"Our Vision","text":"<p>Perhaps more important than what we are trying to accomplish is what we are not trying to accomplish. ROSflight is not intended to be a fully-featured autopilot with all the same functions of other autopilots, but instead serve as a core foundation that can easily be adapted to any use case.</p> <p>Therefore, one of our primary objectives is to avoid feature creep and remain lean. We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.</p>"},{"location":"developer-guide/contribution-guidelines/","title":"Contribution Guidelines","text":"<p>ROSflight is intended to be a streamlined, bare-bones autopilot. We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the project. In an attempt to avoid \"feature creep,\" we will be very discriminatory in merging pull requests whose purpose is to simply add features. Forking the repository in order to add features is totally acceptable and encouraged, just recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license).</p> <p>In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like. By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature. Please don't be offended if we ask you to modify the formatting of your code before approving a pull request.</p> <p>Although we strive for complete in-code documentation, in practice this sometimes gets left behind for the sake of rapid development. If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the appropriate GitHub issues page or forum, and encourage you to submit pull requests which improve documentation. Several new developers have started with first improving the documentation to get a handle on how things work.</p>"},{"location":"developer-guide/contribution-guidelines/#key-goals-of-rosflight","title":"Key Goals of ROSflight","text":"<p>Here is a summary of the key goals and philosophies behind ROSflight. As you look to make contributions to the project, keep these in mind.</p> <ul> <li> <p>Only include the things that most people will need. The goal of this would be to do most of the work so people can get a MAV in the air quickly and easily, but not overcomplicate the code with features that only a small portion of users would need.</p> </li> <li> <p>Be modular and adaptable for many research-centric use cases. This will be accomplished by putting the majority of the autopilot in a well-designed ROS2 framework. That which needs to be on the microcontroller will need to be done so carefully with good coding practices. Additionally, microcontroller code that is the most likely to be expanded upon should include clear interfaces and instructions for doing so.</p> </li> <li> <p>Keep everything simple and well documented. The key goal here is to minimize the amount of time and effort it takes someone to go from knowing nothing about ROSflight to being able to implement their own features and making meaningful progress with their research.</p> </li> </ul>"},{"location":"developer-guide/contribution-guidelines/#communication","title":"Communication","text":"<p>There are two channels to communicate with the developer team. For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate GitHub issue page. For questions and other discussions, please use the forum.</p>"},{"location":"developer-guide/style-guide/","title":"Style Guide","text":"<p>The focus of anyone contributing to this project should be to write code that is easily understood by anyone, including people who have little experience with ROSflight or coding in general. So, we ask that contributions adhere to the following style guidelines.</p>"},{"location":"developer-guide/style-guide/#comments","title":"Comments","text":"<p>Well written and clear code should be easy to understand even without comments. However, since this project is intended to be as accessible as possible, we ask that you write both clear code and clear comments. Don't use comments to explain code that would be difficult to understand without comments, but instead use them to make clear code even more understandable.</p>"},{"location":"developer-guide/style-guide/#doxygen","title":"Doxygen","text":"<p>Doxygen comments should be added pretty much anywhere where it makes sense. Please include at least a brief for anything you write. For methods and functions, also include explanations of all arguments and the return value. More detailed explanations are encouraged for non-trivial methods and objects.</p>"},{"location":"developer-guide/style-guide/#white-space-and-line-endings","title":"White Space and Line Endings","text":"<p>Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run <code>git diff --check</code> before you stage your files.</p>"},{"location":"developer-guide/style-guide/#code-style","title":"Code Style","text":"<p>ROSflight follows the ROS2 C++ style guide, with some more specific guidelines below. Please follow first the style guidelines below and then the ROS2 guidelines. A .clang-format file and format-correcting script is provided in most ROSflight repositories that can be used to auto-format your code to help you find things you might have missed. Format checks on pull requests using this .clang-format file may also exist.</p>"},{"location":"developer-guide/style-guide/#indentation","title":"Indentation","text":"<p>Indentation should be 2 spaces (no tabs). Case statements in switch blocks should not be indented, e.g.</p> <pre><code>switch (variable)\n{\ncase 1:\n  // do something\n  break;\ndefault:\n  break;\n}\n</code></pre>"},{"location":"developer-guide/style-guide/#spaces","title":"Spaces","text":"<p>There should be a space between <code>if</code>, <code>for</code>, or <code>while</code> and the condition, e.g. <code>while (true)</code>, not <code>while(true)</code>.</p>"},{"location":"developer-guide/style-guide/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Class names should be capitalized with no spaces (i.e. <code>StateManager</code>).</li> <li>Member variables should contain a post-pended underscore (i.e. <code>data_</code>).</li> <li>Member functions should be all lower case with underscores (i.e. <code>set_error()</code>).</li> <li>Boolean values should be assigned <code>true</code> or <code>false</code>, not <code>0</code> or <code>1</code>.</li> </ul>"},{"location":"developer-guide/style-guide/#function-arguments","title":"Function Arguments","text":"<p>Primitive data types (<code>int</code>, <code>float</code>, etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example:</p> <pre><code>void do_something(float dt, const MyClass&amp; data, int* output);\n</code></pre> <p>This function would be called as</p> <pre><code>float dt = 0.01f;\nMyClass my_class;\nint value;\n\ndo_something(dt, my_class, &amp;value);\n</code></pre> <p>This makes it clear the <code>value</code> is modified by the function call.</p>"},{"location":"developer-guide/style-guide/#classes","title":"Classes","text":"<p>All modules should be defined as a self-contained class. All member variables should be declared as \"private,\" named with a post-pended underscore, and accessed through inline accessor functions. All accessible data should be encapsulated in a struct. For example, here is a snippet from the <code>Sensors</code> module in the firmware:</p> <pre><code>class Sensors\n{\npublic:\n  struct Data\n  {\n    vector_t accel = {0, 0, 0};\n    vector_t gyro = {0, 0, 0};\n    float imu_temperature = 0;\n    uint64_t imu_time = 0;\n\n    float diff_pressure_velocity = 0;\n    float diff_pressure = 0;\n    float diff_pressure_temp = 0;\n    bool diff_pressure_valid = false;\n\n    float baro_altitude = 0;\n    float baro_pressure = 0;\n    float baro_temperature = 0;\n    bool baro_valid = false;\n\n    float sonar_range = 0;\n    bool sonar_range_valid = false;\n\n    vector_t mag = {0, 0, 0};\n\n    bool baro_present = false;\n    bool mag_present = false;\n    bool sonar_present = false;\n    bool diff_pressure_present = false;\n  };\n\n  Sensors(ROSflight&amp; rosflight);\n\n  inline const Data &amp; data() const { return data_; }\n\nprivate:\n  Data data_;\n}\n</code></pre> <p>Note that <code>data_</code> is a private member variable, but the <code>Data</code> struct is declared publicly and <code>data_</code> is accessed through an <code>inline const</code> accessor to prevent another module from changing <code>data_</code>.</p>"},{"location":"developer-guide/style-guide/#enums","title":"Enums","text":"<p>Enums should be declared using the following style: <pre><code>enum ArmedState\n{\n  ARMED_STATE_INIT,\n  ARMED_STATE_DISARMED,\n  ARMED_STATE_ARMED\n};\n</code></pre></p> <p>The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.</p>"},{"location":"developer-guide/style-guide/#structs","title":"Structs","text":"<p>Structs should be declared using the following style: <pre><code>struct SomeValue\n{\n  int v1;\n  int v2;\n};\n</code></pre> Struct type names should be in CamelCase.</p>"},{"location":"developer-guide/style-guide/#globals","title":"Globals","text":"<p>The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals). This should only occur in board support layers and not in the core ROSflight libary code.</p>"},{"location":"developer-guide/style-guide/#include-order","title":"Include Order","text":"<p>Include files at the top of your file in the following order:</p> <ol> <li>Standard library (e.g. <code>&lt;cstdint&gt;</code>)</li> <li>Files from external libraries included in the project (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, <code>&lt;mavlink/v1.0/common/mavlink.h&gt;</code>)</li> <li>Other header files from this project (e.g. <code>\"rosflight.h\"</code>)</li> <li>The header file for this specific source file</li> </ol> <p>Group the includes according to the above list with an empty line between each group. (For external libraries, you may subdivide group 2 into a group for each library.) The first two groups should use angle brackets (<code>&lt;&gt;</code>), and the last two groups should use quotation marks (<code>\"\"</code>). Files from external libraries should be namespaced by the library name (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, not <code>&lt;breezystm32.h&gt;</code>).</p> <p>Alphabetize the files within each group. Do not change the include order to fix build errors; if you have to do that it means you are not including a file somewhere that you should. Please fix it by including all the right files.</p> <p>Include C standard library headers using the C++ style (<code>#include &lt;cmath&gt;</code>) instead of the C style (<code>#include &lt;math.h&gt;</code>).</p> <p>For example, in <code>sensors.c</code> I might have: <pre><code>#include &lt;cstdbool&gt;\n#include &lt;cstdint&gt;\n\n#include &lt;breezystm32/breezystm32.h&gt;\n#include &lt;breezystm32/drv_mpu6050.h&gt;\n\n#include \"param.h\"\n\n#include \"sensors.h\"\n</code></pre></p>"},{"location":"developer-guide/style-guide/#namespacing","title":"Namespacing","text":"<p>All modules should be encapsulated in a package namespace that is unique and consistent within the package (like <code>rosflight_firmware</code> for anything in the firmware package).</p>"},{"location":"developer-guide/firmware/building-and-flashing/","title":"Building and Flashing the Firmware","text":"<p>This guide assumes you are running Ubuntu 22.04 LTS, which is the currently supported development environment.</p>"},{"location":"developer-guide/firmware/building-and-flashing/#installing-the-arm-embedded-toolchain","title":"Installing the ARM Embedded Toolchain","text":"<pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre> <p>You can test the installation and check which version is installed by running <code>arm-none-eabi-gcc --version</code>.</p>"},{"location":"developer-guide/firmware/building-and-flashing/#building-the-firmware-from-source","title":"Building the Firmware from Source","text":"<p>Now that we have the compiler installed, simply clone the ROSflight firmware repository, pull down the submodules, and build:</p> <pre><code>git clone --recursive https://github.com/rosflight/rosflight_firmware\ncd rosflight_firmware\nmkdir build \ncd build \ncmake .. -DBUILD_VARMINT=TRUE\nmake\n</code></pre>"},{"location":"developer-guide/firmware/building-and-flashing/#flashing-newly-built-firmware","title":"Flashing Newly-Built Firmware","text":"<p>TODO</p> <p>Update this when hardware support is finalized.</p> <p>First, make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.</p>"},{"location":"developer-guide/firmware/building-and-flashing/#f4","title":"F4","text":"<p>Flash the firmware to the board by running <code>make BOARD=REVO flash</code>. If necessary, specify the serial port with <code>make BOARD=REVO SERIAL_DEVICE=/dev/ttyACM0 flash</code>.</p>"},{"location":"developer-guide/firmware/code-architecture/","title":"Code Architecture","text":"<p>The firmware is divided into two main components: the core library, and a collection of board implementations. This division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the hardware abstraction layer (HAL). This architecture is illustrated in the following diagram:</p> <p></p>"},{"location":"developer-guide/firmware/code-architecture/#firmware-core-library","title":"Firmware Core Library","text":"<p>The firmware core library consists of all the code in the <code>include</code> and <code>src</code> directories of the firmware repository. This includes the code for what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, state manager, etc.) required for flight. It also includes the interface definition for the hardware abstraction layer, which is defined by the abstract <code>Board</code> class in <code>include/board.h</code>. The communications link (MAVLink) is also abstracted, with the interface defined by the <code>CommLink</code> class in <code>include/comm_link.h</code>. External libraries are contained in the <code>lib</code> folder.</p>"},{"location":"developer-guide/firmware/code-architecture/#board-abstraction","title":"Board Abstraction","text":"<p>The hardware abstraction implementations are contained in the <code>boards</code> directory, organized in subdirectories according to the hardware driver layer. Each board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack. The Varmint implementation in the <code>boards/varmint</code> shows how this is done for an embedded flight controller. Examples of board implementations for SIL simulation are found in the <code>rosflight_sim</code> ROS2 package available here.</p> <p>The flight stack is encapsulated in the <code>ROSflight</code> class defined at <code>include/rosflight.h</code>. This class contains two public functions: <code>init()</code> and <code>run()</code>. Its constructor requires two arguments: an implementation of the <code>Board</code> interface, and an implementation of the <code>CommLink</code> interface.</p> <p>Each board implementation is required to implement the entire Board class.</p>"},{"location":"developer-guide/firmware/code-architecture/#comm-link-abstraction","title":"Comm Link Abstraction","text":"<p>The purpose of the comm link abstraction layer is to allow communication protocols other than MAVLink to be used if desired. The comm link abstraction implementations are contained in the <code>comms</code> directory, organized in subdirectories by protocol. The implementations translate between the messages that the firmware expects to send and receive, and the messages defined by the communication protocol. Currently, only MAVLink is implemented.</p>"},{"location":"developer-guide/firmware/code-architecture/#flight-stack","title":"Flight Stack","text":"<p>The flight stack is encapsulated by the <code>ROSflight</code> class defined in <code>include/rosflight.h</code>. It consists of a collection of modules. Each of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality. The following diagram illustrates these modules and the data flow between them. Rectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer:</p> <p></p> <p>We'll describe each of these modules in the following sections:</p>"},{"location":"developer-guide/firmware/code-architecture/#state-manager","title":"State Manager","text":"<p>This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle. While only the comm manager data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status.</p> <p>The operation of the state manager is defined by the following finite state machine:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults. In the case of a hard fault, the firmware writes a small amount of data to backup memory then reboots. This backup memory location is checked and then cleared after every reboot. The backup memory includes the armed state of the flight controller. On reboot, the firmware will initialize then, if this armed-state flag is set, immediately transition back into the armed state. This functionality allows for continued RC control in the case of a hard fault. Hard faults are not expected with the stable firmware code base, but this feature adds an additional layer of safety if experimental changes are being made to the firmware itself.</p>"},{"location":"developer-guide/firmware/code-architecture/#parameter-server","title":"Parameter Server","text":"<p>This module handles all parameters for the flight stack. It supports the getting and setting of integer and floating-point parameters, and the saving of these parameters to non-volatile memory. Setting and getting of parameters from the companion computer is done through the serial communication interface. While no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.</p>"},{"location":"developer-guide/firmware/code-architecture/#comm-manager","title":"Comm Manager","text":"<p>This module handles all serial communication between the flight controller and companion computer. This includes streaming data and receiving offboard control setpoints and other commands from the computer. This module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server.</p> <p>The actual communication protocol used is abstracted by the interface in include/comm_link.h. A new protocol can be used by implementing a wrapper around the protocol that inherits from this interface. Currently, only MAVLink has been implemented. The implementation is found in comms/mavlink/mavlink.h and comms/mavlink/mavlink.cpp.</p>"},{"location":"developer-guide/firmware/code-architecture/#sensors","title":"Sensors","text":"<p>This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.). Its responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.</p>"},{"location":"developer-guide/firmware/code-architecture/#estimator","title":"Estimator","text":"<p>This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.</p>"},{"location":"developer-guide/firmware/code-architecture/#rc","title":"RC","text":"<p>The RC module is responsible for interpreting the RC signals coming from the transmitter via the receiver. This includes mapping channels to their appropriate functions and reversing directions if necessary.</p>"},{"location":"developer-guide/firmware/code-architecture/#command-manager","title":"Command Manager","text":"<p>The command manager combines inputs from the RC and comm manager modules to produce a control setpoint. Its main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.</p>"},{"location":"developer-guide/firmware/code-architecture/#controller","title":"Controller","text":"<p>The controller uses the inputs from the command manager and estimator to compute a control output. This control output is computed in a generic form (x, y, and z torques, and force F), and is later converted into actual motor commands by the mixer.</p>"},{"location":"developer-guide/firmware/code-architecture/#mixer","title":"Mixer","text":"<p>The mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.</p>"},{"location":"developer-guide/firmware/debugging/","title":"Using an In-Circuit Debugger","text":"<p>TODO</p> <p>Update this when hardware support is finalized.</p> <p>Debugging an STM32-based board is accomplished with an ST-LINK/V2 in-circuit debugger and programmer. We have had the best luck with the official version from STMicroelectronics. These devices are reasonably priced, and are available directly from STMicroelectronics or from vendors such as Digi-Key, Mouser, and Newark.</p> <p>The following guide will show you how to get the in-circuit debugger running with either the Visual Studio Code or QtCreator IDE. Start with the steps in the General Setup section, then move on to either the VS Code or STM32cubeIDE sections depending on your choice of IDE.</p> <p>This guide assumes you are running Ubuntu 22.04 LTS, which is the currently supported development environment.</p>"},{"location":"developer-guide/firmware/debugging/#general-setup","title":"General Setup","text":"<p>Follow the guide in Building and Flashing to install the compiler toolchain.</p> <p>Also make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.</p>"},{"location":"developer-guide/firmware/debugging/#connect-debugger-to-flight-controller","title":"Connect debugger to flight controller","text":"<p>The ST-LINK/V2 connects to the microcontroller using the Serial Wire Debug (SWD) interface. You will need to connect the <code>GND</code>, <code>NRST</code>, <code>SWDIO</code>, and <code>SWCLK</code> lines of the ST-LINK/V2 to your flight controller. On many F4 boards, these lines are pinned out through a 4-position JST SH connector, although that connector is not always populated. Refer to the documentation for your specific board for details.</p> <p>The official ST-LINK/V2 also needs a target voltage reference on pin 1 or 2, which for the F4 boards is 3.3V. However, there is no externally accessible 3.3V pinout on the F4 boards. An easy solution to this is to connect pin 19 (VDD 3.3V) of the ST-LINK/V2 to pin 1 or 2 of the ST-LINK/V2 (Target VCC) to provide the voltage reference. You will also need to power the board from another source, either through the USB port or over the servo rail. Note that this connection is not required for the cheap clone versions of the ST-LINK/V2.</p>"},{"location":"developer-guide/firmware/debugging/#vs-code","title":"VS Code","text":"<p>You can install Visual Studio Code by downloading the latest version from their website. Follow the steps below to configure debugging with the in-circuit debugger.</p> <p>You should open the root firmware directory for editing and debugging, e.g. <code>code /path/to/rosflight_firmware</code>.</p>"},{"location":"developer-guide/firmware/debugging/#install-openocd","title":"Install OpenOCD","text":"<p>OpenOCD (On-Chip Debugger) is the software that will control the debugger. Install from the <code>apt</code> repositories:</p> <pre><code>sudo apt install openocd\n</code></pre>"},{"location":"developer-guide/firmware/debugging/#install-cortex-debug-extension","title":"Install Cortex-Debug extension","text":"<p>The embedded debugging functionality is provided by the <code>Cortex-Debug</code> extension. Install using the VS Code GUI, or from VS Code press <code>Ctrl+P</code> then type <code>ext install marus25.cortex-debug</code>.</p> <p>Steps for configuring this extension are described next.</p>"},{"location":"developer-guide/firmware/debugging/#download-svd-file","title":"Download SVD file","text":"<p>A System View Description (SVD) file describes the configuration (CPU, peripherals, registers, etc.) of the microcontroller. The Cortex-Debug extension can make use of an SVD file to provide more detailed debugging information, such as the ability to inspect register values.</p> <p>SVD files can be downloaded from STMicroelectronics. The files for the F4 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F405.svd</code>. The files for the F1 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F103.svd</code>. Put those files in a convenient location.</p>"},{"location":"developer-guide/firmware/debugging/#configure-build-step","title":"Configure build step","text":"<p>You can configure VS Code to run <code>make</code> for you when you press <code>Ctrl+Shift+B</code>. To do this, put the following in <code>.vscode/tasks.json</code> inside your firmware working directory:</p> <pre><code>{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"type\": \"shell\",\n      \"label\": \"make\",\n      \"command\": \"make\",\n      \"args\": [\"DEBUG=GDB\"],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>Note that by default, this will only build the F4 (Revo) firmware. To build the F1 firmware, you will need to edit this to add the argument <code>BOARD=NAZE</code>.</p>"},{"location":"developer-guide/firmware/debugging/#configure-debugging","title":"Configure debugging","text":"<p>To configure in-circuit debugging of F4 and F1 targets, put something like the following in <code>.vscode/launch.json</code> inside your firmware working repository:</p> <pre><code>{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"STM32F405\",\n      \"type\": \"cortex-debug\",\n      \"request\": \"launch\",\n      \"servertype\": \"openocd\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"executable\": \"${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf\",\n      \"device\": \"STM32F405\",\n      \"svdFile\": \"/path/to/STM32F405.svd\",\n      \"configFiles\": [\n        \"interface/stlink-v2.cfg\",\n        \"target/stm32f4x.cfg\"\n      ],\n      \"runToMain\": true\n    },\n    {\n      \"name\": \"STM32F103\",\n      \"type\": \"cortex-debug\",\n      \"request\": \"launch\",\n      \"servertype\": \"openocd\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"executable\": \"${workspaceRoot}/boards/breezy/build/rosflight_NAZE_Debug.elf\",\n      \"device\": \"STM32F103\",\n      \"svdFile\": \"/path/to/STM32F103.svd\",\n      \"configFiles\": [\n        \"interface/stlink-v2.cfg\",\n        \"target/stm32f1x.cfg\"\n      ],\n      \"runToMain\": true\n    }\n  ]\n}\n</code></pre> <p>Be sure to edit the values of <code>\"svdFile\"</code> to point to the respective SVD files you downloaded earlier.</p> <p>To start debugging, enter the debug pane in VS Code, select the desired configuration, then click the green arrow to start debugging. The shortcut key <code>F5</code> will also launch the last-selected debug configuration.</p> <p>More details on the configuration and use of the <code>Cortex-Debug</code> extension can be found here and here.</p>"},{"location":"developer-guide/firmware/debugging/#stm32cubeide","title":"STM32cubeIDE","text":""},{"location":"developer-guide/firmware/unit-tests/","title":"Building and Running Unit Tests","text":"<p>Contributions will need to pass our continuous integration unit tests before merging. To test your contributions against these tests, you'll first need to install Eigen and gtest:</p> <pre><code>sudo apt install build-essential libgtest-dev libeigen3-dev cmake\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#compile-gtest","title":"Compile gtest","text":"<p>You just downloaded a bunch of source files, which you now have to go build</p> <pre><code>cd /usr/src/gtest\nsudo cmake CMakeLists.txt\nsudo make\n</code></pre> <p>Copy the archive files you just built to the <code>/usr/lib</code> directory so CMake can find them later:</p> <pre><code>sudo cp ./lib/libgtest*.a /usr/lib\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#run-the-test-script","title":"Run the Test Script","text":"<p>The simplest way to run the unit tests is to use the testing script. This script first checks that the firmware compiles, then runs the unit tests. This is the same script used on the continuous integration server, so this is a great way to check that your code will pass the tests before opening a pull request. Run the test script with</p> <pre><code>cd &lt;firmware_directory&gt;\n./scripts/run_tests.sh\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#manually-build-and-run-the-unit-tests","title":"Manually Build and Run the Unit Tests","text":"<p>If you want to manually build and run the unit tests, first build them with the following commands:</p> <pre><code>cd &lt;firmware_directory&gt;\nmkdir build\ncd build\ncmake .. -DBUILD_TEST=TRUE\nmake\n</code></pre> <p>Then run them with:</p> <pre><code>./test/unit_tests\n</code></pre>"},{"location":"user-guide/autonomous-flight/","title":"Autonomous Flight","text":"<p>To perform autonomous flight with ROSflight, we need to send control commands from our companion computer to the firmware. This can be done with ROSplane or ROScopter, which already have completed autonomy stacks developed specifically for ROSflight. We recommend starting with one of these autonomy stacks and building on them to suit your needs. If using a multirotor, follow the ROScopter setup guide to get started. If using a fixed-wing, follow the ROSplane setup guide.</p> <p>However, ROSplane and ROScopter are optional and an entirely different autonomy stack can be used if desired. To use a different autonomy stack, follow this guide.</p>"},{"location":"user-guide/autonomous-flight/#provide-control-from-a-companion-computer","title":"Provide Control from a Companion Computer","text":"<p>Control setpoints are sent to the flight controller by publishing to the <code>/command</code> topic that is advertised by the <code>rosflight_io</code> node. This topic accepts messages of type <code>rosflight_msgs/Command</code>, which have the following structure:</p> <pre><code>std_msgs/Header header\nuint8 mode\nuint8 ignore\nfloat32 x\nfloat32 y\nfloat32 z\nfloat32 f\n</code></pre> <p>The <code>header</code> field is a standard ROS2 message header. The <code>x</code>, <code>y</code>, <code>z</code>, and <code>f</code> fields are the control setpoint values, which are interpreted according to the <code>mode</code> and <code>ignore</code> fields.</p> <p>The following table describes the different values the <code>mode</code> field can take, as well as how the setpoint values are interpreted for each of these modes:</p> Value Enum x y z F 0 <code>MODE_PASS_THROUGH</code> aileron deflection (-1 to 1) elevator deflection (-1 to 1) rudder deflection (-1 to 1) throttle (0 to 1) 1 <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> roll rate (rad/s) pitch rate (rad/s) yaw rate (rad/s) throttle (0 to 1) 2 <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> roll angle (rad) pitch angle (rad) yaw rate (rad/s) throttle (0 to 1) <p>The <code>MODE_PASS_THROUGH</code> mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> and <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> modes are used for multirotor vehicles to specify the attitude rates or angles, respectively.</p> <p>The <code>ignore</code> field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify throttle setpoints to perform altitude hold, while still letting the RC pilot specify the attitude setpoints. The <code>ignore</code> field is a bitmask that can be populated by combining the following values:</p> Value Enum Result 0 <code>IGNORE_NONE</code> Ignore none of the fields (default) 1 <code>IGNORE_X</code> Ignore the <code>x</code> field 2 <code>IGNORE_Y</code> Ignore the <code>y</code> field 4 <code>IGNORE_Z</code> Ignore the <code>z</code> field 8 <code>IGNORE_F</code> Ignore the <code>F</code> field <p>For the previous example, I would set the <code>ignore</code> field to a value of <pre><code>ignore = IGNORE_X | IGNORE_Y | IGNORE_Z\n</code></pre></p> <p>The best practice is to use enum names rather than the actual numeric values for the <code>mode</code> and <code>ignore</code> fields. For example, to specify a multirotor attitude angle command in C++ I might have: <pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rosflight_msgs/msg/command.hpp&gt;\n\nrosflight_msgs::msg::Command msg;\nmsg.header.stamp = node-&gt;get_clock()-&gt;now();\nmsg.mode = rosflight_msgs::msg::Command::MODE_ROLL_PITCH_YAWRATE_THROTTLE;\nmsg.ignore = rosflight_msgs::msg::Command::IGNORE_NONE;\nmsg.x = 0.0;\nmsg.y = 0.0;\nmsg.z = 0.0;\nmsg.f = 0.6;\n</code></pre></p> <p>In Python I might have: <pre><code>import rclpy\nfrom rosflight_msgs.msg import Command\n\nmsg = Command()\nmsg.header.stamp = node.get_clock().now().to_msg()\nmsg.mode = Command.MODE_ROLL_PITCH_YAWRATE_THROTTLE\nmsg.ignore = Command.IGNORE_NONE\nmsg.x = 0.0\nmsg.y = 0.0\nmsg.z = 0.0\nmsg.f = 0.6\n</code></pre> I would then publish this message to the <code>/command</code> topic to forward it to the embedded flight controller.</p> <p>Note</p> <p>If the flight controller does not receive a new command for a defined period of time, it will ignore the old commands and revert to RC control. The length of this timeout period is set by the <code>OFFBOARD_TIMEOUT</code> parameter.</p>"},{"location":"user-guide/flight-controller-setup/","title":"Flight Controller Setup","text":"<p>Note</p> <p>This page contains instructions for flashing pre-built firmware binaries. For instructions on building and flashing from source, see Building and Flashing in the Developer Guide.</p>"},{"location":"user-guide/flight-controller-setup/#compatible-hardware","title":"Compatible Hardware","text":"<p>Currently, the ROSflight firmware only supports an in-development board from AeroVironment, the Varmint. This board is not yet commercially available, but plans are for it to start being sold early 2024.</p> <p>We also plan to add support for the CubePilot Orange, which uses the same H7 processor as the Varmint.</p>"},{"location":"user-guide/flight-controller-setup/#serial-port-configuration","title":"Serial Port Configuration","text":"<p>Tip</p> <p>You can see which groups you are a member of by running <code>groups $USER</code> on the command line.</p> <p>The following bullet point is necessary:</p> <ul> <li>Be sure your user is in the <code>dialout</code> and <code>plugdev</code> groups so you have access to the serial ports. You will need to log out and back in for these changes to take effect. <pre><code>sudo usermod -aG dialout,plugdev $USER\n</code></pre></li> </ul> <p>If you experience issues, you may need one or both of the next two bullet points:</p> <ul> <li> <p>Temporarily stop the modem-manager (Sometimes, Linux thinks the device is a modem -- this command will be effective until next boot, or until you run the command again with <code>start</code> in place of <code>stop</code>) <pre><code>sudo systemctl stop ModemManager.service\n</code></pre></p> </li> <li> <p>Add the custom udev rule so Linux handles the flight controller properly (copy the following as <code>/etc/udev/rules.d/45-stm32dfu.rules</code>) <pre><code># DFU (Internal bootloader for STM32 MCUs)\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"df11\", MODE=\"0664\", GROUP=\"plugdev\"\n</code></pre></p> </li> </ul> <p>Tip</p> <p>You can permanently disable the ModemManager if you do not need it, then you won't have to disable it every time you reboot: <pre><code>sudo systemctl disable ModemManager.service\n</code></pre> Replace <code>disable</code> with <code>enable</code> to revert (i.e. if you find some other program you use needs access to it). Or you can uninstall it entirely from your system: <pre><code>sudo apt purge modemmanager\n</code></pre></p>"},{"location":"user-guide/flight-controller-setup/#flashing-firmware","title":"Flashing Firmware","text":"<p>TODO</p> <p>Update flashing instructions.</p>"},{"location":"user-guide/flight-controller-setup/#f4-boards","title":"F4 Boards","text":"<ul> <li>Install the dfu-util utility</li> </ul> <pre><code>sudo apt install dfu-util\n</code></pre> <ul> <li>Download the latest rosflight-F4.bin file, found here</li> <li>Put the board in bootloader mode (short the boot pins while restarting the board by cycling power)</li> </ul> <p>Tip</p> <p>dfu-util auto-detects F4-based boards. Try <code>dfu-util -l</code> to make sure your board is in bootloader mode</p> <ul> <li>Flash the firmware to the device <pre><code>    dfu-util -a 0 -s 0x08000000 -D rosflight-F4.bin\n</code></pre></li> </ul>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages:</p> <ol> <li>Set up your hardware (fixed-wing or multirotor platform, flight controller, and companion computer)</li> <li>Flash your flight controller with the latest ROSflight firmware</li> <li>Set up your RC transmitter</li> <li>Set up ROS2 on your companion computer</li> <li>Configure the flight controller for your setup: the configuration checklists below should help guide you through this process</li> <li>Run through your preflight checks</li> <li>Tune the firmware attitude controller gains (multirotors only)</li> <li>Set up autonomous flight via offboard control (optional)</li> </ol>"},{"location":"user-guide/getting-started/#configuration-checklist","title":"Configuration Checklist","text":"<p>The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your hardware is already set up correctly.</p>"},{"location":"user-guide/getting-started/#general-setup","title":"General Setup","text":"<ol> <li>Set the <code>FIXED_WING</code> parameter (<code>1</code> if a fixed-wing, <code>0</code> if a multirotor)</li> <li>Set the <code>RC_TYPE</code> parameter (<code>0</code> if PPM, <code>1</code> if SBUS)</li> <li>Set the <code>MIXER</code> parameter to the appropriate value described in the Hardware Setup page</li> <li>Set the <code>MOTOR_PWM_UPDATE</code> parameter (typically <code>490</code> for SimonK ESCs, <code>50</code> for standard servos)</li> <li>Make sure your RC transmitter is set up correctly</li> <li>Set up your RC switches<ul> <li>If you want to arm/disarm using a switch, set the <code>ARM_CHANNEL</code> parameter to the appropriate channel (0-indexed)</li> <li>If you want to use a switch to enable RC override, set the <code>RC_ATT_OVRD_CHN</code> and <code>RC_THR_OVRD_CHN</code> parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel.</li> </ul> </li> <li>Calibrate your IMU: start <code>rosflight_io</code>, then run <code>ros2 service call /calibrate_imu std_srvs/srv/Trigger</code></li> <li>Complete the multirotor-specific or fixed-wing-specific checklist below</li> <li>Save the parameters (<code>ros2 service call /param_write std_srvs/srv/Trigger</code>)</li> <li>You'll probably want to save a backup of your parameters (call <code>ros2 service call /param_save_to_file rosflight_msgs/srv/ParamFile \"{filename: \"params.yml\"}\"</code>)</li> <li>Make sure you run through the Preflight Checklist before flying</li> </ol>"},{"location":"user-guide/getting-started/#multirotor-specific-setup","title":"Multirotor-specific Setup","text":"<p>Danger</p> <p>IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!!</p> <ol> <li> <p>Calibrate ESCs</p> <ol> <li>Make sure <code>MOTOR_MIN_PWM</code> and <code>MOTOR_MAX_PWM</code> are correct (usually <code>1000</code> and <code>2000</code>)</li> <li>Set <code>MIXER</code> param to <code>0</code> (ESC calibration mixer)</li> <li>Set <code>ARM_SPIN_MOTORS</code> to <code>0</code></li> <li> <p>Perform ESC calibration. For standard ESCs:</p> <ol> <li>With power disconnected from the motors, arm the flight controller</li> <li>Set throttle to maximum</li> <li>Connect power to the motors</li> <li>Drop the throttle to minimum</li> </ol> </li> <li> <p>Set the <code>MIXER</code> parameter back to the appropriate value for your vehicle (see the Hardware Setup page)</p> </li> <li>Set <code>ARM_SPIN_MOTORS</code> back to <code>1</code></li> </ol> </li> <li> <p>The <code>ARM_SPIN_MOTORS</code> parameter should be set to <code>1</code> so the motors spin slowly when armed. The idle throttle setting can be adjusted with the <code>MOTOR_IDLE_THR</code> parameter.</p> </li> <li>You'll most likely want to set the <code>CAL_GYRO_ARM</code> param to <code>1</code> to enable calibrating gyros before arming</li> <li>Set the <code>RC_ATT_MODE</code> parameter to set RC control mode (<code>0</code> for rate mode, <code>1</code> for angle mode [default])</li> <li>Set torque offsets as described in the RC trim calculation section of the Improving Firmware Performance page</li> <li>Set the <code>FAILSAFE_THR</code> parameter to specify the throttle level the MAV will hold if the transimtter disconnects. Set the parameter to <code>0</code> if you just want the MAV to drop, otherwise determine the amount of throttle required to hover the MAV and set the parameter comfortably below that. DO NOT set it above, as this will result in a runaway MAV. We recommended that you test the throttle level in an enclosed space by powering off the transmitter while hovering, if you set this parameter above 0.</li> <li>Tune the controller gains as described in the Multirotor gain tuning section of the Improving Firmware Performance page</li> </ol>"},{"location":"user-guide/getting-started/#fixed-wing-specific-setup","title":"Fixed-Wing-Specific Setup","text":"<ol> <li>Reverse servo directions if necessary using the <code>AIL_REV</code>, <code>ELEVATOR_REV</code>, and <code>RUDDER_REV</code> parameters (<code>1</code> to reverse, <code>0</code> to keep current direction)</li> <li>You'll most likely want to set the <code>ARM_SPIN_MOTORS</code> parameter to <code>0</code> so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching</li> </ol>"},{"location":"user-guide/hardware-setup/","title":"Hardware Setup","text":""},{"location":"user-guide/hardware-setup/#parts-list","title":"Parts List","text":"<p>To use ROSflight to its full potential, you will need the following system components. Some components are mounted on your MAV (Miniature Aerial Vehicle), while others are on the ground. ROSflight supports both multirotor and fixed-wing vehicles.</p> <p>Mounted on the MAV</p> <ol> <li>Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s)</li> <li>Flight Controller (FC)</li> <li>Vibration Isolation for FC</li> <li>Any external sensors</li> <li>R/C Receiver</li> <li>Companion Computer</li> <li>Wi-Fi Antenna, or access of some kind to ground-station, wireless network (e.g. Ubiquiti Bullet)</li> </ol> <p>Ground Station</p> <ol> <li>Ground-Station, Wireless Network (e.g. Wi-Fi Router, Ubiquiti Rocket)</li> <li>R/C transmitter</li> <li>Laptop or base station computer</li> <li>Joystick (Xbox controller)</li> </ol>"},{"location":"user-guide/hardware-setup/#frame-motors-escs-battery-and-propeller","title":"Frame, Motors, ESCs, Battery, and Propeller","text":"<p>We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination. There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts.</p> <p>If you are designing your own multirotor or airplane, you may want to look at ecalc, an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV.</p> <p>Some things to keep in mind as you design or build your MAV.</p> <ul> <li>Most kits do not include space for a companion computer, cameras, laser scanners or other sensors. Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV.</li> <li>You will likely also need to customize the power circuitry of your MAV to provide power to your companion computer at some specific voltage. Many people like to separate the power electronics (the ESCs and motors), from the computer and companion sensors. This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand. We will talk about this more when we talk about wiring up your MAV.</li> <li>Cheap propellers can cause a huge amount of vibration. Consider buying high-quality propellers, doing a propeller balance, or both. RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing.</li> <li>ESCs will need to be calibrated from 2000 to 1000 us</li> </ul>"},{"location":"user-guide/hardware-setup/#flight-controller","title":"Flight Controller","text":"<p>TODO</p> <p>Update recommended hardware once supported hardware has been finalized.</p>"},{"location":"user-guide/hardware-setup/#external-sensors","title":"External Sensors","text":"<p>Additional Sensors you may want for your ROSflight setup include:</p> <ul> <li>Sonar</li> <li>GPS</li> <li>Digital Airspeed Sensor (Pitot Tube)</li> </ul>"},{"location":"user-guide/hardware-setup/#vibration-isolation","title":"Vibration Isolation","text":"<p>It is really important to isolate your flight controller from vehicle vibrations, such as those caused by propellers and motors. We recommend using small amounts of Kyosho Zeal to mount a fiberglass plate holding the FC to the MAV. You may also want to try adding mass to the flight control board. We have accomplished this by gluing steel washers to the fiberglass mounting plate.</p> <p></p> <p>You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the FC mounting plate. The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.</p>"},{"location":"user-guide/hardware-setup/#companion-computer","title":"Companion Computer","text":"<p>The only requirement for the companion computer is that it runs Linux (usually an Ubuntu LTS version, but using Docker on other distributions is also an option), ROS2, has at least one USB port, and can be carried by the aircraft. We have had success with the following companion computers, but by no means is this a comprehensive list; it is more by way of suggestion.</p> <ul> <li>NVIDIA Jetson</li> <li>MSI CUBI</li> <li>Intel NUC</li> <li>Rasberry Pi 3</li> </ul>"},{"location":"user-guide/hardware-setup/#wi-fi","title":"Wi-Fi","text":"<p>You will need Wi-Fi to communicate with your MAV when it is in the air. Because ROS2 communicates over UDP, it is very easy to use ROS2 to view what is going on in your MAV while it is flying by sending commands and reading sensor data. For most applications, a standard Wi-Fi router and dongle will suffice. For long-range applications, you may want to look into Ubiquiti point-to-point Wi-Fi. (We have seen ranges over a mile with these networks.)</p>"},{"location":"user-guide/hardware-setup/#rc-transmitter-and-receiver","title":"RC Transmitter and Receiver","text":"<p>For RC Control, you will need a transmitter with between 6 and 8 channels. Any additional channels will be wasted. We require RC control for safe operation, and only support arming and disarming via RC control.</p> <p>ROSflight only supports PPM (pulse position modulation) and SBUS receivers. Individual channel PWM outputs are not supported. Any configurations with PPM or SBUS and 6-8 channels will be sufficient.</p>"},{"location":"user-guide/hardware-setup/#laptop-or-base-station-computer","title":"Laptop or Base Station Computer","text":"<p>You will need a laptop which can run ROS2 to communicate with the MAV over the ground station wireless network. To do this natively you'll want a recent Ubuntu LTS version, but this can also be done with Docker containers from pretty much any Linux distribution. Linux within a virtual machine can also work, but is not recommended. </p>"},{"location":"user-guide/hardware-setup/#joystick","title":"Joystick","text":"<p>A joystick is used for software-in-the-loop (SIL) simulations. The joystick is not technically a required component because it is possible to control your MAV from the command line, but it makes things much easier. Our first recommendation is to use the same transmitter you use for hardware as a joystick by plugging it into the computer via USB. We support Taranis QX7 transmitters, Radiomaster TX16s transmitters, RealFlight controllers, and XBOX controllers. Other joysticks can be used, but you may need to create custom axis and button mappings within the ROSflight joystick utility.</p>"},{"location":"user-guide/hardware-setup/#battery-monitor","title":"Battery Monitor","text":"<p>A battery monitor is an analog sensor that provides battery voltage and/or battery current information. This data can be used to prevent power loss in air or to measure system load. The sensor outputs an analog voltage proportional to the battery voltage and/or current through the battery. Most flight controllers come equipped with a built-in battery monitor, but if not, small PCB sensors are also available that can be connected to the flight controller.</p> <p>For ROSflight to use a battery monitor, an appropriate multiplier must be set. ROSflight multiplies the analog signal from the monitor by the multiplier to get the final reading. The monitor datasheet should contain the information needed to get the multiplier. For example, the datasheet for the AttoPilot 50V/90A sensor states that it outputs 63.69 mV / V. To get the original battery voltage, the multiplier must be 1/.06369, or 15.7. The multipliers for the voltage and current are set separately, with the <code>BATT_VOLT_MULT</code> and <code>BATT_CURR_MULT</code> parameters, respectively.</p> <p>ROSflight applies a simple low-pass filter to remove noise from the voltage and current measurements. These filters are configurable via the <code>BATT_VOLT_ALPHA</code> and <code>BATT_CURR_ALPHA</code> parameters. The alpha value for a given cutoff frequency \\(a\\), can be calulated with: \\( \\alpha =  e ^ {-.01a} \\). As battery voltages do not typically change quickly, the default of 0.995 usually suffices.</p> <p>More information on battery monitor hardware, including determinining appropriate multipliers and creating a simple DIY monitor, can be found on the OpenPilot Wiki.</p>"},{"location":"user-guide/hardware-setup/#wiring-diagram","title":"Wiring Diagram","text":"<p>Below is an example wiring diagram for a multirotor using an MSI Cubi as a companion computer. This diagram also includes the motor power switch, which allows for the sensors, flight controller, and companion computer to be powered on while the motors are off. This is a safer way to test sensors, code, etc. as the motors are unable to spin while the switch is off.</p> <p></p> <p>Your needs will likely be slightly different than what is shown. This is meant as an example only and can be adapted to fit your needs.</p>"},{"location":"user-guide/hardware-setup/#motor-layouts","title":"Motor Layouts","text":"<p>The desired mixer can be chosen by setting the <code>MIXER</code> parameter to the following values:</p> # Mixer 0 ESC calibration 1 Quad + 2 Quad X 3 Hex + 4 Hex X 5 Octo + 6 Octo X 7 Y6 8 X8 9 Tricopter 10 Fixed-wing (traditional AETR) <p>The associated motor layouts are shown below for each mixer. The ESC calibration mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.</p> <p></p> <p></p>"},{"location":"user-guide/hardware-setup/#connecting-to-the-flight-controller","title":"Connecting to the Flight Controller","text":"<p>The flight controller communicates with the companion computer over a serial link. ROSflight only supports one serial connection at a time and by default should be the serial link connected to the USB connector on the board.</p>"},{"location":"user-guide/hardware-setup/#using-secondary-serial-links","title":"Using Secondary Serial Links","text":"<p>In the case of an F4 flight controller, which has a USB peripheral, the highest bandwidth connection will be the USB connector. However, UART3 can also be used to communicate with the companion computer if you desire a more secure connection (micro USB connectors have been known to disconnect in high vibrations).</p> <p>If a USB connection is detected on the USB peripheral, ROSflight will direct all communication through this port. However, if the <code>PARAM_SERIAL_DEVICE</code> parameter is set to <code>3</code> and the <code>PARAM_BAUD_RATE</code> parameter is set properly, then UART3 will be enabled when the USB connection is absent.</p>"},{"location":"user-guide/improving-firmware-performance/","title":"Improving Firmware Performance","text":"<p>ROSflight supplies several methods to improve the performance of your aircraft. Tuning gains, adding feed-forward torques, and tuning the estimator are three ways to get your aircraft flying great!</p>"},{"location":"user-guide/improving-firmware-performance/#gain-tuning","title":"Gain Tuning","text":"<p>Because there are a wide variety of multirotors out there, no one set of PID controller gains will be optimal for all vehicles. The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases. However, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably. There are some great tutorials online on multirotor gain tuning; this is another tried-and-true method used to great effect at BYU.</p> <p>If you are unfamiliar with PIDs, you should probably go read about them before trying to tune a multirotor. Getting an understanding for what is going on will definitely guide your decision making process as you try to find better gains.</p> <p>While tuning controller gains, it is very likely that the multirotor will oscillate out of control. To handle this scenario, we generally add what we call \"training wheels\" to the multirotors we are tuning. These amount to thin carbon rods in the shape of an X zip-tied to the landing gear. This widens out the base of the multirotor so if you come down on a hard oscillation, chances are the vehicle will land upright, hopefully without a prop strike, or worse, battery damage with a thermal runaway event. If the battery is not tucked inside the main frame, it is wise to add some foam as protection to the battery.</p> <p>Here is a video of a maiden flight of ROSflight with \"training wheels\" attached.</p> <p>Now, for the procedure on tuning.</p>"},{"location":"user-guide/improving-firmware-performance/#tuning-roll-and-pitch-angles","title":"Tuning Roll and Pitch angles","text":"<p>Here is a flowchart describing my PID tuning process for roll and pitch:</p> <p></p> <p>You may want to do another D-tuning iteration. Additionally, sometimes it is helpful to do a little tweaking on roll and pitch separately to eek out a little more performance from the differences in roll and pitch dynamics of your vehicle.</p> <p>Notice that we did not include any <code>I</code> tuning. As a general rule, try to keep the <code>I</code> gain as low as possible. It will always slow your response rate to input, and it can induce low frequency oscillations.</p> <p>You should only have <code>I</code> gain on roll and pitch if one of the following is true:</p> <ol> <li>You expect your CG to change, and/or</li> <li>You expect your rotor geometry to change</li> </ol> <p>Both of these are pretty rare. Instead, use your RC transmitter to trim the aircraft so it hovers with no stick input. In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on the roll, pitch and yaw rates.</p>"},{"location":"user-guide/improving-firmware-performance/#tuning-yaw-rate","title":"Tuning Yaw rate","text":"<p>Dynamically and algorithmically, using a <code>D</code> gain in yaw-rate control has no significant advantage. Controlling with derivative requires differentiating gyro measurements, which tends to be pretty noisy. In our experience, putting <code>D</code> in rate controllers on multirotors has always decreased performance.</p> <p>Tuning yaw rate is generally pretty easy. Basically, keep cranking it up until you feel like it's \"locked in\". Sometimes, a little bit of <code>I</code> (on the order of 0.1P) can help with this as well.</p> <p>The problem with too much <code>P</code> on yaw rate generally manifests itself in motor saturation. Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat. After you are done tuning, you might want to look at a plot of motor commands during a fairly aggressive flight. Underactuated yaw will be pretty obvious in these plots, because you will see the motor commands railing. To fix this, you can put shims between the arm mounts and the motors to tilt the motors just a little bit in the direction of yaw for that motor.</p>"},{"location":"user-guide/improving-firmware-performance/#rc-trim","title":"RC trim","text":"<p>In the vast majority of cases, your multirotor will not be built perfectly. The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different. One way to fix this is by adding an integrator. Integrators get rid of static offsets such as those just mentioned. However, as explained above, integrators also always slow vehicle response. In our case, since this offset is going to be constant, we can instead find a \"feed-forward\", or equilibrium offset, torque that you need to apply to hover without drift.</p> <p>Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level. This is done by trimming the aircraft with the RC trims. These are usually the little switches next to the sticks on your transmitter. Adjust these until you can hover the multirotor without touching the sticks.</p> <p>Next, land the multirotor, disarm, center the sticks and perform a trim calibration with <code>ros2 service call /calibrate_rc_trim std_srvs/srv/Trigger</code>. ROSflight then uses the trim settings on your transmitter to find these feed-forward, or equilibrium, torques that need to be applied post-controller to keep the multirotor level. These torques will be applied to all future commands (both from the companion computer and RC), so you will need to zero out your transmitter trims after calibration.</p>"},{"location":"user-guide/improving-firmware-performance/#estimator-tuning","title":"Estimator Tuning","text":"<p>ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \"Non-linear complementary filters on the special orthogonal group\" by Robert Mahony<sup>1</sup>,  to estimate attitude and angular rates. The implementation has been improved with suggestions from \"Attitude Representation and Kinematic Propagation for Low-Cost UAVs\" by Robert Casey<sup>2</sup>. A write-up of the derivation and implementation details can be found in the LaTeX report in <code>reports/estimator.tex</code>. (You'll need to be able to compile LaTeX sources to view the PDF).</p> <p>In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations. A block diagram of the estimator is shown below for reference. y_{gyro} and y_{acc} are gyro and accelerometer measurements, respectively and \\beta_{gyro} is the estimated gyro biases.</p> <p></p>"},{"location":"user-guide/improving-firmware-performance/#tuning-the-low-pass-filter-gains","title":"Tuning the Low-Pass Filter Gains","text":"<p>The <code>ACC_LPF_ALPHA</code> and <code>GYRO_LPF_ALPHA</code> parameters are used in the following low-pass-filter implementation (see lines <code>98-106</code> of <code>estimator.c</code>):</p> x_t = (1-\\alpha)y_t + \\alpha x_{t-1} <p>where y_t is the measurement and x_t is the filtered value. Lowering \\alpha will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \\alpha. Reducing \\alpha too far, however will result in a lot of noise from the sensors making its way into the motors. This can cause motors to get really hot, so make sure you check motor temperature if you are changing the low-pass filter constants.</p>"},{"location":"user-guide/improving-firmware-performance/#tuning-the-complementary-filter","title":"Tuning the Complementary Filter","text":"<p>The complementary filter has two gains, k_p and k_i. For a complete understanding of how these work, we recommend reading the Mahony Paper, or the technical report in the reports folder. In short, k_p can be thought of as the strength of accelerometer measurements in the filter, and the k_i gain is the integral constant on the gyro bias. These values should probably not be changed. Before you go changing these values, make sure you completely understand how they work in the filter.</p> <p>If you do decide to change these values, you should stick to the following rule of thumb.</p> k_i \\approx \\tfrac{k_p}{10}."},{"location":"user-guide/improving-firmware-performance/#external-attitude-measurements","title":"External Attitude Measurements","text":"<p>Because the onboard attitude estimator uses only inertial measurements, the estimates can deviate from truth. This is especially true during extended periods of accelerated flight, during which the gravity vector cannot be measured. Attitude measurements from an external source can be applied to the filter to help improve performance. These external attitude measurements might come from a higher-level estimator running on the companion computer that fuses additional information from GPS, vision, or a motion capture system.</p> <p>To send these updates to the flight controller, publish a <code>geometry_msgs/Quaternion</code> message to the <code>external_attitude</code> topic to which <code>rosflight_io</code> subscribes. The degree to which this update will be trusted is tuned with the <code>FILTER_KP_EXT</code> parameter.</p> <ol> <li> <p>Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0\u21a9</p> </li> <li> <p>Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/overview/","title":"Overview","text":""},{"location":"user-guide/overview/#main-components-of-rosflight","title":"Main Components of ROSflight","text":"<p>ROSflight is intended to be used with both a typical flight controller and a companion Linux computer. Although it can be used with just a flight controller, this setup will not offer most of the advantages of ROSflight.</p> <p>Note</p> <p>To avoid confusion, we try to consistently use the following terminology:</p> <ul> <li>Flight controller: The embedded board that runs the ROSflight firmware and performs I/O with sensors and ESCs</li> <li>Companion computer: A Linux computer, running ROS2, that is mounted on the vehicle and has a physical, serial connection with the flight controller</li> <li>Offboard control (setpoints): The control setpoints passed from the companion computer to the flight controller. The control is \"offboard\" from the perspective of the flight controller, even though the computer providing those commands is mounted onboard the vehicle.</li> </ul> <p>The following figure illustrates the interactions between the major components of the system:</p> <p></p>"},{"location":"user-guide/overview/#firmware","title":"Firmware","text":"<p>The ROSflight firmware is the low level microcontroller code that runs on the flight controller. This communicates directly with sensors and actuators and serves as the bridge between hardware and higher level software. The firmware itself is designed to do as little as possible, offloading most of the work to the companion computer.</p> <p>Although higher level control is offloaded to the companion computer, enough control and functionality is included in the firmware to enable a safety pilot to fly the UAV through any portion of the flight with or without an operating companion computer.</p>"},{"location":"user-guide/overview/#rosflight-io","title":"ROSflight IO","text":"<p>ROSflight IO is a ROS2 node that runs on the companion computer that communicates directly with the firmware over a serial connection. This serves as the bridge between the firmware and the rest of ROS2 network.</p>"},{"location":"user-guide/overview/#rosplane-and-roscopter","title":"ROSplane and ROScopter","text":"<p>ROSplane and ROScopter are ROS2 based autonomy stacks that run on the companion computer and do most of the heavy computation of the autopilot. Each portion of their autonomy stacks are organized into highly modular ROS nodes that can be easily swapped out with custom nodes.</p> <p>ROSplane and ROScopter are not required for using ROSflight and you could choose to use an entirely different autonomy stack if you so desired.</p>"},{"location":"user-guide/overview/#rc-safety-pilot","title":"RC Safety Pilot","text":"<p>ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer:</p> <ul> <li>RC override switch: The safety pilot can flip a switch on the transmitter to take back RC control. Attitude and throttle override can be mapped independently, meaning you can choose one or the other, put them on separate switches, or put them both on the same switch. Details on these switches are provided on the RC configuration page.</li> <li>Stick deviations: If a stick is deviated from its center position, then that channel is overridden by RC control. This allows the safety pilot to take control without flipping a switch. This may be useful to provide a momentary correction on a single axis. The fraction of stick travel needed to activate the RC override is controlled by the <code>RC_OVRD_DEV</code> parameter. The <code>OVRD_LAG_TIME</code> parameter controls the amount of time that the override remains active after the sticks return to center.</li> <li>Minimum throttle: By default, the flight controller takes the minimum of the two throttle commands from RC and offboard control setpoints. This allows the safety pilot to drop the throttle quickly if needed. This behavior can be turned on or off with the <code>MIN_THROTTLE</code> parameter.</li> </ul>"},{"location":"user-guide/overview/#arming-errors-failsafe","title":"Arming, Errors &amp; Failsafe","text":"<p>The flight controller can only be armed and disarmed via RC control. Two mechanisms are provided: sticks (left stick down and right to arm, down and left to disarm) and switch. Only one of these options can be active at a time. Details on configuration are given on the RC configuration page.</p> <p>The firmware runs a number of error checks before allowing the flight controller to arm. Completing the configuration checklist on the Getting Started page should avoid these errors. In addition to a few internal health checks, the following conditions are checked:</p> <ul> <li>Mixer: Valid mixer must have been selected (see the Hardware Setup documentation page)</li> <li>IMU calibration: The IMU must have been calibrated since firmware was flashed (it is recommended that you recalibrate often)</li> <li>RC: There must be an active RC connection</li> </ul> <p>In addition to the error checking before arming, the flight controller enters a failsafe mode if the RC connection is lost during flight while armed. While in failsafe mode the flight controller commands level flight with the throttle value defined by the <code>FAILSAFE_THR</code> parameter.</p> <p>The following is a simplified version of the finite state machine that defines logic used for the arming, error checks, and failsafe operations:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults if one were to occur, although this is unlikely with unmodified firmware. If a hard fault occurs while the flight controller is armed, the firmware has the ability to immediately rearm after rebooting to enable continued RC control of the vehicle for recovery.</p>"},{"location":"user-guide/overview/#leds","title":"LEDs","text":"<p>The meaning of the various LEDs is summarized in the following table. The colors of the LEDs may change depending on your specific board:</p> LED On Off Slow Blink Fast Blink Power (Blue) Board powered - - - Info (Green) RC control Offboard control - - Warning (Red) Armed Disarmed Error (disarmed) Failsafe (armed)"},{"location":"user-guide/parameter-configuration/","title":"Parameters","text":"<p>The ROSflight firmware has several dozen parameters which it uses to customize performance. Parameters are considered semi-static variables. That is, parameters do not change during flight, but they may change between vehicles. Examples of parameters you may wish to change are:</p> <ul> <li>Fixed-wing vehicle flag</li> <li>PID gains</li> <li>Mixer choice</li> <li>IMU low-pass filter constant</li> <li>RC receiver type (PPM or SBUS)</li> </ul> <p>and so on. Access to all parameters is enabled via ROS2 services advertised by <code>rosflight_io</code> while the flight controller is connected.</p>"},{"location":"user-guide/parameter-configuration/#parameter-interface","title":"Parameter Interface","text":""},{"location":"user-guide/parameter-configuration/#getting-parameter-values","title":"Getting Parameter Values","text":"<p>Sometimes it is handy to ask the flight controller what the current value of a parameter is. This is accomplished using the <code>param_get</code> service. As an example, let's retrieve the roll angle controller proportional (P) gain.</p> <pre><code>ros2 service call /param_get rosflight_msgs/srv/ParamGet \"{name: \"PID_ROLL_ANG_P\"}\"\n</code></pre> <p>You should get a response similar to the following (this happens to be the default value with floating-point error):</p> <pre><code>exists: True\nvalue: 0.15000000596\n</code></pre>"},{"location":"user-guide/parameter-configuration/#changing-parameters","title":"Changing Parameters","text":"<p>Parameters are changed via the <code>param_set</code> service. As an example, let's change the roll angle controller P gain. (I will assume that the flight controller is connected and <code>rosflight_io</code> is running in the root namespace.)</p> <pre><code>ros2 service call /param_set rosflight_msgs/srv/ParamSet \"{name: \"PID_ROLL_ANG_P\", value: 0.08}\"\n</code></pre> <p>You should get a prompt from <code>rosflight_io</code> saying <pre><code>[ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08\n[ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters\n</code></pre></p> <p>Notice that the parameters have been set, but not saved. Parameter changes take effect immediately, however they will not persist over a reboot unless you write them to the non-volatile memory. This brings us to the next task.</p>"},{"location":"user-guide/parameter-configuration/#writing-parameters","title":"Writing Parameters","text":"<p>To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory. This is done by calling <code>param_write</code></p> <pre><code>ros2 service call /param_write std_srvs/srv/Trigger\n</code></pre> <p><code>rosflight_io</code> should then respond with <pre><code>[ INFO] [1491672597.123201952]: Param write succeeded\n[ INFO] [1491672597.123452908]: Onboard parameters have been saved\n</code></pre></p> <p>Warning</p> <p>It is highly recommended that you write parameters before arming and flying the vehicle. Among other things, this will ensure that in the rare case that a hard fault is encountered and the flight controller must reboot during flight, the correct configuration will be loaded on reboot.</p> <p>Error</p> <p>Parameter writing can only happen if the flight controller is disarmed. If the param write failed for some reason, you may want to make sure your FC is disarmed and try again.</p>"},{"location":"user-guide/parameter-configuration/#backing-up-and-loading-parameters-from-file","title":"Backing Up and Loading Parameters from File","text":"<p>It is good practice to back up your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles. We can do this via the <code>param_save_to_file</code> and <code>param_load_from_file</code> services.</p> <p>First, let's back up our current parameter configuration:</p> <pre><code>ros2 service call /param_save_to_file rosflight_msgs/srv/ParamFile \"{filename: \"~/parameters.yaml\"}\"\n</code></pre> <p>Parameters are saved in YAML format. You must also specify the absolute file name of where you would like your parameters to be saved. The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller.</p> <p>Now, let's say we want to re-load this parameter file <pre><code>ros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"{filename: \"~/parameters.yml\"}\"\n</code></pre> Again, you must specify the absolute file name of the file to be loaded.</p>"},{"location":"user-guide/parameter-configuration/#fixed-wing-parameter-configuration","title":"Fixed-Wing Parameter Configuration","text":"<p>Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed-wing aircraft.</p> Parameter Description Type Fixed-Wing Value MOTOR_PWM_UPDATE Refresh rate of motor commands to motors and servos (Hz) - See motor documentation int 50 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_PWM int false MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 ARM_CHANNEL RC switch channel mapped to arming [0 indexed, -1 to disable] int 4 FIXED_WING switches on passthrough commands for fixed-wing operation int true MIXER Which mixer to choose - See Mixer documentation int 10 ELEVATOR_REV reverses elevator servo output int 0/1 AIL_REV reverses aileron servo output int 0/1 RUDDER_REV reverses rudder servo output int 0/1 CAL_GYRO_ARM Calibrate gyros when arming - generally only for multirotors int false"},{"location":"user-guide/parameter-configuration/#description-of-all-parameters","title":"Description of all Parameters","text":"<p>This is a list of all ROSflight parameters, including their types, default values, and minimum and maximum recommended values:</p> Parameter Description Type Default Value Min Max BAUD_RATE Baud rate of MAVlink communication with companion computer int 921600 9600 921600 SERIAL_DEVICE Serial Port (for supported devices) int 0 0 3 SYS_ID Mavlink System ID int 1 1 255 STRM_HRTBT Rate of heartbeat stream (Hz) int 1 0 1000 STRM_STATUS Rate of status stream (Hz) int 10 0 1000 STRM_ATTITUDE Rate of attitude stream (Hz) int 200 0 1000 STRM_IMU Rate of IMU stream (Hz) int 250 0 1000 STRM_MAG Rate of magnetometer stream (Hz) int 50 0 75 STRM_BARO Rate of barometer stream (Hz) int 50 0 100 STRM_AIRSPEED Rate of airspeed stream (Hz) int 50 0 50 STRM_SONAR Rate of sonar stream (Hz) int 40 0 40 STRM_SERVO Rate of raw output stream int 50 0 490 STRM_RC Rate of raw RC input stream int 50 0 50 STRM_GNSS Maximum rate of GNSS data streaming. Higher values allow for lower latency int 1000 0 1000 STRM_GNSS_FULL Maximum rate of fully detailed GNSS data streaming int 0 0 10 STRM_BATTERY Rate of battery status stream int 0 0 50 PARAM_MAX_CMD saturation point for PID controller output float 1.0 0 1.0 PID_ROLL_RATE_P Roll Rate Proportional Gain float 0.070f 0.0 1000.0 PID_ROLL_RATE_I Roll Rate Integral Gain float 0.000f 0.0 1000.0 PID_ROLL_RATE_D Roll Rate Derivative Gain float 0.000f 0.0 1000.0 PID_PITCH_RATE_P Pitch Rate Proportional Gain float 0.070f 0.0 1000.0 PID_PITCH_RATE_I Pitch Rate Integral Gain float 0.0000f 0.0 1000.0 PID_PITCH_RATE_D Pitch Rate Derivative Gain float 0.0000f 0.0 1000.0 PID_YAW_RATE_P Yaw Rate Proportional Gain float 0.25f 0.0 1000.0 PID_YAW_RATE_I Yaw Rate Integral Gain float 0.0f 0.0 1000.0 PID_YAW_RATE_D Yaw Rate Derivative Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_P Roll Angle Proportional Gain float 0.15f 0.0 1000.0 PID_ROLL_ANG_I Roll Angle Integral Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_D Roll Angle Derivative Gain float 0.05f 0.0 1000.0 PID_PITCH_ANG_P Pitch Angle Proportional Gain float 0.15f 0.0 1000.0 PID_PITCH_ANG_I Pitch Angle Integral Gain float 0.0f 0.0 1000.0 PID_PITCH_ANG_D Pitch Angle Derivative Gain float 0.05f 0.0 1000.0 X_EQ_TORQUE Equilibrium torque added to output of controller on x axis float 0.0f -1.0 1.0 Y_EQ_TORQUE Equilibrium torque added to output of controller on y axis float 0.0f -1.0 1.0 Z_EQ_TORQUE Equilibrium torque added to output of controller on z axis float 0.0f -1.0 1.0 PID_TAU Dirty Derivative time constant - See controller documentation float 0.05f 0.0 1.0 MOTOR_PWM_UPDATE Overrides default PWM rate specified by mixer if non-zero - Requires reboot to take effect int 0 0 490 MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 0.0 1.0 FAILSAFE_THR Throttle sent to motors in failsafe condition (set just below hover throttle) float 0.3 0.0 1.0 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_THR int true 0 1 FILTER_INIT_T Time in ms to initialize estimator int 3000 0 100000 FILTER_KP estimator proportional gain - See estimator documentation float 0.5f 0 10.0 FILTER_KI estimator integral gain - See estimator documentation float 0.01f 0 1.0 FILTER_KP_COR estimator proportional gain on external attitude correction - See estimator documentation float 10.0f 0 1.0 FILTER_ACCMARGIN allowable accel norm margin around 1g to determine if accel is usable float 0.1f 0 1.0 FILTER_QUAD_INT Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors) int 1 0 1 FILTER_MAT_EXP 1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration int 1 0 1 FILTER_USE_ACC Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop) int 1 0 1 CAL_GYRO_ARM True if desired to calibrate gyros on arm int false 0 1 GYROXY_LPF_ALPHA Low-pass filter constant on gyro X and Y axes - See estimator documentation float 0.3f 0 1.0 GYROZ_LPF_ALPHA Low-pass filter constant on gyro Z axis - See estimator documentation float 0.3f 0 1.0 ACC_LPF_ALPHA Low-pass filter constant on all accel axes - See estimator documentation float 0.5f 0 1.0 GYRO_X_BIAS Constant x-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Y_BIAS Constant y-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Z_BIAS Constant z-bias of gyroscope readings float 0.0f -1.0 1.0 ACC_X_BIAS Constant x-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Y_BIAS Constant y-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Z_BIAS Constant z-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_X_TEMP_COMP Linear x-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Y_TEMP_COMP Linear y-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Z_TEMP_COMP Linear z-axis temperature compensation constant float 0.0f -2.0 2.0 MAG_A11_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A12_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A13_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A21_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A22_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A23_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A31_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A32_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A33_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_X_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Y_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Z_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 BARO_BIAS Barometer measurement bias (Pa) float 0.0f 0 inf GROUND_LEVEL Altitude of ground level (m) float 1387.0f -1000 10000 DIFF_PRESS_BIAS Differential Pressure Bias (Pa) float 0.0f -10 10 RC_TYPE Type of RC input 0 - PPM, 1 - SBUS int 0 0 1 BATT_VOLT_MULT Battery monitor voltage multiplier float 0 0 inf BATT_CURR_MULT Battery monitor current multiplier float 0 0 inf BATT_VOLT_ALPHA Batter monitor voltage filter alpha. Values closer to 1 smooth the signal more. float 0.995 0 1 BATT_CURR_ALPHA Battery monitor current filter alpha. Values closer to 1 smooth the signal more. float 0.995 0 1 RC_X_CHN RC input channel mapped to x-axis commands [0 - indexed] int 0 0 3 RC_Y_CHN RC input channel mapped to y-axis commands [0 - indexed] int 1 0 3 RC_Z_CHN RC input channel mapped to z-axis commands [0 - indexed] int 3 0 3 RC_F_CHN RC input channel mapped to F-axis commands [0 - indexed] int 2 0 3 RC_ATT_OVRD_CHN RC switch mapped to attitude override [0 indexed, -1 to disable] int 4 4 7 RC_THR_OVRD_CHN RC switch channel mapped to throttle override [0 indexed, -1 to disable] int 4 4 7 RC_ATT_CTRL_CHN RC switch channel mapped to attitude control type [0 indexed, -1 to disable] int -1 4 7 ARM_CHANNEL RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable] int -1 4 7 RC_NUM_CHN number of RC input channels int 6 1 8 SWITCH_5_DIR RC switch 5 toggle direction int 1 -1 1 SWITCH_6_DIR RC switch 6 toggle direction int 1 -1 1 SWITCH_7_DIR RC switch 7 toggle direction int 1 -1 1 SWITCH_8_DIR RC switch 8 toggle direction int 1 -1 1 RC_OVRD_DEV RC stick deviation from center for override float 0.1 0.0 1.0 OVRD_LAG_TIME RC stick deviation lag time before returning control (ms) int 1000 0 100000 MIN_THROTTLE Take minimum throttle between RC and computer at all times int true 0 1 RC_ATT_MODE Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set. int 1 0 1 RC_MAX_ROLL Maximum roll angle command sent by full deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_PITCH Maximum pitch angle command sent by full stick deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_ROLLRATE Maximum roll rate command sent by full stick deflection of RC sticks float 3.14159f 0.0 9.42477796077 RC_MAX_PITCHRATE Maximum pitch command sent by full stick deflection of RC sticks float 3.14159f 0.0 3.14159 RC_MAX_YAWRATE Maximum pitch command sent by full stick deflection of RC sticks float 1.507f 0.0 3.14159 MIXER Which mixer to choose - See Mixer documentation int Mixer::INVALID_MIXER 0 10 FIXED_WING switches on pass-through commands for fixed-wing operation int false 0 1 ELEVATOR_REV reverses elevator servo output int 0 0 1 AIL_REV reverses aileron servo output int 0 0 1 RUDDER_REV reverses rudder servo output int 0 0 1 FC_ROLL roll angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_PITCH pitch angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_YAW yaw angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 ARM_THRESHOLD RC deviation from max/min in yaw and throttle for arming and disarming check (us) float 0.15 0 500 OFFBOARD_TIMEOUT Timeout in milliseconds for offboard commands, after which RC override is activated int 100 0 100000"},{"location":"user-guide/preflight-checks/","title":"Pre-Flight Checklist","text":"<p>This is an example of a ROSflight pre-flight checklist. You will likely need to augment this with checks specific to both (a) your hardware and (b) the code running on your companion computer.</p>"},{"location":"user-guide/preflight-checks/#before-powering-up-motors","title":"Before powering up motors","text":"<ul> <li> ROS2 is running on the companion computer, communicating with the base station</li> <li> <code>rosflight_io</code> reports no errors</li> <li> Sensors are calibrated and publishing<ul> <li> IMU (re-calibrate every flight): <code>ros2 service call /calibrate_imu std_srvs/srv/Trigger</code></li> <li> Barometer: <code>ros2 service call /calibrate_baro std_srvs/srv/Trigger</code></li> <li> Sonar (if attached)</li> <li> Airspeed (if attached)</li> </ul> </li> <li> Estimated attitude is being published and looks accurate</li> <li> Published outputs look reasonable</li> <li> Parameter Check (if using a fixed-wing, there are about 8 parameters you will need to change from default)</li> <li> RC communication</li> <li> Failsafe behavior</li> <li> Arming and disarming</li> <li> RC override behavior</li> <li> RC range test</li> <li> Wire-wiggle test (wiggle all wires to look for bad connections)</li> <li> If desired, logging is turned on (e.g. recording a ros2 bag)</li> </ul>"},{"location":"user-guide/preflight-checks/#after-powering-up-motors","title":"After Powering Up Motors","text":"<p>Danger</p> <p>Be sure the flight controller is disarmed before powering up motors!!!</p> <ul> <li> Arm/Disarm test</li> <li> Propeller spin test (check directions and response to stick inputs)</li> <li> Control surface test (fixed-wing)</li> <li> Response to offboard controls</li> </ul>"},{"location":"user-guide/rc-configuration/","title":"RC Configuration","text":""},{"location":"user-guide/rc-configuration/#binding-your-transmitter-to-your-receiver","title":"Binding your Transmitter to your Receiver","text":"<p>Follow the instructions in your user manual to bind your transmitter to your RC receiver. You may also be able to find a guide on YouTube with instructions; just search for your particular transmitter and receiver model.</p>"},{"location":"user-guide/rc-configuration/#rc-transmitter-calibration","title":"RC Transmitter Calibration","text":"<p>To avoid confusion and to reduce code complexity in the firmware source code, ROSflight does not perform software calibration of RC transmitters. This means that RC calibration must be done on the transmitter itself, as opposed to in software. This is pretty straight-forward for most modern transmitters.</p>"},{"location":"user-guide/rc-configuration/#configure-the-full-stick-output-for-each-channel","title":"Configure the full stick output for each channel","text":"<p>The easiest way to do this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable. You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from <code>rosflight_io</code></p> <pre><code>ros2 topic echo /rc_raw\n</code></pre> <ul> <li>Center both sticks on your transmitter</li> <li>Apply subtrim until the first four channels all read 1500 exactly (or as close as possible--some RC receivers are worse than others and cannot exactly output 1500 us)</li> <li>Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us.</li> </ul>"},{"location":"user-guide/rc-configuration/#configure-stick-directions-for-roll-pitch-and-yaw-channels","title":"Configure stick directions for roll, pitch, and yaw channels.","text":"<p>You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight.</p> <p>You may find this graphic helpful. It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from <code>rosflight_io</code>. Make sure that the stick output is in the correct direction.</p> <p></p> <p>It should be noted that channel assignment can be modified via the <code>RC_*_CHN</code> parameters. So, if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.</p>"},{"location":"user-guide/rc-configuration/#switch-configuration","title":"Switch Configuration","text":"<p>Switches can be configured for the following functions. To disable a switch for a specific, default function, set the corresponding parameter to <code>-1</code>. Be sure to check that the switch directions operate as you intend, and reverse them in your transmitter if necessary.</p>"},{"location":"user-guide/rc-configuration/#safety-pilot-configuration","title":"Safety Pilot Configuration","text":"<p>The <code>RC_ATT_OVRD_CHN</code> parameter maps a switch to override attitude commands with RC control. The <code>RC_THR_OVRD_CHN</code> parameter maps a switch to override throttle commands with RC control. To override both with a single switch, set both parameters to the same value (this is the default behavior).</p>"},{"location":"user-guide/rc-configuration/#arming","title":"Arming","text":"<p>By default, arming is done with the sticks (left stick down and right to arm, down and left to disarm). To use a switch instead, set the <code>ARM_CHANNEL</code> parameter to the desired channel. Setting an arming switch disables arming with the sticks.</p>"},{"location":"user-guide/rc-configuration/#flight-mode","title":"Flight Mode","text":"<p>If desired, you can map a switch to select between attitude control types (angle and rate) in flight by setting the <code>RC_ATT_CTRL_CHN</code> parameter to the desired channel. This can be useful if, for example, you are learning rate mode but want to be able to switch back to attitude mode to help stabilize the vehicle. This feature is disabled by default.</p>"},{"location":"user-guide/ros2-setup/","title":"Installing/Setting up ROS2","text":"<p>You will need to get ROS2 on both the companion computer and the base station laptop. This can be done with a native installation or with Docker. To install ROS2 natively, Check out the official ROS2 Installation page for details. Make sure to install both the <code>ros-humble-desktop</code> and <code>ros-dev-tools</code> packages, or the equivalent packages for your version of ROS2. <code>ros-humble-ros-base</code> can be used instead of <code>ros-humble-desktop</code> if you don't need GUI tools or the simulation.</p> <p>We support all fixed-release ROS2 versions that are not EOL, which currently includes ROS2 Humble and ROS2 Iron. ROS2 Rolling is not fixed-release and is therefore not officially supported. </p>"},{"location":"user-guide/ros2-setup/#installing-rosflight","title":"Installing ROSflight","text":"<p>You will need to install the ROSflight packages on both the companion computer and the base station computer. The companion computer will run the node that actually communicates with the flight controller over a serial connection, while the base station needs the message and service definitions to be able to call services or subscribe and publish to topics.</p>"},{"location":"user-guide/ros2-setup/#from-source","title":"From Source","text":"<p>First, set up a ROS2 workspace:</p> <pre><code>mkdir -p ~/rosflight_ws/src\ncd ~/rosflight_ws/src\n</code></pre> <p>Next, download the source code into your workspace (include the <code>--recursive</code> argument to download the necessary submodules): <pre><code>git clone --recursive https://github.com/rosflight/rosflight_ros_pkgs.git\n</code></pre> Install dependencies: <pre><code>sudo rosdep init\nrosdep update\nrosdep install -i --from-path ./ -y --ignore-src\n</code></pre> Build the packages: <pre><code>cd ~/rosflight_ws\ncolcon build\n</code></pre> Source the setup file and set it to be sourced automatically: <pre><code>source ~/rosflight_ws/install/setup.bash\necho \"source ~/rosflight_ws/install/setup.bash\" &gt;&gt; ~/.bashrc\n</code></pre></p> <p>Note</p> <p>You'll also need to source the file at <code>/usr/share/gazebo/setup.sh</code> if you plan to use the Gazebo simulator.</p>"},{"location":"user-guide/ros2-setup/#running-rosflight_io","title":"Running rosflight_io","text":"<p>The <code>rosflight_io</code> node is the bridge between ROS2 and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command: <pre><code>ros2 run rosflight_io rosflight_io --ros-args -p port:=/dev/ttyUSB0\n</code></pre> Replace <code>/dev/ttyUSB0</code> with the port your flight controller is connected to.</p>"},{"location":"user-guide/ros2-setup/#using-a-docker-container-to-run-ros2","title":"Using a Docker Container to run ROS2","text":"<p>Note</p> <p>This guide was written for using Linux as the host machine, but theoretically you should be able to use Docker to do the same thing on Mac or Windows. However, the specifics of the commands may be different. Please refer to the Docker documentation for information on how to use Docker on a non-Linux system.</p> <p>Tip</p> <p>This guide was written using ROS2 Humble Docker images, but any distribution of ROS can be used. Just replace <code>humble</code> with the name of the distribution you want to use.</p> <p>If you aren't running a compatible version of Ubuntu for ROS2, don't want to make changes to your system, want to be able to easily switch between ROS verions, or just want to containerize your applications then you can use Docker containers. To get started, install Docker Engine, sometimes referred to as Docker server.</p> <p>Docker works by running self-contained systems called containers, which act kind of like a separate computer system but without all the overhead of a full virtual machine. Docker containers are based on Docker images, which provide the initial operating system, files, and programs for the Docker container. Fortunately, the developers of ROS provide Docker images for nearly all versions of ROS, which makes it very easy to get any version of ROS up and running on your system very quickly.</p> <ul> <li>To start a Docker container with ROS run this command: <pre><code>docker run -it ros:humble\n</code></pre></li> </ul> <p>Once completed, you should enter a bash terminal in a fresh installation of Ubuntu and ROS! However, the container does not have access to any USB devices, source files on your system, or your network to be able to communicate with different computers. To do these things we'll need to add more arguments to the <code>docker run</code> command.</p> <ul> <li> <p>To give access to source file on your system, mount a folder on your system to the docker container with the <code>-v</code> argument: <pre><code>docker run -it -v /folder_to_mount_from_host:/location_to_mount_folder_in_container ros:humble\n</code></pre></p> </li> <li> <p>To give access to a USB device, you need to mount the location of the USB device and give the container sudo access to your host system with <code>--privileged</code>: <pre><code>docker run -it -v /dev/usb_to_mount:/dev/USB --privileged ros:humble\n</code></pre></p> </li> <li> <p>To give access to your network, specify the network to use as the host's network with <code>--network host</code>. <pre><code>docker run -it --network host ros:humble\n</code></pre></p> </li> </ul> <p>It is worth noting that every time you use the <code>docker run</code> command, a new container with those specific arguments are created. So, if you want a container with access to all those things, you need to use all the arguments at once.</p> <ul> <li>As an example, if I wanted to make a ROS2 Humble container with access to a USB device at <code>/dev/ttyUSB0</code>, access to my host network, access to the source files at <code>~/rosflight_ws</code>, and give the container a convenient name of <code>rosflight</code> with the <code>--name</code> argument, I would use this command: <pre><code>docker run --name rosflight -it -v /dev/ttyUSB0:/dev/USB --privileged --network host -v ~/rosflight_ws:/rosflight_ws ros:humble\n</code></pre></li> </ul> <p>Something the previous commands don't include is the ability to render GUI tools (like rqt_graph and Gazebo). Being able to render GUI tools can be done a number of ways, but an easy way is to give the container access to your system's X11 windowing system. Note that this isn't the most secure method and doesn't include GPU acceleration. (For more information about including GPU acceleration, refer to the guide found here.)</p> <ul> <li> <p>To give access to the host's windowing system, use the following commands. Note that the base Docker image is <code>osrf/ros:humble-desktop-full</code>, as <code>ros:humble</code> doesn't include GUI tools in the image. Also, <code>xhost +</code> needs to be run once per login session and is not persistent. <pre><code>xhost +\ndocker run -it --env=\"DISPLAY\" --env=\"QT_X11_NO_MITSHM=1\" --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" osrf/ros:humble-desktop-full\n</code></pre></p> </li> <li> <p>To create a GUI enabled ROS container named <code>rosflight</code> with access to the host network, source files found at <code>~/rosflight_ws</code>, and a USB device, use this command: <pre><code>docker run --name rosflight -it -v /dev/ttyUSB0:/dev/USB --privileged --network host -v ~/rosflight_ws:/rosflight_ws --env=\"DISPLAY\" --env=\"QT_X11_NO_MITSHM=1\" --volume=\"/tmp/.X11-unix:/tmp/.X11-unix:rw\" osrf/ros:humble-desktop-full\n</code></pre></p> </li> </ul> <p>Warning</p> <p>During testing, we found some strange behavior with ROS when running a GUI enabled container on a system with ROS already installed. If you need a GUI enabled system, try to do so on a system without ROS installed (or at the very least avoid sourcing/using ROS on your system). Also avoid having multiple GUI enabled containers running at once.</p> <p>Some other useful Docker commands:</p> <ul> <li> <p>To see all containers that exist on your system and their names: <pre><code>docker ps -a\n</code></pre></p> </li> <li> <p>To start a container named <code>rosflight</code> that was previously created with the <code>docker run</code> command: <pre><code>docker start -i rosflight\n</code></pre></p> </li> <li> <p>To open another bash terminal in a container named <code>rosflight</code> that is already running: <pre><code>docker exec -it rosflight bash\n</code></pre></p> </li> <li> <p>To delete a container named <code>rosflight</code>: <pre><code>docker rm rosflight\n</code></pre></p> </li> </ul> <p>You should now be able to create Docker containers with everything you need to run ROSflight! Docker is a very powerful tool and there is much more you can do with Docker to improve your development workflow. However, we're not interested in making an exhaustive Docker guide so please refer to the Docker documentation or other online guides to learn more.</p>"},{"location":"user-guide/roscopter-setup/","title":"ROScopter","text":"<p>ROScopter is still under development. Check the github repo for the latest instructions.</p>"},{"location":"user-guide/rosplane-setup/","title":"ROSplane","text":"<p>ROSplane is still under development. Check the github repo for the latest instructions.</p>"},{"location":"user-guide/running-gazebo-simulation/","title":"Running Simulations in Gazebo","text":"<p>ROSflight comes with a useful tool allowing it to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in Gazebo.</p>"},{"location":"user-guide/running-gazebo-simulation/#architecture-of-the-sil-simulation","title":"Architecture of the SIL Simulation","text":"<p>To best mimic the hardware experience of ROSflight, the SIL plugin for Gazebo actually implements the firmware source code as a library. We just implemented a different \"board layer\" which uses gazebo instead of hardware calls for things like <code>imu_read()</code> and <code>pwm_write()</code>. Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between <code>rosflight_io</code> and the firmware. This means the interface to the SIL plugin is identical to that of hardware. <code>rosflight_io</code> is the main gateway to the firmware in simulation, just as it is in hardware.</p> <p>The following table summarizes the correlation between connections in hardware and simulation:</p> Connection Type Hardware Simulation Serial communications to <code>rosflight_io</code> USB / UART UDP RC PPM Receiver ROS2 <code>RC</code> topic (<code>rosflight_msgs/RCRaw</code>) Motors PWM Gazebo Plugin Sensors SPI/I2C Gazebo Plugin"},{"location":"user-guide/running-gazebo-simulation/#quick-start-guide-to-sil-simulation","title":"Quick-Start Guide to SIL Simulation","text":"<p>Note</p> <p>To simulate a fixed-wing mav, just change all instances of <code>multirotor</code> in the steps below to <code>fixedwing</code>.</p> <ul> <li> <p>Setup ROSflight with the ROS2 Setup guide, making sure to install the <code>-desktop</code> package of ROS2, not the <code>-ros-base</code>.</p> </li> <li> <p>Source the Gazebo setup file if you haven't added it to <code>~/.bashrc</code>: <pre><code>source /usr/share/gazebo/setup.sh\n</code></pre></p> </li> <li> <p>Launch Gazebo with the ROSflight SIL: <pre><code>ros2 launch rosflight_sim multirotor.launch.py\n</code></pre></p> </li> <li> <p>Gazebo should now be running, and you should have the following <code>rqt_graph</code>.</p> </li> </ul> <p></p> <ul> <li> <p>At this point, you can't actually do anything because there is no RC connection and no <code>rosflight_io</code> to talk to the firmware. Let's start by running a <code>rosflight_io</code> node. In a separate terminal, run: <pre><code>ros2 run rosflight_io rosflight_io --ros-args -p udp:=true\n</code></pre></p> <ul> <li>The <code>udp</code> parameter tells <code>rosflight_io</code> to simulate a serial connection over UDP rather than using the USB connection to hardware</li> </ul> </li> </ul> <p>Your <code>rqt_graph</code> should look something like the following image. This looks funny because ROS2 doesn't actually know that there is a UDP connection between <code>rosflight_io</code> and gazebo. There is one, though, and you can test it by echoing any of the topics published by <code>rosflight_io</code>.</p> <p></p> <ul> <li>Start up a simulated RC connection. The easiest way to do this is with the ROSflight utility <code>rc_joy.py</code>. Connect a joystick to the computer (or transmitter) and run:      <pre><code>ros2 run rosflight_utils rc_joy.py --ros-args --remap /RC:=/multirotor/RC\n</code></pre>     This simulates the RC connection in hardware. If everything is mapped correctly, you should now be able to arm, disarm and fly the aircraft in simulation!</li> </ul> <p>Tip</p> <p>To start the Gazebo sim, rosflight_io node, and rc_joy.py utility all at once, run this command instead of the three commands individually: <pre><code>ros2 launch rosflight_utils multirotor_sim_io_joy.launch.py    \n</code></pre></p> <p>Note</p> <p>It is much easier to fly with a real transmitter than with an Xbox-type controller. FrSky Taranis QX7 transmitters, Radiomaster TX16s transmitters, and RealFlight controllers are also supported. Non-Xbox joysticks may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping!</p> <p>Remember, the SIL tries its best to replicate hardware. That means you have to calibrate and set parameters in the same way you do in hardware. See the Hardware Setup and Parameter Configuration pages in this documentation for instructions on how to perform all preflight configuration before the aircraft will arm. You can also run  <pre><code>ros2 launch rosflight_utils multirotor_init_firmware.launch.py\n</code></pre> to load all required parameters and perform initial calibrations for a quick simulation setup.</p>"}]}