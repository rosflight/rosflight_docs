{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-rosflight","title":"Welcome to ROSflight","text":"<p>The ROS2 updates for ROSflight are still under development. Please use with discretion.</p>"},{"location":"#what-is-rosflight","title":"What is ROSflight?","text":"<p>ROSflight is a lean and adaptable autopilot system designed from the ground up with researchers in mind. Its purpose is to enable researchers to quickly and easily try out new ideas with minimal effort. Some of ROSflight's key feature are:</p> <ul> <li>Lightweight, modular, and well documented code that is easy to understand and modify.</li> <li>Most of the autopilot exists on a Linux computer rather than a microcontroller, enabling easier development with increased capabilities.</li> <li>Seamless switching between simulation and hardware: no part of the autopilot knows if it is running in simulation or not.</li> <li>Built on a ROS2 framework, allowing easy integration with ROS2 based projects.</li> </ul> <p>See the user guide for more details on ROSflight.</p>"},{"location":"#why-rosflight","title":"Why ROSflight?","text":"<p>There are a lot of excellent autopilots out there with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Existing autopilots commonly used by researchers tend to have massive codebases under constant development that run primarily on microcontrollers.</p> <p>This presents a number of problems. First, we are limited in our ability to understand and control everything occurring within the autonomy stack, making much of the autopilot an untouchable black box. Second, we are limited to the abilities of microcontrollers and can't take advantage of the more powerful hardware and software that can be found on Linux computers. Third, maintaining up-to-date support for software or hardware projects becomes a lot of work as things are frequently changing.</p> <p>ROSflight is intended to fix these problems by being a lightweight, modular, and well documented codebase that offloads as much as possible to a ROS2 based framework running on a Linux computer.</p>"},{"location":"#our-vision","title":"Our Vision","text":"<p>Perhaps more important than what we are trying to accomplish is what we are not trying to accomplish. ROSflight is not intended to be a fully-featured autopilot with all the same functions of other autopilots, but instead serve as a core foundation that can easily be adapted to any use case.</p> <p>Therefore, one of our primary objectives is to avoid feature creep and remain lean. We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.</p>"},{"location":"developer-guide/contribution-guidelines/","title":"Contribution Guidelines","text":"<p>ROSflight is intended to be a streamlined, bare-bones autopilot. We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the project. In an attempt to avoid \"feature creep,\" we will be very discriminatory in merging pull requests whose purpose is to simply add features. Forking the repository in order to add features is totally acceptable and encouraged, just recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license).</p> <p>In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like. By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature. Please don't be offended if we ask you to modify the formatting of your code before approving a pull request.</p> <p>Although we strive for complete in-code documentation, in practice this sometimes gets left behind for the sake of rapid development. If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the appropriate GitHub issues page or forum, and encourage you to submit pull requests which improve documentation. Several new developers have started with first improving the documentation to get a handle on how things work.</p>"},{"location":"developer-guide/contribution-guidelines/#key-goals-of-rosflight","title":"Key Goals of ROSflight","text":"<p>Here is a summary of the key goals and philosophies behind ROSflight. As you look to make contributions to the project, keep these in mind.</p> <ul> <li> <p>Only include the things that most people will need. The goal of this would be to do most of the work so people can get a MAV in the air quickly and easily, but not overcomplicate the code with features that only a small portion of users would need.</p> </li> <li> <p>Be modular and adaptable for many research-centric use cases. This will be accomplished by putting the majority of the autopilot in a well-designed ROS2 framework. That which needs to be on the microcontroller will need to be done so carefully with good coding practices. Additionally, microcontroller code that is the most likely to be expanded upon should include clear interfaces and instructions for doing so.</p> </li> <li> <p>Keep everything simple and well documented. The key goal here is to minimize the amount of time and effort it takes someone to go from knowing nothing about ROSflight to being able to implement their own features and making meaningful progress with their research.</p> </li> </ul>"},{"location":"developer-guide/contribution-guidelines/#communication","title":"Communication","text":"<p>There are two channels to communicate with the developer team. For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate GitHub issue page. For questions and other discussions, please use the forum.</p>"},{"location":"developer-guide/style-guide/","title":"Style Guide","text":""},{"location":"developer-guide/style-guide/#style-guide","title":"Style Guide","text":"<p>The focus of anyone contributing to this project should be to write code that is easily understood by anyone, including people who have little experience with ROSflight or coding in general. So, we ask that contributions adhere to the following style guidelines.</p>"},{"location":"developer-guide/style-guide/#comments","title":"Comments","text":"<p>Well written and clear code should be easy to understand even without comments. However, since this project is intended to be as accessible as possible, we ask that you write both clear code and clear comments. Don't use comments to explain code that would be difficult to understand without comments, but instead use them to make clear code even more understandable.</p>"},{"location":"developer-guide/style-guide/#doxygen","title":"Doxygen","text":"<p>Doxygen comments should be added pretty much anywhere where it makes sense. Please include at least a brief for anything you write. For methods and functions, also include explanations of all arguments and the return value. See the below example for the Doxygen style you should use. </p><pre><code>/**\n  * @brief Converts an LLA coordinate to NED coordinates\n  * \n  * @param lla: Array of floats of size 3, with [latitude, longitude, altitude]\n  * @return Array of doubles corresponding to the NED coordinates measured from the origin\n  */\nstd::array&lt;double, 3&gt; lla2ned(std::array&lt;float, 3&gt; lla);\n</code></pre><p></p> <p>More detailed explanations are encouraged for non-trivial methods and objects. For single-line Doxygen comments, three slashes is acceptable, e.g., <code>/// Comment here</code>.</p>"},{"location":"developer-guide/style-guide/#white-space-and-line-endings","title":"White Space and Line Endings","text":"<p>Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run <code>git diff --check</code> before you stage your files.</p>"},{"location":"developer-guide/style-guide/#code-style","title":"Code Style","text":"<p>ROSflight follows the ROS2 C++ style guide, with some more specific guidelines below. Please follow first the style guidelines below and then the ROS2 guidelines. A .clang-format file and format-correcting script is provided in most ROSflight repositories that can be used to auto-format your code to help you find things you might have missed.</p>"},{"location":"developer-guide/style-guide/#indentation","title":"Indentation","text":"<p>Indentation should be 2 spaces (no tabs).</p>"},{"location":"developer-guide/style-guide/#spaces","title":"Spaces","text":"<p>There should be a space between <code>if</code>, <code>for</code>, or <code>while</code> and the condition. </p><pre><code>// Correct\nwhile (true) { ... }\n\n// Incorrect\nwhile(true) { ... }\n</code></pre><p></p>"},{"location":"developer-guide/style-guide/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Class names should be CamelCase, that is, capitalized with no spaces (i.e. <code>StateManager</code>).</li> <li>Member variables should contain a post-pended underscore (i.e. <code>data_</code>).</li> <li>Member functions should be all lower case with underscores (i.e. <code>set_error()</code>).</li> <li>Boolean values should be assigned <code>true</code> or <code>false</code>, not <code>0</code> or <code>1</code>.</li> </ul>"},{"location":"developer-guide/style-guide/#classes","title":"Classes","text":"<p>All modules should be defined as a self-contained class. All member variables should be declared as \"private,\" named with a post-pended underscore. All accessible data should be encapsulated in a struct. For example, here is a snippet from the <code>Sensors</code> module in the firmware:</p> <pre><code>class Sensors\n{\npublic:\n  struct Data\n  {\n    vector_t accel = {0, 0, 0};\n    vector_t gyro = {0, 0, 0};\n    float imu_temperature = 0;\n    uint64_t imu_time = 0;\n\n    float diff_pressure_velocity = 0;\n    float diff_pressure = 0;\n    float diff_pressure_temp = 0;\n    bool diff_pressure_valid = false;\n\n    float baro_altitude = 0;\n    float baro_pressure = 0;\n    float baro_temperature = 0;\n    bool baro_valid = false;\n\n    float sonar_range = 0;\n    bool sonar_range_valid = false;\n\n    vector_t mag = {0, 0, 0};\n\n    bool baro_present = false;\n    bool mag_present = false;\n    bool sonar_present = false;\n    bool diff_pressure_present = false;\n  };\n\n  Sensors(ROSflight&amp; rosflight);\n\n  inline const Data &amp; data() const { return data_; }\n\nprivate:\n  Data data_;\n}\n</code></pre> <p>Note that <code>data_</code> is a private member variable, but the <code>Data</code> struct is declared publicly.</p>"},{"location":"developer-guide/style-guide/#enums","title":"Enums","text":"<p>Enums should be declared using the following style: </p><pre><code>enum ArmedState\n{\n  ARMED_STATE_INIT,\n  ARMED_STATE_DISARMED,\n  ARMED_STATE_ARMED\n};\n</code></pre><p></p> <p>The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.</p>"},{"location":"developer-guide/style-guide/#structs","title":"Structs","text":"<p>Structs should be declared using the following style: </p><pre><code>struct SomeValue\n{\n  int v1;\n  int v2;\n};\n</code></pre> Struct type names should be in CamelCase.<p></p>"},{"location":"developer-guide/style-guide/#globals","title":"Globals","text":"<p>The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals). This should only occur in board support layers and not in the core ROSflight libary code, ROSplane, or ROScopter.</p>"},{"location":"developer-guide/style-guide/#include-order","title":"Include Order","text":"<p>Include files at the top of your file in the following order:</p> <ol> <li>Standard library (e.g. <code>&lt;cstdint&gt;</code>)</li> <li>Files from external libraries included in the project (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, <code>&lt;mavlink/v1.0/common/mavlink.h&gt;</code>)</li> <li>Other header files from this project (e.g. <code>\"rosflight.h\"</code>)</li> <li>The header file for this specific source file</li> </ol> <p>Group the includes according to the above list with an empty line between each group. (For external libraries, you may subdivide group 2 into a group for each library.) The first two groups should use angle brackets (<code>&lt;&gt;</code>), and the last two groups should use quotation marks (<code>\"\"</code>). Files from external libraries should be namespaced by the library name (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, not <code>&lt;breezystm32.h&gt;</code>).</p> <p>Alphabetize the files within each group. Do not change the include order to fix build errors; if you have to do that it means you are not including a file somewhere that you should. Please fix it by including all the right files.</p> <p>Include C standard library headers using the C++ style (<code>#include &lt;cmath&gt;</code>) instead of the C style (<code>#include &lt;math.h&gt;</code>).</p> <p>For example, in <code>sensors.c</code> I might have: </p><pre><code>#include &lt;cstdbool&gt;\n#include &lt;cstdint&gt;\n\n#include &lt;breezystm32/breezystm32.h&gt;\n#include &lt;breezystm32/drv_mpu6050.h&gt;\n\n#include \"param.h\"\n\n#include \"sensors.h\"\n</code></pre><p></p>"},{"location":"developer-guide/style-guide/#namespacing","title":"Namespacing","text":"<p>All modules should be encapsulated in a package namespace that is unique and consistent within the package (like <code>rosflight_firmware</code> for anything in the firmware package).</p>"},{"location":"developer-guide/firmware/building-and-flashing/","title":"Building and Flashing","text":""},{"location":"developer-guide/firmware/building-and-flashing/#building-and-flashing-the-firmware","title":"Building and Flashing the Firmware","text":"<p>This guide assumes you are running Ubuntu 22.04 LTS, which is the currently supported development environment.</p>"},{"location":"developer-guide/firmware/building-and-flashing/#installing-the-arm-embedded-toolchain","title":"Installing the ARM Embedded Toolchain","text":"<pre><code>sudo apt install gcc-arm-none-eabi\n</code></pre> <p>You can test the installation and check which version is installed by running <code>arm-none-eabi-gcc --version</code>.</p>"},{"location":"developer-guide/firmware/building-and-flashing/#building-the-firmware-from-source","title":"Building the Firmware from Source","text":"<ol> <li>To build the firmware, first clone the firmware repository:     <pre><code>git clone --recursive https://github.com/rosflight/rosflight_firmware\n</code></pre></li> <li>Create build directory:     <pre><code>cd rosflight_firmware &amp;&amp; mkdir build &amp;&amp; cd build\n</code></pre></li> <li>Build using: (<code>board_name</code> should be either <code>varmint</code> or <code>pixracer_pro</code>)     <pre><code>cmake .. -DBOARD_TO_BUILD=&lt;board_name&gt; &amp;&amp; make -j\n</code></pre></li> </ol>"},{"location":"developer-guide/firmware/building-and-flashing/#flashing-firmware","title":"Flashing firmware","text":""},{"location":"developer-guide/firmware/building-and-flashing/#install-stm32cubeprogrammer","title":"Install STM32CubeProgrammer","text":"<p>We use the STM32CubeProgrammer to flash the flight controller.</p> <ol> <li>Download the programmer here.     You may have to enter your email to download the software.</li> <li>Install the software by following the instructions in the downloaded package.</li> </ol>"},{"location":"developer-guide/firmware/building-and-flashing/#flashing-the-varmint","title":"Flashing the Varmint","text":"<p>Needed tools</p> <p>You will need an ST-Link STM programmer to flash the firmware. We use ST-Link V2, and you can find it on Mouser.</p> <ol> <li> <p>Plug the end of the ribbon cable into the 6-pin slot on the Varmint.     You may have to make your own cable that connects the ST-Link to the 6-pin connector.</p> <p>Danger</p> <p>The Varmint has 2 6-pin connectors. Do not connect the ribbon cable to the port closest to the power wires.</p> <p></p> </li> <li> <p>Power on the Varmint by connecting a battery to the board.</p> </li> <li> <p>Open STM32CubeProgrammer.</p> </li> <li> <p>Plug in the USB connector from the ST-Link to the computer. Select \"Connect\" in the STM32CubeProgrammer. This should detect the ST-Link and connect automatically.     </p> </li> <li> <p>Navigate to the programming page.     </p> </li> <li> <p>Select the hex file that was just built and click \"Open\".     </p><pre><code>/path/to/rosflight_firmware/build/boards/varmint_h7/varmint_10X/varmint10X.hex\n</code></pre> <p></p> </li> <li> <p>Select the appropriate options and press \"Start Programming\"     </p> </li> </ol>"},{"location":"developer-guide/firmware/building-and-flashing/#flashing-the-pixracer-pro","title":"Flashing the Pixracer Pro","text":"<p>Flashing the Pixracer Pro is a very similar process to flashing the Varmint.</p> <ol> <li> <p>The Pixracer Pro does not use the same 6-pin connector to connect to the ST-Link.     Instead, it uses a TC2030 connector with retaining clips.</p> <p>Connectors we use</p> <p>In addition to the ST-Link V2 board linked above, we use these cables to flash the Pixracer Pro:</p> <ol> <li>20-pin ribbon adapter board (connect the ST-Link to this adapter)</li> <li>Programming cable that connects to the adapter board</li> <li>TC2030 clip to attach the programming cable to the board</li> </ol> <p></p> </li> <li> <p>Power on the Pixracer Pro using a USB-C port.</p> </li> <li> <p>Follow the instructions from the Varmint flashing guide.</p> </li> </ol>"},{"location":"developer-guide/firmware/code-architecture/","title":"Code Architecture","text":""},{"location":"developer-guide/firmware/code-architecture/#code-architecture","title":"Code Architecture","text":"<p>The firmware is divided into two main components: the core library, and a collection of board implementations. This division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the hardware abstraction layer (HAL). This architecture is illustrated in the following diagram:</p> <p></p>"},{"location":"developer-guide/firmware/code-architecture/#firmware-core-library","title":"Firmware Core Library","text":"<p>The firmware core library consists of all the code in the <code>include</code> and <code>src</code> directories of the firmware repository. This includes the code for what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, state manager, etc.) required for flight. It also includes the interface definition for the hardware abstraction layer, which is defined by the abstract <code>Board</code> class in <code>include/board.h</code>. The communications link (MAVLink) is also abstracted, with the interface defined by the <code>CommLink</code> class in <code>include/comm_link.h</code>. External libraries are contained in the <code>lib</code> folder.</p>"},{"location":"developer-guide/firmware/code-architecture/#board-abstraction","title":"Board Abstraction","text":"<p>The hardware abstraction implementations are contained in the <code>boards</code> directory, organized in subdirectories according to the hardware driver layer. Each board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack. The Varmint implementation in the <code>boards/varmint</code> shows how this is done for an embedded flight controller. Examples of board implementations for SIL simulation are found in the <code>rosflight_sim</code> ROS2 package available here.</p> <p>The flight stack is encapsulated in the <code>ROSflight</code> class defined at <code>include/rosflight.h</code>. This class contains two public functions: <code>init()</code> and <code>run()</code>. Its constructor requires two arguments: an implementation of the <code>Board</code> interface, and an implementation of the <code>CommLink</code> interface.</p> <p>Each board implementation is required to implement the entire Board class.</p>"},{"location":"developer-guide/firmware/code-architecture/#comm-link-abstraction","title":"Comm Link Abstraction","text":"<p>The purpose of the comm link abstraction layer is to allow communication protocols other than MAVLink to be used if desired. The comm link abstraction implementations are contained in the <code>comms</code> directory, organized in subdirectories by protocol. The implementations translate between the messages that the firmware expects to send and receive, and the messages defined by the communication protocol. Currently, only MAVLink is implemented.</p>"},{"location":"developer-guide/firmware/code-architecture/#flight-stack","title":"Flight Stack","text":"<p>The flight stack is encapsulated by the <code>ROSflight</code> class defined in <code>include/rosflight.h</code>. It consists of a collection of modules. Each of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality. The following diagram illustrates these modules and the data flow between them. Rectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer:</p> <p></p> <p>We'll describe each of these modules in the following sections:</p>"},{"location":"developer-guide/firmware/code-architecture/#state-manager","title":"State Manager","text":"<p>This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle. While only the comm manager data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status.</p> <p>The operation of the state manager is defined by the following finite state machine:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults. In the case of a hard fault, the firmware writes a small amount of data to backup memory then reboots. This backup memory location is checked and then cleared after every reboot. The backup memory includes the armed state of the flight controller. On reboot, the firmware will initialize then, if this armed-state flag is set, immediately transition back into the armed state. This functionality allows for continued RC control in the case of a hard fault. Hard faults are not expected with the stable firmware code base, but this feature adds an additional layer of safety if experimental changes are being made to the firmware itself.</p>"},{"location":"developer-guide/firmware/code-architecture/#parameter-server","title":"Parameter Server","text":"<p>This module handles all parameters for the flight stack. It supports the getting and setting of integer and floating-point parameters, and the saving of these parameters to non-volatile memory. Setting and getting of parameters from the companion computer is done through the serial communication interface. While no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.</p>"},{"location":"developer-guide/firmware/code-architecture/#comm-manager","title":"Comm Manager","text":"<p>This module handles all serial communication between the flight controller and companion computer. This includes streaming data and receiving offboard control setpoints and other commands from the computer. This module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server.</p> <p>The actual communication protocol used is abstracted by the interface in include/comm_link.h. A new protocol can be used by implementing a wrapper around the protocol that inherits from this interface. Currently, only MAVLink has been implemented. The implementation is found in comms/mavlink/mavlink.h and comms/mavlink/mavlink.cpp.</p>"},{"location":"developer-guide/firmware/code-architecture/#sensors","title":"Sensors","text":"<p>This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.). Its responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.</p>"},{"location":"developer-guide/firmware/code-architecture/#estimator","title":"Estimator","text":"<p>This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.</p>"},{"location":"developer-guide/firmware/code-architecture/#rc","title":"RC","text":"<p>The RC module is responsible for interpreting the RC signals coming from the transmitter via the receiver. This includes mapping channels to their appropriate functions and reversing directions if necessary.</p>"},{"location":"developer-guide/firmware/code-architecture/#command-manager","title":"Command Manager","text":"<p>The command manager combines inputs from the RC and comm manager modules to produce a control setpoint. Its main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.</p>"},{"location":"developer-guide/firmware/code-architecture/#controller","title":"Controller","text":"<p>The controller uses the inputs from the command manager and estimator to compute a control output. This control output is computed in a generic form (Q_x, Q_y, and Q_z torques, and forces F_x, F_y, and F_z), and is later converted into actual motor commands by the mixer.</p>"},{"location":"developer-guide/firmware/code-architecture/#mixer","title":"Mixer","text":"<p>The mixer takes the outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.</p>"},{"location":"developer-guide/firmware/debugging/","title":"Debugging","text":""},{"location":"developer-guide/firmware/debugging/#using-an-in-circuit-debugger","title":"Using an In-Circuit Debugger","text":"<p>TODO</p> <p>Update this when hardware support is finalized.</p> <p>Debugging an STM32-based board is accomplished with an ST-LINK/V2 in-circuit debugger and programmer. We have had the best luck with the official version from STMicroelectronics. These devices are reasonably priced, and are available directly from STMicroelectronics or from vendors such as Digi-Key, Mouser, and Newark.</p> <p>The following guide will show you how to get the in-circuit debugger running with either the Visual Studio Code or QtCreator IDE. Start with the steps in the General Setup section, then move on to either the VS Code or STM32cubeIDE sections depending on your choice of IDE.</p> <p>This guide assumes you are running Ubuntu 22.04 LTS, which is the currently supported development environment.</p>"},{"location":"developer-guide/firmware/debugging/#general-setup","title":"General Setup","text":"<p>Follow the guide in Building and Flashing to install the compiler toolchain.</p> <p>Also make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.</p>"},{"location":"developer-guide/firmware/debugging/#connect-debugger-to-flight-controller","title":"Connect debugger to flight controller","text":"<p>The ST-LINK/V2 connects to the microcontroller using the Serial Wire Debug (SWD) interface. You will need to connect the <code>GND</code>, <code>NRST</code>, <code>SWDIO</code>, and <code>SWCLK</code> lines of the ST-LINK/V2 to your flight controller. On many F4 boards, these lines are pinned out through a 4-position JST SH connector, although that connector is not always populated. Refer to the documentation for your specific board for details.</p> <p>The official ST-LINK/V2 also needs a target voltage reference on pin 1 or 2, which for the F4 boards is 3.3V. However, there is no externally accessible 3.3V pinout on the F4 boards. An easy solution to this is to connect pin 19 (VDD 3.3V) of the ST-LINK/V2 to pin 1 or 2 of the ST-LINK/V2 (Target VCC) to provide the voltage reference. You will also need to power the board from another source, either through the USB port or over the servo rail. Note that this connection is not required for the cheap clone versions of the ST-LINK/V2.</p>"},{"location":"developer-guide/firmware/debugging/#vs-code","title":"VS Code","text":"<p>You can install Visual Studio Code by downloading the latest version from their website. Follow the steps below to configure debugging with the in-circuit debugger.</p> <p>You should open the root firmware directory for editing and debugging, e.g. <code>code /path/to/rosflight_firmware</code>.</p>"},{"location":"developer-guide/firmware/debugging/#install-openocd","title":"Install OpenOCD","text":"<p>OpenOCD (On-Chip Debugger) is the software that will control the debugger. Install from the <code>apt</code> repositories:</p> <pre><code>sudo apt install openocd\n</code></pre>"},{"location":"developer-guide/firmware/debugging/#install-cortex-debug-extension","title":"Install Cortex-Debug extension","text":"<p>The embedded debugging functionality is provided by the <code>Cortex-Debug</code> extension. Install using the VS Code GUI, or from VS Code press <code>Ctrl+P</code> then type <code>ext install marus25.cortex-debug</code>.</p> <p>Steps for configuring this extension are described next.</p>"},{"location":"developer-guide/firmware/debugging/#download-svd-file","title":"Download SVD file","text":"<p>A System View Description (SVD) file describes the configuration (CPU, peripherals, registers, etc.) of the microcontroller. The Cortex-Debug extension can make use of an SVD file to provide more detailed debugging information, such as the ability to inspect register values.</p> <p>SVD files can be downloaded from STMicroelectronics. The files for the F4 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F405.svd</code>. The files for the F1 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F103.svd</code>. Put those files in a convenient location.</p>"},{"location":"developer-guide/firmware/debugging/#configure-build-step","title":"Configure build step","text":"<p>You can configure VS Code to run <code>make</code> for you when you press <code>Ctrl+Shift+B</code>. To do this, put the following in <code>.vscode/tasks.json</code> inside your firmware working directory:</p> <pre><code>{\n  // See https://go.microsoft.com/fwlink/?LinkId=733558\n  // for the documentation about the tasks.json format\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"type\": \"shell\",\n      \"label\": \"make\",\n      \"command\": \"make\",\n      \"args\": [\"DEBUG=GDB\"],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      }\n    }\n  ]\n}\n</code></pre> <p>Note that by default, this will only build the F4 (Revo) firmware. To build the F1 firmware, you will need to edit this to add the argument <code>BOARD=NAZE</code>.</p>"},{"location":"developer-guide/firmware/debugging/#configure-debugging","title":"Configure debugging","text":"<p>To configure in-circuit debugging of F4 and F1 targets, put something like the following in <code>.vscode/launch.json</code> inside your firmware working repository:</p> <pre><code>{\n  // Use IntelliSense to learn about possible attributes.\n  // Hover to view descriptions of existing attributes.\n  // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"STM32F405\",\n      \"type\": \"cortex-debug\",\n      \"request\": \"launch\",\n      \"servertype\": \"openocd\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"executable\": \"${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf\",\n      \"device\": \"STM32F405\",\n      \"svdFile\": \"/path/to/STM32F405.svd\",\n      \"configFiles\": [\n        \"interface/stlink-v2.cfg\",\n        \"target/stm32f4x.cfg\"\n      ],\n      \"runToMain\": true\n    },\n    {\n      \"name\": \"STM32F103\",\n      \"type\": \"cortex-debug\",\n      \"request\": \"launch\",\n      \"servertype\": \"openocd\",\n      \"cwd\": \"${workspaceRoot}\",\n      \"executable\": \"${workspaceRoot}/boards/breezy/build/rosflight_NAZE_Debug.elf\",\n      \"device\": \"STM32F103\",\n      \"svdFile\": \"/path/to/STM32F103.svd\",\n      \"configFiles\": [\n        \"interface/stlink-v2.cfg\",\n        \"target/stm32f1x.cfg\"\n      ],\n      \"runToMain\": true\n    }\n  ]\n}\n</code></pre> <p>Be sure to edit the values of <code>\"svdFile\"</code> to point to the respective SVD files you downloaded earlier.</p> <p>To start debugging, enter the debug pane in VS Code, select the desired configuration, then click the green arrow to start debugging. The shortcut key <code>F5</code> will also launch the last-selected debug configuration.</p> <p>More details on the configuration and use of the <code>Cortex-Debug</code> extension can be found here and here.</p>"},{"location":"developer-guide/firmware/debugging/#stm32cubeide","title":"STM32cubeIDE","text":""},{"location":"developer-guide/firmware/unit-tests/","title":"Unit Tests","text":""},{"location":"developer-guide/firmware/unit-tests/#building-and-running-unit-tests","title":"Building and Running Unit Tests","text":"<p>Contributions will need to pass our continuous integration unit tests before merging. To test your contributions against these tests, you'll first need to install Eigen and gtest:</p> <pre><code>sudo apt install build-essential libgtest-dev libeigen3-dev cmake\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#compile-gtest","title":"Compile gtest","text":"<p>You just downloaded a bunch of source files, which you now have to go build</p> <pre><code>cd /usr/src/gtest\nsudo cmake CMakeLists.txt\nsudo make\n</code></pre> <p>Copy the archive files you just built to the <code>/usr/lib</code> directory so CMake can find them later:</p> <pre><code>sudo cp ./lib/libgtest*.a /usr/lib\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#run-the-test-script","title":"Run the Test Script","text":"<p>The simplest way to run the unit tests is to use the testing script. This script first checks that the firmware compiles, then runs the unit tests. This is the same script used on the continuous integration server, so this is a great way to check that your code will pass the tests before opening a pull request. Run the test script with</p> <pre><code>cd &lt;firmware_directory&gt;\n./scripts/run_tests.sh\n</code></pre>"},{"location":"developer-guide/firmware/unit-tests/#manually-build-and-run-the-unit-tests","title":"Manually Build and Run the Unit Tests","text":"<p>If you want to manually build and run the unit tests, first build them with the following commands:</p> <pre><code>cd &lt;firmware_directory&gt;\nmkdir build\ncd build\ncmake .. -DBUILD_TEST=TRUE\nmake\n</code></pre> <p>Then run them with:</p> <pre><code>./test/unit_tests\n</code></pre>"},{"location":"developer-guide/roscopter/roscopter-dev-overview/","title":"Developer Guide Overview","text":""},{"location":"developer-guide/roscopter/roscopter-dev-overview/#roscopter-developer-guide-overview","title":"ROScopter Developer Guide Overview","text":"<p>Danger</p> <p>Documentation for ROScopter is still under development. Please check back soon!</p>"},{"location":"developer-guide/rosplane/parameter-management/","title":"Parameter Management","text":""},{"location":"developer-guide/rosplane/parameter-management/#parameter-management","title":"Parameter Management","text":""},{"location":"developer-guide/rosplane/parameter-management/#overview","title":"Overview","text":"<p>In ROSplane, all internal variables are represented as ROS2 parameters. This enables easy loading, tuning, and saving parameters of various ROSplane modules without needing to rebuild. ROS2 parameters can also be changed dynamically, enabling live editing and tuning of the system. </p> <p>For a good introduction to ROS2 parameters and the CLI tools, see the ROS2 parameter CLI documentation. For an introduction to the parameter system using the ROS2 client libraries, see ROS2 parameter client libraries documentation.</p>"},{"location":"developer-guide/rosplane/parameter-management/#parameter-manager-class","title":"Parameter Manager class","text":"<p>A <code>param_manager</code> class has been created to manage the ROS interface required when dealing with parameters. Specifically, a <code>param_manager</code> object handles the declaration and updates of parameters. Since a base class publicly owns the <code>param_manager</code>, derived classes will have access to any parent class's parameters, if needed. This also allows derived classes to define parameters close to where they will be used in the derived class, helping with readability.</p> <p>For example, the <code>controller_base</code> class declares a <code>frequency</code> variable, which defines the rate of the control loops. This same parameter is needed in other derived classes, like the <code>controller_successive_loop</code> class. Since we declare the parameter in the <code>controller_base</code> class, the <code>controller_successive_loop</code> class will have access to the <code>frequency</code> parameter without having to redefine it.</p>"},{"location":"developer-guide/rosplane/parameter-management/#usage","title":"Usage","text":""},{"location":"developer-guide/rosplane/parameter-management/#declaration","title":"Declaration","text":"<p>To use the <code>param_manager</code> to define your own parameters, do the following:</p> <ol> <li>Declare an instance of <code>param_manager</code> in your class, or ensure that a parent class has a public or protected instance of <code>param_manager</code>.</li> <li>Initialize the <code>param_manager</code> object with a pointer to the ROS2 node object associated with the parameters.</li> <li>In the constructor, use <code>param_manager::declare_param(std::string &lt;PARAM_NAME&gt;, &lt;PARAM&gt;)</code> to declare parameters of type double, bool, or string, where <code>&lt;PARAM&gt;</code> is the default value for the parameter.<ul> <li>Use <code>param_manager::declare_int(std::string &lt;PARAM_NAME&gt;, &lt;PARAM&gt;)</code> to declare an integer parameter.</li> </ul> </li> <li>In the constructor, use <code>param_manager::set_parameters()</code> to load any parameters that have changed on launch to the <code>param_manager</code> object.</li> </ol> <p>Note</p> <p>The <code>param_manager::set_parameters()</code> call is important when a node is loaded with parameters from a file on launch. Not making this call will mean that the parameters stored in the <code>param_manager</code> object are out of sync with the ROS2 parameters.</p> <p>These steps will register your parameters with ROS2, allowing you to change them dynamically or load them from a launch file.</p>"},{"location":"developer-guide/rosplane/parameter-management/#using-parameters-in-code","title":"Using parameters in code","text":"<p>After declaring the parameters with <code>param_manager::declare_param</code> or <code>param_manager::declare_int</code>, you need to allocate variables in your code to hold the values of the parameters. Get the parameter value by using the appropriate function call:</p> <ul> <li><code>param_manager::get_double(std::string &lt;PARAM_NAME&gt;)</code></li> <li><code>param_manager::get_bool(std::string &lt;PARAM_NAME&gt;)</code></li> <li><code>param_manager::get_string(std::string &lt;PARAM_NAME&gt;)</code></li> <li><code>param_manager::get_int(std::string &lt;PARAM_NAME&gt;)</code></li> </ul> <p>Note that the return type of <code>param_manager::get_int</code> is <code>int_64</code>, since that is how ROS2 internally stores integers.</p>"},{"location":"developer-guide/rosplane/parameter-management/#defining-parameters-with-a-parameter-file","title":"Defining parameters with a parameter file","text":"<p>We recommend using a YAML file to hold all of the parameters for a given node. This file can be loaded at launch time so that all parameters are updated with the values in the launch file. This means you don't have to change the default values in code (which would require a rebuild) to make sure a node gets launched with the correct values.</p> <p>To do this, add the <code>parameters=[\"/path/to/parameter/file\"]</code> to a node's launch argument. See <code>rosplane.launch.py</code> for an example.</p>"},{"location":"developer-guide/rosplane/parameter-management/#updating-parameters","title":"Updating Parameters","text":"<p>Parameters can be updated from the command line using normal ROS2 commands. See the ROS2 parameter CLI tools documentation for more information on how to interface with these parameters from the command line.</p> <p>Note</p> <p>Be sure to create a callback for your parameter changes, especially if you use a <code>param_manager</code> object. ROS2 will send a list of changed parameters to this callback when the parameters are changed, allowing you to update the internally stored value in the <code>param_manager</code>. Otherwise, your internally stored values will be out of sync with the ROS2 parameters, and it will likely not function correctly. See the <code>controller_base</code> or <code>estimator_base</code> or <code>path_planner</code> code for an example of the callbacks.</p>"},{"location":"developer-guide/rosplane/rosplane-dev-overview/","title":"Developer Guide Overview","text":""},{"location":"developer-guide/rosplane/rosplane-dev-overview/#rosplane-developer-guide-overview","title":"ROSplane Developer Guide Overview","text":"<p>The purpose of the this section is to provide detailed information on each of the components of ROSplane, as shown in the below figure. It is written with the intent that a user might know how to change each component of ROSplane, not only how to use it.</p> <p>Note that the system components not part of ROSplane are not included in this section (ROSflight firmware, physical aircraft setup, etc.).</p> Diagram of the ROSplane architecture <p>Each of these components are described in detail in this section, but the implementation is not fully described. Please refer to the code for more detailed information on the actual implementation of each of the elements shown above.</p>"},{"location":"developer-guide/rosplane/rosplane-dev-overview/#contributing-to-rosplane","title":"Contributing to ROSplane","text":"<p>If you create a new \"module\" when using ROSplane for your application, please contribute back! While changes won't be included in the core ROSplane stack (see ROSflight Vision), we hope to build a repository of modules and projects that have been created by others. Doing this is also an effective way to share your work and help others build on it.</p>"},{"location":"developer-guide/rosplane/controller/controller-base/","title":"Controller Base","text":""},{"location":"developer-guide/rosplane/controller/controller-base/#controller-base","title":"Controller Base","text":""},{"location":"developer-guide/rosplane/controller/controller-base/#overview","title":"Overview","text":"<p>The controller base implements the basic ROS interfaces for the controller. This includes setting up subscribers, publishers and initializing parameter management. The idea of the base class, is that all interfacing with ROS and shared resources across all inheritance levels happens or are contained in this class.</p>"},{"location":"developer-guide/rosplane/controller/controller-base/#ros-interfaces","title":"ROS interfaces","text":"<p>The controller base has the following ROS interactions.</p> Figure 1: Controller's ROS interactions. <p>The controller has four ROS interfaces that are tracked as member variables of the class. These interfaces are the only points of contact that influence the every layer of the controller along side the node parameters. Each of the callbacks for the subscribers are also contained in <code>controller_base</code>.</p> ROS Interface Topic Explanation Message Type <code>actuators_pub_</code> <code>/command</code> Publishes the acutator commands for the aircraft. The publishing rate is controller by the <code>timer_</code> object. Command.msg <code>internals_pub_</code> <code>/controller_inners_debug</code> Publishes the intermediate values created by the outer control loops. Published simultaneously as the commands when there is at least one subscriber to the topic. ControllerInnersDebug.msg <code>controller_commands_sub_</code> <code>/controller_commands</code> Subscribes to the commands for the controller. ControllerCommands.msg <code>vehicle_state_sub_</code> <code>/estimated_state</code> Subscribes to the estimated state of the aircraft. State.msg <p>Note</p> <p>The command message is from the <code>rosflight_msgs</code> package not the <code>rosplane_msgs</code> package.</p>"},{"location":"developer-guide/rosplane/controller/controller-base/#parameter-management","title":"Parameter Management","text":"<p>See the Parameter Management page for more details on how parameter management works.</p>"},{"location":"developer-guide/rosplane/controller/controller-base/#list-of-parameters","title":"List of Parameters","text":"Parameter Explanation Range pwm_rad_e Radian to PWM conversion for the elevator. \\geq 1.0 (double) pwm_rad_a Radian to PWM conversion for the ailerons. \\geq 1.0 (double) pwm_rad_r Radian to PWM conversion for the rudder. \\geq 1.0 (double) frequency Frequency of the timer, effective control loop closure frequency. \\geq 100 (hertz, int)"},{"location":"developer-guide/rosplane/controller/controller-base/#modifying-controller-base","title":"Modifying Controller Base","text":"<p>The <code>controller_base</code> class should only contain things that are necessary for each layer of the controller. If you are considering adding something to the controller, but it only applies to one layer, perhaps reconsider. All ROS related items should also be stored here. For example, if you needed to use another topic subscription, the new subscriber should be created and stored in <code>controller_base</code>.</p> <p>As shown in the Controller Software Architecture page, you may need to modify the <code>main</code> function in <code>controller_base.cpp</code> to use a newly implemented controller.</p>"},{"location":"developer-guide/rosplane/controller/controller-general-overview/","title":"General Controller Overview","text":""},{"location":"developer-guide/rosplane/controller/controller-general-overview/#rosplane-controller","title":"ROSplane Controller","text":""},{"location":"developer-guide/rosplane/controller/controller-general-overview/#overview","title":"Overview","text":"<p>The ROSplane controller generates the controller commands to achieve the commanded states that the path follower directs. The controller has the basic function of controlling roll, pitch, yaw, airspeed, course and altitude. Higher functions of controlling position and tracking paths is handled by other nodes, the path follower and manager specifically. To gain the best understanding of the Controller and its role, read chapter 1 of the UAV book, or the ROSplane Overview page.</p>"},{"location":"developer-guide/rosplane/controller/controller-general-overview/#interfaces","title":"Interfaces","text":"Figure 1: Controller's ROS interactions."},{"location":"developer-guide/rosplane/controller/controller-general-overview/#input","title":"Input","text":"<p>The controller receives controller commands using the ControllerCommands message on the <code>\\controller_commands</code> topic from the <code>path_follower</code> node.  This set of commands are outlined below, along with a short explanation of each.</p> Message Field Explanation Units header This contains time stamp information. Time in Seconds and Nanoseconds (int) va_c The commanded airspeed. Meters per second (float) h_c The commanded altitude. Meters (float) chi_c The commanded course. Radians (float) phi_ff Feedforward roll term (for orbits) Radians (float) aux[4] Four array of auxiliary commands None (float) aux_valid Indicates whether aux vector contains actual information. True/False (bool) <p>The controller uses these targets to control the aircraft. This drives the aircraft to approach and follow the path as the path_follower commands. See the Path Follower page for more information. See the Successive Loop Closure Controller Outline for more information on how these commands are used specifically.</p> <p>Note</p> <p>Poor path performance may be due to controller or the path follower, see the Tuning Guide in the User Guide section for more details.</p>"},{"location":"developer-guide/rosplane/controller/controller-general-overview/#output","title":"Output","text":"<p>The controller calculates the control surface outputs in percent deflection (based around zero) and throttle. It formats and the publishes these outputs in the Command message on the <code>/command</code> topic. There are a further four auxiliary channels that can be used in the Command message, however they are unused typically. A summary of the parts of the command message are as follows.</p> Message Field Explanation Units header This contains time stamp information. Time in Seconds and Nanoseconds (int) mode The control mode (used in multi-rotors) None (int) ignore A bitmask to ignore particular values. None (int) x Aileron Command Percent deflection in direction [-1.0, 1.0] (float) y Elevator Command Percent deflection in direction [-1.0, 1.0] (float) z Rudder Command Percent deflection in direction [-1.0, 1.0] (float) f Throttle Command Percent of full throttle [0.0, 1.0] (float) <p>These are passed to <code>rosflight_io</code>, which formats them into MAVLink messages and forwards them onto the FCU.</p> <p>Note</p> <p>For this to work the parameters on the <code>rosflight_firmware</code> must be set to work for an airplane. See the User Guide on first time start up or README.md for the repository for more details on firmware setup.</p>"},{"location":"developer-guide/rosplane/controller/controller-general-overview/#running-the-controller","title":"Running the Controller","text":"<p>As mentioned in the ROSplane ROS overview, the controller is in the main <code>rosplane</code> ROS package. The ROS executable is <code>controller</code>, yielding the run command:</p> <p><code>ros2 run rosplane controller</code></p> <p>The type of controller used is passed right after the executable name, substitute <code>control_type</code> for controller being used.</p> <p><code>ros2 run rosplane controller control_type</code></p> <p>To pass a set of parameters for the controller from a yaml file using the <code>--ros-args</code> option.</p> <p><code>ros2 run rosplane controller --ros-args --params-file path/to/params.yaml</code></p> <p>Putting it all together,</p> <p><code>ros2 run rosplane controller control_type --ros-args --params-file path/to/params.yaml</code></p> <p>A table of arguments and parameter files that work out of the box is given in the following table.</p> <p>Note</p> <p>Filepaths will need to be altered to work.</p> <p>Note</p> <p>The most common way of running the controller is through a launch file with the rest of the ROSplane pipeline running as well. See the ROSplane Overview in the Developer and User Guides for more details.</p> Argument Explanation Values --params-file The parameters file that contains the gains and other important parameters. <code>rosflight_ws/src/rosplane/rosplane/params/anaconda_autopilot_params.yaml</code>,<code>rosflight_ws/src/rosplane/rosplane/params/skyhunter_autopilot_params.yaml</code> control_type These arguements are passed directly to the main function defined in the controller. <code>default</code>, <code>total_energy</code>"},{"location":"developer-guide/rosplane/controller/controller-outline/","title":"Successive Loop Closure Controller Outline","text":""},{"location":"developer-guide/rosplane/controller/controller-outline/#successive-loop-closure-controller","title":"Successive Loop Closure Controller","text":""},{"location":"developer-guide/rosplane/controller/controller-outline/#overview","title":"Overview","text":"<p>The control scheme used by default in ROSplane comes from the book Small Unmannded Aircraft: Theory and Practice by Randal Beard and Timothy McLain. A full and in depth description of the theory behind this controller is outlined in chapter 6. Additionally, many simplifing assumptions are made some of which will be mentioned, but the rationale not explored. These too are found in the book, in chapters 3, 4 and 5. A link to the most up to date book can be found on the GitHub page for the book. This section of the documentation is to briefly outline the important, practical parts of the controller to be useful in understanding how to tune or modify the existing code or algorithm for a developer. A good primer on PID control can be found here.</p> <p>The control algortihm is split into two parts: Lateral-directional Autopilot and Longitudinal Autopilot. The lateral and longitudinal dynamics are assumed to be decoupled as discussed in Section 6.1 of Small Unmannded Aircraft. This allows us to develop a controller for each set of dynamics to simplify the controller design.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#successive-loop-closure","title":"Successive Loop Closure","text":"<p>For a full discussion of PID successive loop closure, which is used heavily through out the entire controller, read section 6.1 in the book. One major assumption used is that the inner loops are much faster (more than ten times faster) than the outer loops. This means that the bandwidth seperation should be seperated by a factor of 10. See end of section 6.1.1 Course Hold using Commanded Roll in the book for a more thorough discussion. A significant advantage of successive loop closure is that gains are tuned independently. Starting from the inner loops, tune the response and then tune the outer loop.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#nomenclature","title":"Nomenclature","text":"Symbol Meaning Range \\large{\\boldsymbol{\\chi}} Course/Heading [-\\pi,\\pi) \\large{\\boldsymbol{\\phi}} Roll [-\\pi,\\pi) \\large{\\boldsymbol{\\theta}} Theta [-\\pi,\\pi) \\large{\\boldsymbol{\\psi}} Yaw [-\\pi,\\pi) \\large{\\boldsymbol{h}} Altitude \\large{p} Roll Rate \\large{q} Pitch Rate \\large{r} Yaw Rate \\large{V_a} Airspeed \\large{\\boldsymbol{\\delta_i}} Command percent defelection of control surface i [-1.0,1.0] \\large{\\boldsymbol{e_a}} Error in state variable a \\large{\\boldsymbol{a^c}} Commanded value of state variable a \\large{\\boldsymbol{k_{p_{a}}}} Proportional gain for state variable a \\large{\\boldsymbol{k_{d_{a}}}} Derivative gain for state variable a \\large{\\boldsymbol{k_{i_{a}}}} Integral gain for state variable a \\large{\\boldsymbol{p_{wo}}} Washout filter bandwidth \\large{\\boldsymbol{P}} Plant transfer function \\large{\\boldsymbol{s}} Laplace operator"},{"location":"developer-guide/rosplane/controller/controller-outline/#lateral-directional-autopilot","title":"Lateral-directional Autopilot","text":"<p>The autopilot uses induced roll to control changes in course. The Lateral-directional Autopilot also uses a yaw damper to damp the dutch roll mode that can be induced by changes in roll.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#course-loop","title":"Course Loop","text":"<p>In figure 1, the entire control loop for the course is shown. This loop allows for tracking of ramp and step commands in course. Since the inner loop is tuned first and influences the outer loop tune, we will discuss it first.</p> Figure 1: Lateral-directional Autopilot Control Loop"},{"location":"developer-guide/rosplane/controller/controller-outline/#inner-loop","title":"Inner Loop","text":"<p>The inner loop calculates the required percent deflection in the ailerons, \\boldsymbol{\\delta_a}, to acheive the commanded roll angle generated by the outer loop. This loop is a PD loop, meaning that it uses only a proportional and derivative control.</p> <p>Note</p> <p>That the derivative gain does not act on the rate of change of the error but of the direct roll rate, p.</p> <p>The proportional gain acts on the error given by the estimated roll and the commanded roll. This loop does not use integral contol to ensure that it closes much faster than the outer loop. This bandwidth seperation helps the controller perform smoothly. See the specific page on the Course Loop for details on tuning and common pitfalls. For more details on how the roll rate and the roll angle are calculated, see the Estimator page. The output for the inner loop is routed into the outer loop.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#outer-loop","title":"Outer Loop","text":"<p>The outer loop calculates the commanded roll angle, \\boldsymbol{\\phi}, based on the error in the course, \\boldsymbol{\\chi}. This is a PI loop, meaning that it uses only proportional and integral control. The proportional gain acts on the error between the estimated course \\boldsymbol{\\chi} and the commanded course \\boldsymbol{\\chi}. The integral gain acts on the same error, ensuring that errors in course are driven to zero.</p> <p>Note</p> <p>The PI loop allows for only constant error in ramp inputs (orbits) and for no error to step inputs (path following commands).</p> <p>See the specific page on the Course Loop for details on tuning and common pitfalls. For more details on how course is estimated and measured, see the Estimator page. These loops combine to give complete control of the course of the aircraft.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#yaw-damper","title":"Yaw Damper","text":"<p>The yaw damper allows for effective damping of undesirable yaw modes induced by rolling. This is done by using the rudder to control the yaw rate, r, to zero. Not all yaw rates should be controlled to zero since this would disallow turning. A washout filter is used to only damp high frequency yaw rates. In effect, this control only 'turns on' if the frequency of the yaw rate is high enough. For mor information see the Yaw Damper page.</p> Figure 2: Yaw Damper Control Loop"},{"location":"developer-guide/rosplane/controller/controller-outline/#longitudinal-autopilot","title":"Longitudinal Autopilot","text":"<p>The longitudinal autopilot controls the longitudinal dynamics of the aircraft. This means that the loop controls altitude, pitch and airspeed.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#altitude-loop","title":"Altitude Loop","text":"<p>The altitude loop utilizes successive loop closure to control altitude. It uses the elevator to control the pitch of the aircraft, and then controls using commanded pitch the altitude. This loop can track step and ramp commands.</p> Figure 3: Altitude Control Loop"},{"location":"developer-guide/rosplane/controller/controller-outline/#inner-loop_1","title":"Inner Loop","text":"<p>The inner loop controls the pitch, \\boldsymbol{\\theta}. It does so by calculating the necessary \\boldsymbol{\\delta_e} to acheive the commanded pitch. This is a PD loop, this means that there is often a small DC offset to the commanded pitch. This does not affect the performance of the overall altitude loop. Like the inner loop of the course control, the derivative gain acts on the measured pitch rate rather than the error derivative.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#outer-loop_1","title":"Outer Loop","text":"<p>The outer loop is a PI loop. It uses the error in the altitude, h, and integral of the error of altitude to drive the error to zero for steps and for ramps. The commanded altitude is capped using a scheme described in the Altitude Loop page. In practice, the altitude loop is often slower when the commanded altitude is descending and faster when ascending. This is because the airspeed is coupled to the altitude. While descending the controller will attempt to maintain airspeed. This can also result in more overshoot while descending.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#airspeed-loop","title":"Airspeed Loop","text":"<p>The Airspeed loop is a PI loop. It reacts to the straight forward error in commanded airspeed V_a^c given by the waypoint mission. It generates the required throttle, \\delta_t, to acheive the commanded airspeed. This is suffecient because of the natural damping of the drag on the aircraft. In practice, the loop performs well, but is prone to small fluctuations (on the order of \\pm 1 \\frac{m}{s}) due to the differential pressure sensor fluctuating because of wind and other disturbances.</p> Figure 4: Airspeed using throttle control loop"},{"location":"developer-guide/rosplane/controller/controller-outline/#controller-outputs","title":"Controller Outputs","text":"<p>What the entire controller outputs is a set of 4 control efforts that correspond to the 4 major control surfaces on the aircraft. These are the elevator, ailerons, rudder and the throttle. The controller can easily be switched to outputing up to 8 outputs, using the aux channels of the Commands Message. These outputs are fed directly to rosflight_io and then passed along to the microcontroller and finally actuated on the physical or simulated aircraft. The controller is the exposed portion of ROSplane to ROSflight.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#important-notes","title":"Important Notes","text":"<p>The controller does not directly control the position. In the ROSplane overview page, it shows how the Path Follower feeds into the controller. The Path Follwer generates commands that result in the position control of the aircraft. For a better understanding of this realtionship visit the Path Follower page.</p>"},{"location":"developer-guide/rosplane/controller/controller-outline/#software-architecture","title":"Software Architecture","text":"<p>The Successive Loop Closure Controller (SLCC) inherits from the state machine class, (see Software Architecture for more details) and implements the state function for each of the states. This state function is then populated with the desired control during each phase of flight (see State Machine for more details on control during each state). The state functions split control into longitudinal and lateral control, this allows for inheritance of this class an only override longitudinal or lateral control (see Total Energy Control for an example of how this is done).</p> Figure 5: An example of an implementation of a state function, in this case the altitude hold state. <p>The lateral and longitudinal control functions activate particular control loops necessary.</p> Figure 6: An example of an implementation of a lateral and longitudinal control, in this case during the altitude hold state. <p>Each control loop gets its own function and it follows a specific format. This format is pictured below, but a full outline is given in the .cpp file for the SLCC.</p> <p>Note</p> <p>All of the PID is implemented but the gains if not using a particular control (proportional/derivative/integral) are zero.</p> Figure 7: An example of an implementation of a control loop, in this case the roll loop (inner course loop)."},{"location":"developer-guide/rosplane/controller/controller-outline/#parameters","title":"Parameters","text":"<p>These values are typically held in a .yaml file. For the default values, check the .cpp file.</p> Parameter Explanation Range max_takeoff_throttle Trottle saturation level during the takeoff zone. (0.0, 1.0) (double) c_kp The proportional gain on the outer course loop. \\geq 0.0 (double) c_kd The derivative gain on the outer course loop. \\leq 0.0 (double) c_ki The integral gain on the outer course loop. \\geq 0.0 (double) max_roll Commanded roll saturation limit. \\geq 0.0 (double)(degrees) cmd_takeoff_pitch Commanded pitch while in takeoff state. \\geq 0.0 (double)(degrees) r_kp The proportional gain on the inner course loop. \\geq 0.0 (double) r_kd The derivative gain on the inner course loop. \\geq 0.0 (double) r_ki The integral gain on the inner course loop. \\geq 0.0 (double) max_a Saturation limit for the ailerons \\geq 0.0 (double) trim_a Trim value for the ailerons. \\geq 0.0 (double) a_kp The proportional gain on the outer altitude loop. \\geq 0.0 (double) a_kd The derivative gain on the outer altitude loop. \\geq 0.0 (double) a_ki The integral gain on the outer altitude loop. \\geq 0.0 (double) max_pitch Commanded pitch saturation limit. \\geq 0.0 (double)(degrees) p_kp The proportional gain on the inner altitude loop. \\leq 0.0 (double) p_kd The derivative gain on the inner altitude loop. \\leq 0.0 (double) p_ki The integral gain on the inner altitude loop. \\leq 0.0 (double) max_e Saturation limit for the elevator \\geq 0.0 (double) trim_e Trim value for the elevator. \\geq 0.0 (double) y_pwo The yaw damper washout filter cutoff frequency. \\leq 0.0 (double)(radians/s) y_kr Control gain on yaw damper. \\leq 0.0 (double) a_t_kp The proportional gain on the airspeed loop. \\geq 0.0 (double) a_t_kd The derivative gain on the airspeed loop. \\geq 0.0 (double) a_t_ki The integral gain on the airspeed loop. \\geq 0.0 (double) max_t Saturation limit for the throttle. \\geq 0.0 (double) trim_t Trim value for the throttle. \\geq 0.0 (double) tau Dirty derivative low pass filter gain for airspeed. \\geq 0.0 (double)"},{"location":"developer-guide/rosplane/controller/controller-software-architecture/","title":"Controller Software Architecture","text":""},{"location":"developer-guide/rosplane/controller/controller-software-architecture/#controller-software-architecture","title":"Controller Software Architecture","text":""},{"location":"developer-guide/rosplane/controller/controller-software-architecture/#overview","title":"Overview","text":"<p>The controller makes use of inheritance to make the controller more modular. This creates a hierarchy of classes that each take on a responsibility. This means that a user that modifies the controller only has to inherit from a particular class make the modifications only to the portions of the code that matter to them, and then continue to use the other parts of the controller. An example of this is provided in the code. The total energy controller exemplifies this by inheriting and only changing just a few key functions. The aim of this architecture is to make the developer's job easier.</p>"},{"location":"developer-guide/rosplane/controller/controller-software-architecture/#inheritance-scheme","title":"Inheritance Scheme","text":"<p>The controller starts off with the <code>controller_base</code> class. This contains all of the interface with ROS. The next layer, <code>controller_state_machine</code>, implements a basic state machine for the controller. These states control which commands are happening at what time. An example of how this may be used is, ensuring the aircraft is at altitude before attempting major maneuvers. Following the state machine is the actual control scheme. By default we use a successive loop closure scheme, <code>controller_successive_loop</code>. This layer calculates the control errors and necessary actuator deflections to track commands.</p>   | ![Diagram of Controller Inheritance](../../../assets/controller_assets/Controller_classes.png \"Controller Class Inheritance\") | |:--:| |*Figure 1: Controller class inheritance structure.*|   <p>This scheme was chosen to limit code duplication. A composition structure would have resulted in code duplication between controllers. Guides on how and where to modify each part of this structure can be found on the respective pages in the Developer Guide. This page does go over the basics of how to implement a controller changes in terms of overall architecture.</p>"},{"location":"developer-guide/rosplane/controller/controller-software-architecture/#implementing-a-new-controller","title":"Implementing A New Controller","text":"Figure 2: Options for implementing a new controller. <p>The total energy controller in the <code>rosplane</code> package, shows in a practical way how to implement a new controller. This section is meant to only give a high level overview of how this can be done. The first step is to identify where your changes should be made. This means determining which class the change belongs in. Consult the class pages for more information on where the best fit for your controller would be. The next step is to define a new class that inherits from class you are changing. Override the functions of interest. Next if the inherited class is not at the bottom of the inheritance chain, you will have to modify (duplicate but only change the inheritance, this is to not break default behavior) the controller classes further down the chain to inherit from your class rather than the original. This is to avoid a multiple inheritance problem (inheritance diamond).</p> <p>To add your new controller as an option to be launched you will need to make a few edits. To be clear, you add your new final controller, (<code>new_controller</code> or <code>copy_of_controller</code> in the diagram) as an option. These edits are as follows:</p> <ul> <li>Add new controller to the CMakeLists.txt.<ul> <li>The best examples are found in the CMakeLists.txt.</li> <li>Be sure to include the <code>.cpp</code> files.</li> </ul> </li> </ul>   | ![CMakeLists Controller Exe](../../../assets/controller_assets/CMakeLists_controller.png \"CMakeLists.txt controller executable location.\") | |:--:| |*Figure 3: Location in `CMakeLists.txt` to add the new controller's `.cpp` file(s).*|   <ul> <li>First import the new controller by adding its header file to <code>controller_base.cpp</code>.</li> </ul>   | ![Controller Base Include](../../../assets/controller_assets/controller_base_include.png \"Include in Controller Base\") | |:--:| |*Figure 4: Location in `controller_base.cpp` to import new controller's header file.*|   <ul> <li>Next you need to add the new controller as an option to the <code>main</code> function. The argument to the main function is the name/activation string for the control. This is passed in on launch of ROSplane (see Launching ROSplane in the User Guide for more details).</li> </ul>   | ![Controller Base Main](../../../assets/controller_assets/controller_base_main.png \"Main in Controller Base\") | |:--:| |*Figure 5: Location in `controller_base.cpp` to add option to select control type.*|   <p>If this is done correctly, then you should be able to simply change between control schemes with only an argument to a launch file. This will allow for easier testing where you can use a more tested controller initially and but swap to a new controller when convenient.</p>"},{"location":"developer-guide/rosplane/controller/controller-state-machine/","title":"Controller State Machine","text":""},{"location":"developer-guide/rosplane/controller/controller-state-machine/#controller-state-machine","title":"Controller State Machine","text":""},{"location":"developer-guide/rosplane/controller/controller-state-machine/#state-machine-overview","title":"State Machine Overview","text":"<p>The controller state machine uses discrete states to turn on and off particular controls for a more stable flight. These regimes are designed so that particular mission objectives are only activated when particular conditions are met. In the default implementation this is controlled based on the aircraft's altitude. Though, in practice these states could be effected by any input from a ROS topic. The states are pictured below, and the differences in state are explored in the next section.</p> Figure 1: Controller state machine."},{"location":"developer-guide/rosplane/controller/controller-state-machine/#states","title":"States","text":"<p>This section describes all of the states and what control is active during that phase of flight.</p>"},{"location":"developer-guide/rosplane/controller/controller-state-machine/#takeoff","title":"Takeoff","text":"<p>In the takeoff state, the commanded airspeed is set to cruise, the commanded pitch is held constant and roll is controlled to zero. This results in a steady takeoff directly along the runway. The deactivation of course control means that the aircraft will not attempt to maneuver while too close to the ground. The takeoff regime is only below a certain cutoff altitude. After passing this threshold it moves into the climb state.</p>"},{"location":"developer-guide/rosplane/controller/controller-state-machine/#climb","title":"Climb","text":"<p>The climb state commands altitude and airspeed as normal, but still controls roll to zero. This means that the aircraft will proceed directly ahead until it is withing a cutoff (see Params section) of commanded altitude. Deactivating course control allows for the aircraft to gain enough altitude to be clear of all obstacles before attempting to follow the waypoint mission. Once within a cutoff of the commanded altitude, the state transitions to altitude hold. If the aircraft dips beneath the takeoff threshold, it will enter the takeoff state again.</p>"},{"location":"developer-guide/rosplane/controller/controller-state-machine/#altitude-hold","title":"Altitude Hold","text":"<p>In altitude hold all control loops are closed normally.  The aircraft will fly the waypoint mission as normal. If the aircraft dips beneath the takeoff cutoff, the state transitions to takeoff again.</p>"},{"location":"developer-guide/rosplane/controller/controller-state-machine/#code-architecture","title":"Code Architecture","text":"<p>The state machine's architecture allows for different aspects of the control to be modified. It simply defines a virtual method to be implemented by a child that will control during the particular state the aircraft is in. The state method is implemented in the child, only using the controls necessary for that phase of flight (see the Architecture section of the Successive Loop Closure).</p> Figure 2: Code snippet from the state machine."},{"location":"developer-guide/rosplane/controller/controller-state-machine/#parameters","title":"Parameters","text":"Parameter Explanation Range alt_toz The altitude of the takeoff zone cutoff. \\geq 0.0 (double) alt_hz The altitude command saturation limit, and difference required to transition into altitude hold. \\geq 0.0 (double)"},{"location":"developer-guide/rosplane/controller/controller-total-energy/","title":"Total Energy Controller","text":""},{"location":"developer-guide/rosplane/controller/controller-total-energy/#total-energy-controller","title":"Total Energy Controller","text":""},{"location":"developer-guide/rosplane/controller/controller-total-energy/#overview","title":"Overview","text":"<p>The total energy control system approach (TECS) differs from the successive loop closure controller in its control of airspeed and altitude. It does this by calculating the total energy of the system, both potential and kinetic and controlling it to the desired energy. A more in depth treatment of of TECS see Section 6.2 in the UAV book.</p> <p>The TECS controller has been included in ROSplane not only to provide control of the aircraft but to also demonstrate how to easily modify the controller (see Software Architecture and the following section for more details). The TECS controller calculates the desired kinetic and potential energy, using references from the commanded airspeed and altitude. It then calculates the current kinetic and potential energies and finds the kinetic and potential errors. It combines these errors, and the throttle control loop uses a PI loop to drive this total energy error to zero. The energy errors are also used to find a balance error. This is the error in the ratio of potential to kinetic energy. Pitch is then controlled by a PI loop to drive the balance error to zero. Essentially the throttle allows for the total energy to rise as it adds or allows drag to subtract energy from the system. The pitch loop controls how much of that input energy is in potential versus kinetic energy</p> <p>This approach can have advantages because it deals with the coupling of airspeed and altitude. In the successive loop closure controller (SLCC), it assumes a decoupling of airspeed and altitude which can present tuning issues, though they are not insurmountable.</p>"},{"location":"developer-guide/rosplane/controller/controller-total-energy/#software-architecture","title":"Software Architecture","text":"<p>The TECS controller provides an excellent template on implementing a new controller. Since the changes to the total energy controller are only in the longitudinal control and the rest are the same as the SLCC it inherits directly from <code>controller_successive_loop</code> and only overrides the longitudinal functions for each state.</p> Figure 1: Total Energy Controller's overriden longitudinal control for the altitude hold state."},{"location":"developer-guide/rosplane/controller/controller-total-energy/#parameters","title":"Parameters","text":"Parameter Explanation Range e_kp Total energy error proportional gain, used in throttle control. \\geq 0.0 (double) e_ki Total energy error integral gain, used in throttle control. \\geq 0.0 (double) e_kd Total energy error derivative gain, used in throttle control. \\geq 0.0 (double) l_kp Balance energy error proportional gain, used in throttle control. \\geq 0.0 (double) l_ki Balance energy error integral gain, used in throttle control. \\geq 0.0 (double) l_kd Balance energy error derivative gain, used in throttle control. \\geq 0.0 (double) mass The mass of the aircraft, allowing for calculation of energies. \\geq 0.0 (double)(kg) gravity The gravity experienced by the aircraft, allowing for calculation of potential energy. \\geq 0.0 (double)(\\frac{m}{s}) max_alt_error This is the maximum error in altitude that the total energy loop will use to calculate energy error. \\geq 0.0 (double)(meters)"},{"location":"developer-guide/rosplane/estimator/estimator-base/","title":"Estimator Base","text":""},{"location":"developer-guide/rosplane/estimator/estimator-base/#estimator-base","title":"Estimator Base","text":""},{"location":"developer-guide/rosplane/estimator/estimator-base/#overview","title":"Overview","text":"<p>The estimator base implements the basic ROS interfaces for the estimator. This includes setting up subscribers, publishers and initializing parameter management. The idea of the base class, is that all interfacing with ROS and shared resources across all inheritance levels happens or are contained in this class.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-base/#ros-interfaces","title":"ROS Interfaces","text":"<p>The estimator has the following ROS interfaces.</p> Figure 1: Estimator's ROS interactions. <p>The estimator has several ROS interfaces that are tracked as member variables of the <code>estimator_base</code> class. They are summarized in the table below:</p> ROS Interface Topic Explanation Message Type <code>vehicle_state_pub_</code> <code>/estimated_state</code> Publishes the estimated state of the vehicle. State.msg <code>gnss_fix_sub_</code> <code>/navsat_compat/fix</code> Subcribes to the GNSS position information. NavSatFix.msg <code>gnss_vel_sub_</code> <code>/navsat_compat/vel</code> Subcribes to the GNSS velocity information. TwistStamped.msg <code>imu_sub_</code> <code>/imu/data</code> Subcribes to the IMU data (both Gyro and Accel). Imu.msg <code>baro_sub_</code> <code>/baro</code> Subcribes to the barometer pressure information. Barometer.msg <code>airspeed_sub_</code> <code>/airspeed</code> Subcribes to the differential pressure information. Airspeed.msg <code>status_sub_</code> <code>/status</code> Subcribes to the aircraft status information. Status.msg <p>Note</p> <p>The NavSatFix, TwistStamped and Imu messages are from standard ROS message packages. Barometer, Airspeed and Status messages are from <code>rosflight_msgs</code>.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-base/#parameters","title":"Parameters","text":"Parameter Explanation Type Range <code>rho</code> The density of the air. double ~1.225 \\frac{kg}{m^3} <code>gravity</code> The acceleration due to gravity. double ~9.81 \\frac{m}{s^2} <code>estimator_update_frequency</code> The frequency that the estimator will run estimations. double \\geq 100 Hz <code>gps_ground_speed_threshold</code> This determines when the aircraft is moving fast enough to get a course estimate. double \\geq 0.3 \\frac{m}{s} <code>baro_measurement_gate</code> The maximum allowable instantaneous change in barometer pressure measurement. double ~1 meter <code>airspeed_measurement_gate</code> The maximum allowable instantaneous change in differential pressure measurement. double ~5 \\frac{m}{s} <code>baro_calibration_count</code> The number of barometer measurements used to do calibration. int \\geq 100"},{"location":"developer-guide/rosplane/estimator/estimator-base/#modifying-the-estimator","title":"Modifying the Estimator","text":"<p>Update when full state estimator and continuous-discrete are both implemented and a swap between them works.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/","title":"Estimator Example","text":""},{"location":"developer-guide/rosplane/estimator/estimator-example/#estimator-example","title":"Estimator Example","text":""},{"location":"developer-guide/rosplane/estimator/estimator-example/#overview","title":"Overview","text":"<p>The <code>estimator_example</code> class implements a continuous-discrete Kalman filter as described in section 8.5 of the UAV book or 8.6 and 8.7 of volume one of the same book. Specifically, this estimator uses algorithm 2 of chapter 8 in Volume 1. It utilizes a two stage estimation process along with low pass filtering the inversion of a few sensor models and direct measurements. The roll and pitch of the aircraft are estimated first. This is called the attitude estimation step though not all of the attitude is estimated here. The other states are then estimated as a all at once. This is called the position estimation step, though more than just position is estimated during this step. The estimator runs on a set timer with a configurable frequency (see Parameters section for details).</p> <p>The estimator makes large use of something called a pseudo-measurement. These measures assume that the side slip angle is zero and the corresponding wind triangle solution. This allows us to take these measures and then find the wind in the north and east directions along with the yaw of the aircraft. They are more fully explored in section 8.11.4 of the UAV book.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#nomenclature","title":"Nomenclature","text":"Symbol Meaning Range \\large{\\chi} Course [-\\pi,\\pi) \\large{\\phi} Roll [-\\pi,\\pi) \\large{\\theta} Theta [-\\pi,\\pi) \\large{\\psi} Yaw [-\\pi,\\pi) \\large{h} Altitude - \\large{p} Roll Rate - \\large{q} Pitch Rate - \\large{r} Yaw Rate - \\large{V_a} Airspeed \\geq 0 \\large{w_n} Wind North - \\large{w_e} Wind East -"},{"location":"developer-guide/rosplane/estimator/estimator-example/#sensor-model-inversion","title":"Sensor Model Inversion","text":"<p>The roll, pitch and yaw rates are directly measured by the rate gyro and then low pass filtered. The low pass filter is a simple alpha filter described by:</p>      a_{n} = a_{n-1} \\alpha + (1 - \\alpha) a_{measured}  <p>Where a is the state. This filter technique is used on the measurements before they are used in an estimate throughout the estimator.</p> <p>The following are calculated directly from a model of the sensor:</p> State Measured Value Model Equation Inversion Equation h - altitude P - absolute pressure (Pa) P = \\rho_{air} gh h = \\frac{\\rho_{air} g}{P} V_a - airspeed \\Delta P - differential pressure (Pa) \\Delta P = \\frac{1}{2} \\rho_{air} V_a^2 V_a = \\sqrt{\\frac{2}{\\rho_{air} g} \\Delta P} <p>These values are then used in the first step of the estimator.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#attitude-estimation","title":"Attitude Estimation","text":"<p>The first step in estimating the attitude is understanding how we propagate our guess between measurements. Our estimates are on roll angle, \\phi, and on pitch angle, \\theta. These estimates are part of the state \\hat{x}_a, where the hat over the variable indicates an estimate.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#propagation","title":"Propagation","text":"<p>At each call of the estimation algorithm, the estimate from the previous time step is propagated to the next time step. The propagation step is broken up into N smaller steps to yield an estimate for the current time step. N is typically 10, meaning that the previous estimate that was updated by a measurement is updated in 10 steps instead of a single step to calculate the estimate at the current time step. The length of each of the N steps is 1/N the original time step.</p> <p>The attitude estimation is propagated according to the model f:</p> \\begin{equation}     f =     \\begin{bmatrix}         \\dot{\\phi} = p + (q \\sin{\\phi} + r \\cos{\\phi}) \\tan{\\theta} \\\\         \\dot{\\theta} = q \\cos{\\phi} + r \\sin{\\phi})     \\end{bmatrix} \\end{equation} <p>This propagated estimate is then used in the calculation of the Jacobian A.</p> \\begin{equation}     A =     \\begin{bmatrix}         (q \\cos{\\phi} - r \\sin{\\phi})\\tan{\\theta} &amp; \\frac{q\\sin{\\phi} + r\\cos{phi}}{\\cos^2{\\theta}} \\\\         0 &amp; -q \\sin{\\phi} - r \\cos{\\phi} \\\\     \\end{bmatrix} \\end{equation} <p>This Jacobian is then used to find a second-order approximation of the matrix exponential, A_d.</p> \\begin{equation}     A_d = I + \\frac{T_s}{N} A + \\frac{1}{2} \\frac{T_s^2}{N^2} A^2 \\end{equation} <p>Where T_s is the length of a time step. A_d is then used to propagate the actual covariance of the estimate.</p> <p>The process noise due to model uncertainty is defined in the matrix Q, but the process uncertainty due to the use of the rate gyro measurements Q_g, has not been adjusted for yet. This is done with the use of the matrix G which takes into account the Coriolis effects of the gyro measurements. The measurement variance is transformed into process noise due to gyro measurements. All of these contribute into finding the current covariance of our estimate, P. This is done by the following equation:</p> P_a = A_d P A_d^\\top + (Q + G Q_g G^\\top) \\frac{T_s^2}{N^2} <p>With this propagated estimate and covariance we are now ready for a measurement update.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#measurement-update","title":"Measurement Update","text":"<p>A measurement update provides a check on our propagated estimate and we take this new information and fuse it into our estimate. The Kalman filter allows us to optimally adjust our estimate, our tuned process noises, and the noise characteristics of our sensor given the measurement. These noise characteristics are captured in a diagonal matrix, R_{sensor}. The entries are the variances and for the attitude step this is defined as:</p> \\begin{equation}     R_{accel} =      \\begin{bmatrix}         \\sigma_{accel, x}^2 &amp; 0 &amp; 0 \\\\         0 &amp; \\sigma_{accel, y}^2 &amp; 0 \\\\         0 &amp; 0 &amp; \\sigma_{accel, z}^2 \\\\     \\end{bmatrix} \\end{equation} <p>Using our estimate and a model set of equations h, we predict the measurements the accelerometer will produce. We will then compare the actual and predicted measurements and optimally adjust our estimate with the new information. Since measurements come in much faster than the model propagates the measurement step is run every time the propagated estimate is calculated.</p> <p>Note</p> <p>The estimator asssumes that measurements come in faster than/as fast the estimation timer is calls for estimation updates. If this is not the case performance can actually go down for the estimation if you increase the frequency of the estimation updates.</p> <p>The set of equations, h, that predict the 3 measurements of the accelerometer, y, is given by:</p> \\begin{equation}     h =      \\begin{bmatrix}         q V_a \\sin{\\theta} + g \\sin{\\theta} \\\\         r V_a \\cos{\\theta} - p V_a \\sin{\\theta} - g \\cos{\\theta} \\sin{\\phi} \\\\         -q V_a \\cos{\\theta} - g \\cos{\\theta} \\cos{\\phi} \\\\     \\end{bmatrix} \\end{equation} <p>This yields a Jacobian C:</p> \\begin{equation}     C =      \\begin{bmatrix}         0 &amp; q V_a \\cos{\\theta} + g \\cos{\\theta} \\\\         -g \\cos{\\phi}\\cos{\\theta} &amp; -r V_a \\sin{\\theta} - p V_a \\cos{\\theta} + g \\sin{\\phi} \\sin{theta} \\\\         g \\sin{\\phi}\\cos{\\theta} &amp; (q V_a + g \\cos{\\phi}) \\sin{\\theta}     \\end{bmatrix} \\end{equation} <p>Which is used in finding the Kalman gain L. An intermediate value is calculated called S^{-1}. This value is:</p> \\begin{equation}     S^{-1} = (R_{accel} + CPC^\\top)^{-1} \\end{equation} <p>This intermediate value is then used to find L:</p> \\begin{equation}     L = PC^\\top S^{-1} \\end{equation} <p>The optimal estimate is then found:</p> \\begin{equation}     \\hat{x}_a^+ =  \\hat{x}_a^- + L (y - h) \\end{equation} <p>Finally, we update the covariance from our new estimate:</p> \\begin{equation}     P^+ = (I - LC) P^- (I - LC)^\\top + LR_{accel}L^\\top \\end{equation} <p>We repeat this cycle until termination of the program. This estimation scheme split into two parts allows for a clear set of equations and how the estimates affect one another. We will now move on to the next portion of the estimator that estimates the rest of the states.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#position-estimation","title":"Position Estimation","text":"<p>The position estimation step follows the same algorithm as previous. Only new values are used for each of the matrices. Those new entries are shown here, but reference the previous section for details on implementation.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#propagation_1","title":"Propagation","text":"<p>The attitude estimation is propagated according to the model f:</p> \\begin{equation}     f =     \\begin{bmatrix}         V_g \\cos{\\chi} \\\\         V_g \\sin{\\chi} \\\\         \\dot{V_g} \\\\         0 \\\\         0 \\\\         \\dot{\\psi} \\\\     \\end{bmatrix} \\end{equation} <p>Where,</p> \\begin{equation}     \\dot{\\psi} = q \\sin{\\phi} + r \\frac{\\cos{\\phi}}{\\cos{\\theta}} \\\\     \\dot{V_g} = \\frac{V_a}{V_g} \\dot{\\psi} (w_e \\cos{\\psi} - w_n \\sin{\\psi}) \\end{equation} <p>This propagated estimate is then used in the calculation of the Jacobian A.</p> \\begin{equation}     A =     \\begin{bmatrix}         0 &amp; 0 &amp; \\cos{\\chi} &amp; -V_g \\sin{\\chi} &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; \\sin{\\chi} &amp; V_g \\cos{\\chi} &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; -\\frac{\\dot{V_g}}{V_g} &amp; 0 &amp; -\\dot{\\psi} V_a \\frac{\\sin{\\psi}}{V_g} &amp; \\dot{\\psi} V_a \\frac{\\cos{\\psi}}{V_g} &amp; -\\dot{\\psi} V_a (w_n \\cos{\\psi} + w_e \\sin{\\psi}) \\\\         0 &amp; 0 &amp; -\\frac{g}{V_g^2} \\tan{\\phi} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\     \\end{bmatrix} \\end{equation} <p>This Jacobian is then used to find a second-order approximation of the matrix exponential, A_d.</p> \\begin{equation}     A_d = I + \\frac{T_s}{N} A + \\frac{1}{2} \\frac{T_s^2}{N^2} A^2 \\end{equation} <p>Where T_s is the length of a time step. A_d is then used to propagate the actual covariance of the estimate.</p> <p>The process noise due to model uncertainty is defined in the matrix Q and is fused into the covariance. This is done by the following equation:</p> P_a = A_d P A_d^\\top + Q \\frac{T_s^2}{N^2} <p>With this propagated estimate and covariance we are now ready for a measurement update.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#measurement-update_1","title":"Measurement Update","text":"<p>Because the GPS measures come in slower than the model propagates, the measurement step is only run when there is new GPS information. This process is identical to the measurement update in the attitude step. This will likely change before release, but the only difference is that it is done one measurement at a time. This has advantages for querying the values while debugging, but is on the whole less clear and is more error prone. The math is the same but it is carried through, and expressed as the final sum and each row calculated separately.</p> <p>The measurement model, h has only 6 entries instead of 7 since heading, \\psi is not measured. A digital compass could be added and h and C expanded if desired, but control is operated on course, \\chi, so this proves largely unnecessary.</p> \\begin{equation}     h =      \\begin{bmatrix}         p_n \\\\         p_e \\\\         V_g \\\\         \\chi \\\\         V_a \\cos{\\psi} + w_n - V_g \\cos{\\chi} \\\\         V_a \\sin{\\psi} + w_e - V_g \\sin{\\chi} \\\\     \\end{bmatrix} \\end{equation} <p>This yields a Jacobian C:</p> \\begin{equation}     C =      \\begin{bmatrix}         1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; -\\cos{\\chi} &amp; V_g\\sin{\\chi} &amp; 1 &amp; 0 &amp; -V_a\\sin{\\psi} \\\\         0 &amp; 0 &amp; -\\sin{\\chi} &amp; -V_g\\cos{\\chi} &amp; 0 &amp; 1 &amp; V_a\\cos{\\psi} \\\\     \\end{bmatrix} \\end{equation} <p>Which is used in finding the Kalman gain L.</p> <p>The measurement noise matrix, R_{position}, is defined as:</p> \\begin{equation}     R_{position} =      \\begin{bmatrix}         \\sigma_{gps, n}^2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; \\sigma_{gps, e}^2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; \\sigma_{gps, V_g}^2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; \\sigma_{gps, \\chi}^2 &amp; 0 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; \\sigma_{pseudo, w_n}^2 &amp; 0 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\sigma_{pseudo, w_n}^2 &amp; 0 \\\\         0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\sigma_{pseudo, \\psi}^2 \\\\     \\end{bmatrix} \\end{equation} <p>An intermediate value is calculated called S^{-1}. This value is:</p> \\begin{equation}     S^{-1} = (R_{position} + CPC^\\top)^{-1} \\end{equation} <p>This intermediate value is then used to find L:</p> \\begin{equation}     L = PC^\\top S^{-1} \\end{equation} <p>The optimal estimate is then found:</p> \\begin{equation}     \\hat{x}_a^+ =  \\hat{x}_a^- + L (y - h) \\end{equation} <p>Finally, we update the covariance from our new estimate:</p> \\begin{equation}     P^+ = (I - LC) P^- (I - LC)^\\top + LR_{accel}L^\\top \\end{equation} <p>We repeat this cycle until termination of the program.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#software-architecture","title":"Software Architecture","text":""},{"location":"developer-guide/rosplane/estimator/estimator-example/#estimator-implementation-specifics","title":"Estimator implementation Specifics","text":"<p>The estimator calls the update of the estimate on a timer. Between estimation updates, the measurements come in as they are published and are saved in the estimator. This allows asynchronous measurements and for only the most recent measurements to be used. It does mean however, that the propagation is reliant on the measurements being faster or as fast as the estimation updates. It also means that turning up the estimation frequency will not always have the anticipated effect. To increase estimator performance a combination of process noise tuning, sensor uncertainty characterization, sensor update speed increase estimate update speed increase will be needed.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-example/#replacing-the-estimator","title":"Replacing the Estimator","text":"<p>To replace the estimator all that needs to be done is inherit from the <code>estimator_base</code> class and override the <code>estimate</code> method, as described in the .hpp file.</p> Figure 1: The member method that must be overriden to use a new estimator. <p>Next, replace <code>estimator_example.cpp</code> in the <code>CMakeLists.txt</code> with the newly created estimator file.</p> Figure 2: The location to replace the file for the new estimator file."},{"location":"developer-guide/rosplane/estimator/estimator-example/#parameters","title":"Parameters","text":"Parameter Explanation Type Range <code>sigma_n_gps</code> The standard deviation of gps measurements in the north axis. double ~0.01 meters <code>sigma_e_gps</code> The standard deviation of gps measurements in the east axis. double ~0.01 meters <code>sigma_Vg_gps</code> The standard deviation of gps ground speed measurements. double ~0.005 \\frac{m}{s} <code>sigma_course_gps</code> The standard deviation of gps ground course measurements. double ~0.00025 radians <code>sigma_accel</code> The standard deviation of accelerometer measurements. double ~0.025 \\frac{m}{s^2} <code>sigma_pseudo_wind_n</code> The standard deviation of pseudo-measurement along the north axis. double ~0.01 <code>sigma_pseudo_wind_e</code> The standard deviation of pseudo-measurement along the east axis. double ~0.01 <code>sigma_heading</code> The standard deviation of heading measurement. double ~0.01 radians <code>lpf_a</code> The lowpass filter cutoff frequency for the gyro and accelerometers. double ~50.0 Hz <code>lpf_a1</code> The lowpass filter cutoff frequency for the pressure sensors. double ~8.0 Hz <code>gps_n_lim</code> The limit of GPS measurements in the north direction. double \\geq 10000 meters <code>gps_e_lim</code> The limit of GPS measurements in the east direction. double \\geq 10000 meters <code>roll_process_noise</code> The process noise on the roll propagation. double ~0.0001 <code>pitch_process_noise</code> The process noise on the pitch propagation. double ~0.0000001 <code>gyro_process_noise</code> The process noise on the gyro inversion. double ~0.13 <code>pos_process_noise</code> The process noise on the position propagation. double 0.1 <code>attitude_initial_cov</code> Initial covariance entry for attitude. double 5.0 <code>pos_n_initial_cov</code> Initial covariance entry for position north. double 0.03 <code>pos_e_initial_cov</code> Initial covariance entry for position east. double 0.03 <code>vg_initial_cov</code> Initial covariance entry for groundspeed. double 0.01 <code>chi_initial_cov</code> Initial covariance entry for course. double 5.0 Degrees <code>wind_n_initial_cov</code> Initial covariance entry for wind north. double 0.04 <code>wind_e_initial_cov</code> Initial covariance entry for wind east. double 0.04 <code>psi_initial_cov</code> Initial covariance entry for heading. double 5.0 <code>num_propagation_steps</code> Number of propagation steps to run between measurements. int 10 <code>max_estimated_phi</code> The maximum roll estimate before estimator saturation. double ~90.0 degrees <code>max_estimated_theta</code> The maximum pitch estimate before estimator saturation. double ~80.0 degrees <code>estimator_max_buffer</code> The buffer that the esimator returns the estimate to after saturation. double ~3.0 degrees"},{"location":"developer-guide/rosplane/estimator/estimator-overview/","title":"Estimator Overview","text":""},{"location":"developer-guide/rosplane/estimator/estimator-overview/#estimator-overview","title":"Estimator Overview","text":""},{"location":"developer-guide/rosplane/estimator/estimator-overview/#overview","title":"Overview","text":"<p>The estimator is a continuous-discrete Kalman Filter, a full treatment of the filter is found in section 8.5 of the UAV book. This filter essentially works by inverting a few sensor models and then using a two stage estimation of first the attitude and then the position state values. This page will outline the states, their meaning and any general notes on the states. For a more in depth look at which states are estimated in which way visit the Estimator Base and Estimator Example pages.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-overview/#ros-interactions","title":"ROS Interactions","text":"<p>The estimator takes in sensor information from <code>rosflight_io</code> computes an estimate and publishes it to the rest of ROSplane.</p> Figure 1: ROS network interactions for the estimator."},{"location":"developer-guide/rosplane/estimator/estimator-overview/#input","title":"Input","text":"<p>The inputs to the estimator are, accelerometer, rate gyro, barometer, differential pressure, GPS position, and GPS velocity estimates. The table with the topic for each of the measures is below.</p> Measure Explanation Topic Accelerometer This measures the specfic force applied to the aircraft in the body frame axes (see section 7.1 in the UAV book for more details). <code>/imu/data/linear_acceleration</code> Rate Gyro This measures the angular velocity of the aircraft around the body frame axes. <code>/imu/data/angular_velocity</code> Barometer The barometer measures the ambient air pressure. It is calibrated on arm to establish a \"zero\" altitude measurement. <code>/baro/pressure</code> Differential Pressure The differential pressure sensor, measures the difference in pressure using a pitot tube due to forward velocity. <code>/airspeed/differential_pressure</code> GNSS Position GNSS postion gives the position of the aircraft in latitude, longitude and altitude. <code>/navsat_compat/fix</code> GNSS Velocity GNSS velocity gives the velocity of the aircraft in meters per second in the global NED frame. <code>/navsat_compat/vel</code> Status Indicates whether the aircraft is armed (indicating a need to initialize position and altitude estimates). <code>/status</code> <p>These topics provide the measures that are fused to create a state estimate.</p> Figure 1: ROS topic subscriptions and publications for the estimator."},{"location":"developer-guide/rosplane/estimator/estimator-overview/#output","title":"Output","text":"<p>There are 20 states estimated by the estimator that are published to the rest of ROSplane. These states cover the position, orientation and aerodynamic information for the aircraft. Below is a table of the <code>/estimated_state</code> message and what each of the fields represents. Note that there are more than 20 states listed in the following table, but this is because either Euler angles or quaternions can be used to express orientation. See the Frames and Derivation page for more information, or chapter 2 of the UAV book.</p> State Explanation Range/Type/Units postion[3] A 3 vector of the NED position of the aircraft. (-\\infty , \\infty) (float)(meters) va The airspeed of the aircraft. Always positive because it is the magnitude. (0 , \\infty) (float)(meters/second) alpha The angle of attack of the aircraft wing. (-\\pi, \\pi) (float)(radians) beta The side-slip angle of the aircraft. (-\\pi, \\pi) (float)(radians) phi The roll angle of the aircraft. (-\\pi, \\pi) (float)(radians) theta The pitch angle of the aircraft. (-\\pi, \\pi) (float)(radians) psi The yaw angle of the aircraft. (-\\pi, \\pi) (float)(radians) chi The course angle of the aircraft. (-\\pi, \\pi) (float)(radians) u The velocity in the body x axis. (-\\infty, \\infty) (float)(meters/second) v The velocity in the body y axis. (-\\infty, \\infty) (float)(meters/second) w The velocity in the body z axis. (-\\infty, \\infty) (float)(meters/second) p The angular velocity about the body x axis (rollrate). (-\\infty, \\infty) (float)(radians/second) q The angular velocity about the body y axis (pitchrate). (-\\infty, \\infty) (float)(radians/second) r The angular velocity about the body z axis (yawrate). (-\\infty, \\infty) (float)(radians/second) vg The groundspeed of the aircraft. Always positive because it is the magnitude. (0 , \\infty) (float)(meters/second) wn The global north velocity of the wind. (-\\infty , \\infty) (float)(meters/second) we The global east velocity of the wind. (-\\infty , \\infty) (float)(meters/second) _ The following entries are optional. _ quat[4] A 4 vector of the quaternion describing the orientation. (-1 , 1) (float) quat_valid A flag indicating whether the data in the quat entry is valid. True/False (bool) psi_deg The yaw angle of the aircraft in degrees. (-180, 180) (float)(degrees) chi_deg The course angle of the aircraft in degrees. (-180, 180) (float)(degrees) init_lat The latitude of the aircraft when first armed. (-90, 90) (float)(DDS) init_long The longitude of the aircraft when first armed. (-180, 180) (float)(DDS) init_alt The altitude of the aircraft when first armed. (0, \\infty) (float)(meters) <p>Note</p> <p>More states may be estimated in the estimator than listed, these states are just those useful to other parts of ROSplane.</p>"},{"location":"developer-guide/rosplane/estimator/estimator-overview/#running-the-estimator","title":"Running the Estimator","text":"<p>The estimator is in the main <code>rosplane</code> ROS package. The ROS executable is <code>estimator</code>, yielding the run command:</p> <p><code>ros2 run rosplane estimator</code></p> <p>To pass a set of parameters for the controller from a yaml file using the <code>--ros-args</code> option.</p> <p><code>ros2 run rosplane estimator --ros-args --params-file path/to/params.yaml</code></p> <p>Note</p> <p>Filepaths will need to be altered to work.</p> <p>Note</p> <p>The most common way of running the estimator is through a launch file with the rest of the ROSplane pipeline running as well. See the ROSplane Overview in the Developer and User Guides for more details.</p>"},{"location":"developer-guide/rosplane/navigation/navigation-overview/","title":"Navigation Overview","text":""},{"location":"developer-guide/rosplane/navigation/navigation-overview/#navigation-overview","title":"Navigation Overview","text":"<p>The path planning methods used in ROSplane is modeled after the architecture presented in Small Unmanned Aircraft: Theory and Practice by Dr. Randal Beard and Dr. Tim McLain.</p> <p>In their work, the path planning functionality of the aircraft is split into three main parts, as shown in Figure 1.</p> <p>Note</p> <p>This is not a full description of the architecture. For example, the state estimator is not shown, and not all of the inputs to each of the blocks is included. These elements were removed from the figure for simplicity.</p> Figure 1: Path planning architecture - based on Figure 1.1 in Small Unmanned Aircraft: Theory and Practice <p>The high-level path planning is done by the path planner node. The path planner's job is to manage, create, and publish waypoints. Those waypoints are published to the path manager node. The path manager's job is to determine and calculate the appropriate line segments and orbits needed to complete the waypoints. The path manager then publishes these straight lines and waypoints to the path follower.  The job of the path follower is to control the course, airspeed, and altitude of the aircraft to follow these lines and orbits.</p> <p>For more information on each of these nodes, see the related documentation pages for the path planner, the path manager, and the path follower. See also chapters 10-13 of the Small Unmanned Aircraft: Theory and Practice book.</p>"},{"location":"developer-guide/rosplane/navigation/navigation-overview/#changing-the-navigation-stack","title":"Changing the Navigation Stack","text":"<p>The path planner currently takes in a set of user-defined waypoints and follows those waypoints.  This is not useful in all contexts, since in many applications the aircraft needs to take in sensor data and create its own waypoints and paths.</p> <p>For example, we could replace the path planner block with a vision-based guidance block. The vision-based-guidance block would make decisions based on visual data to create waypoints.  However, the interface between the path planner (now the visual-based guidance planner) and the path manager would remain the same.</p> <p>Similarly, the path manager could be adjusted to follow b-splines instead of straight lines and orbits as currently implemented, without affecting the general waypoint management (path planner) or the underlying path following control loops (path follower).</p> <p>The modularity of this framework allows users to \"plug in\" their own algorithms for each of the blocks defined in Figure 1, instead of rewriting the whole path planning stack.</p> <p>Chapter 13 of the Small Unmanned Aircraft: Theory and Practice book contains more detail on implementing a vision-based path planner.</p>"},{"location":"developer-guide/rosplane/navigation/navigation-overview/#running-the-navigation-stack","title":"Running the Navigation Stack","text":"<p>To launch the navigation stack, you will need to launch 3 ROS2 nodes, one for each part of the navigation stack (path planner, manager, and follower).</p> <p>Remember to launch these nodes with the appropriate parameter launch file, as seen in the <code>rosplane.launch.py</code> file.</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/","title":"Path Follower","text":""},{"location":"developer-guide/rosplane/navigation/path-follower/#path-follower","title":"Path Follower","text":""},{"location":"developer-guide/rosplane/navigation/path-follower/#overview","title":"Overview","text":"<p>The role of the path follower is to generate the correct airspeed, course, and altitude commands for the autopilot such that the aircraft follows the paths published by <code>path_manager</code>.</p> <p>More information on the <code>path_follower</code> can be found in Small Unmanned Aircraft: Theory and Practice by Dr. Randal Beard and Dr. Tim McLain.</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/#path-follower-base","title":"Path Follower Base","text":"<p>The path follower base contains all the ROS2 interfaces required for the path follower. A list of these interfaces is below.</p> <p>The <code>path_follower_base::follow</code> method is a virtual method that should be implemented by a derived class. The <code>path_follower_base</code> publishes the controller commands calculated by the implementation of <code>path_follower_base::follow</code>.</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/#list-of-ros2-interfaces","title":"List of ROS2 Interfaces","text":"ROS2 Interface Topic or Service Explanation Message or Service Type <code>vehicle_state_sub_</code> <code>/estimated_state</code> Subscribes to the estimated aircraft state <code>rosplane_msgs::msg::State</code> <code>current_path_sub_</code> <code>/current_path</code> Subscribes to the current path messages published by <code>path_manager</code> <code>rosplane_msgs::msg::CurrentPath</code> <code>controller_commands_pub_</code> <code>/controller_commands</code> Publishes control commands to the autopilot <code>rosplane_msgs::msg::ControllerCommand</code> <code>update_timer_</code> -- ROS2 timer that controls how frequently <code>controller_commands_pub_</code> publishes --"},{"location":"developer-guide/rosplane/navigation/path-follower/#interface-with-the-autopilot","title":"Interface with the Autopilot","text":"<p>The <code>path_follower</code> node interfaces with the MAV autopilot by publishing to the <code>/controller_commands</code> topic. The <code>/controller_commands</code> topic contains the following information calculated by the <code>path_follower</code>:</p> Member Description Type / units Required <code>header</code> Standard message header that contains a valid timestamp <code>std_msgs::msg::Header</code> Yes <code>va_c</code> Commanded airspeed <code>double</code>, m/s Yes <code>h_c</code> Commanded altitude <code>double</code>, m Yes <code>chi_c</code> Commanded course <code>double</code>, rad Yes <code>phi_ff</code> Feedforward command (for orbits) <code>double</code>, rad No"},{"location":"developer-guide/rosplane/navigation/path-follower/#path-follower-example","title":"Path Follower Example","text":"<p>The <code>path_follower_example</code> class contains the implementation of the <code>path_follower_base::follow</code> method. This method contains the control command computations for straight line and orbit-type paths as outlined in Small Unmanned Aircraft: Theory and Practice.</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/#parameters","title":"Parameters","text":"<p>See the Parameter Management page for more details on how parameter management works.</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/#list-of-parameters","title":"List of Parameters","text":"Parameter Explanation Type / Units Range <code>chi_infty</code> At infinity, the angle at which the aircraft will approach the desired line double (rad) \\frac{\\pi}{2} \\geq \\chi^{\\infty} &gt; 0.0 <code>k_path</code> Constant that determines how quickly commanded course transitions from \\chi^{\\infty} to 0 during line following double &gt; 0.0 <code>k_orbit</code> Constant that determines how quickly commanded course transitions from \\lambda \\frac{\\pi}{2} to 0 during an orbit double &gt; 0.0 <p>Since there are two different types of lines generated by the <code>path_manager</code> (straight lines and orbits), the <code>path_follower</code> uses different parameters to calculate the control output for each path type.</p> <p>For line following, <code>path_follower</code> uses </p> <ul> <li><code>chi_infty</code> and </li> <li><code>k_path</code> to compute the control commands.</li> </ul> <p>As described in Small Unmanned Aircraft: Theory and Practice, these two parameters define a vector field for the commanded course. The <code>chi_infty</code> parameter describes the angle at which the aircratft will approach a target line if the aircraft is infinitely far from the target line. For example, if <code>chi_infty</code> is set to \\frac{\\pi}{2}, then the aircraft will approach the target line at an angle perpindicular to the line when the aircraft is far away.</p> <p>The <code>k_path</code> parameter defines how quickly the vectors at <code>chi_infty</code> \"smooth\" into the target line. When <code>k_path</code> is large, the transition will be abrupt, and when <code>k_path</code> is small, the transition will be smoother.</p> <p>During orbit following, <code>path_follower</code> uses</p> <ul> <li><code>k_orbit</code> to compute the control commands.</li> </ul> <p>If the aircraft is very far away from the orbit, it will align itself so it flies directly at the center of the orbit. The <code>k_orbit</code> parameter is similar to the <code>k_path</code> parameter in that it determines how quickly the commanded angle of the aircraft will change from directly toward the center to the orbit direction.</p> <p>Note</p> <p>When tuning, make sure you are changing the correct gains for the type of line (straight or orbit) the aircraft is tracking. <code>chi_infty</code> and <code>k_path</code> will not affect the orbit performance!</p>"},{"location":"developer-guide/rosplane/navigation/path-follower/#modifying-the-path-follower","title":"Modifying the Path Follower","text":"<p>Changes to any of the ROS2 interface should be done in the <code>path_follower_base</code>.</p> <p>Changes to how <code>path_follower</code> computes control commands to follow paths given by the <code>path_manager</code> should be done in the <code>path_manager_example</code>.</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/","title":"Path Manager","text":""},{"location":"developer-guide/rosplane/navigation/path-manager/#path-manager","title":"Path Manager","text":""},{"location":"developer-guide/rosplane/navigation/path-manager/#overview","title":"Overview","text":"<p>The path manager is responsible for calculating and publishing the current path to the path follower.  It is split into a base class and an inherited class. The base class handles the ROS2 interfaces (publishing and subscribing) while the inherited class manages the path, i.e., calculates the parameters for the current path.</p> <p>The path manager is designed this way so that the inherited class (how the paths are managed) can be replaced or rewritten without affecting the overlying ROS2 interface.</p> <p>Both the <code>path_manager_base</code> and the <code>path_manager_example</code> are included in the same ROS2 node when compiled, called <code>path_manager</code>. Parameters associated with the <code>path_manager_base</code> or the <code>path_manager_example</code> will therefore be visible under the <code>path_manager</code> ROS2 node.</p> <p>More details about the path manager can be found in Small Unmanned Aircraft: Theory and Practice by Dr. Randal Beard and Dr. Tim McLain.</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#path-manager-base","title":"Path Manager Base","text":"<p>The path manager base contains all the ROS2 interfaces required for the path manager. A list of these interfaces is below.</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#list-of-ros2-interfaces","title":"List of ROS2 Interfaces","text":"ROS2 Interface Topic or Service Explanation Message or Service Type <code>vehicle_state_sub_</code> <code>/estimated_state</code> Subscribes to the estimated aircraft state <code>rosplane_msgs::msg::State</code> <code>new_waypoint_sub_</code> <code>/waypoint_path</code> Subscribes to the waypoint messages published by <code>path_planner</code> <code>rosplane_msgs::msg::State</code> <code>current_path_pub_</code> <code>/current_path</code> Publishes the parameters of the current path <code>rosplane_msgs::msg::CurrentPath</code> <code>update_timer_</code> -- ROS2 timer that controls how frequently <code>current_path_pub_</code> publishes --"},{"location":"developer-guide/rosplane/navigation/path-manager/#interface-with-the-path-follower","title":"Interface with the Path Follower","text":"<p>The <code>path_manager</code> node interfaces with the path follower by publishing to the <code>/current_path</code> topic. These messages contain information about the current trajectory, which are either straight lines or circles. </p> <p>Note that the only supported path types are straight lines and circles. Depending on how the <code>path_manager</code> is set up to manage the waypoints, this may not be suitable for your application. See \"Modifying the Path Manager\" for more information. For more information on the path follower, see the Path Follwer documentation.</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#path-manager-example","title":"Path Manager Example","text":"<p>The <code>path_manager_example</code> class inherits from the <code>path_manager_base</code> class. Specifically, the <code>path_manager_example</code> overrides the <code>path_manager_base::manage</code> method to determine how the path is managed.</p> <p>In the current implementation, <code>path_manager_example</code> decides to manage a waypoint using straight lines and fillets, orbits, or Dubins paths based on the current state of the aircraft, the values of the current ROS2 parameters, and the waypoints given. For example, if the <code>use_chi</code> field on a Waypoint object (see Path Planner for more information) is set to <code>true</code>, then <code>path_manager_example</code> will use a Dubins path to navigate to the next waypoint. If <code>use_chi</code> is set to <code>false</code>, then <code>path_manager_example</code> will use straight lines when navigating in between waypoints and a fillet to manage the corners. See Figure 1 for an example of a real flight path flown using ROSplane with <code>chi_d</code> set to <code>false</code>.</p> Example flight path from an actual flight test showing the straight lines and fillets path type <p>Note that using fillets to manage the corners often means that the aircraft does not actually achieve the waypoint. If this is undesirable in your application, use Dubins paths or another method for the <code>path_manager</code>. </p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#parameters","title":"Parameters","text":"<p>See the Parameter Management page for more details on how parameter management works.</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#list-of-parameters","title":"List of Parameters","text":"Parameter Explanation Type Range <code>R_min</code> Minimum radius for orbit, fillet, and Dubins paths double \\geq 0.0 <code>orbit_last</code> Specifies whether or not to orbit the last waypoint. If false, <code>param_manager</code> will fly a circuit bool <code>true</code> or <code>false</code>"},{"location":"developer-guide/rosplane/navigation/path-manager/#the-orbit_last-parameter","title":"The <code>orbit_last</code> Parameter","text":"<p>The <code>path_manager</code> node has a parameter named <code>orbit_last</code>. This parameter controls what happens as the aircraft is approaching the last waypoint in the set of waypoints published to the <code>path_manager</code>. If <code>orbit_last</code> is set to <code>true</code>, then <code>path_manager</code> will follow an orbit around the last waypoint.</p> <p>The direction of this waypoint (clockwise or counterclockwise) will be chosen based on which direction requires the least amount of turning. In other words, if the aircraft is angled slightly left as it approaches the waypoint, <code>path_manager</code> will choose to orbit the last waypoint counterclockwise (from a top-down perspective). If the aircraft is pointing slightly right as it approaches the waypoint, it will orbit the waypoint clockwise (from a top-down perspective).</p>"},{"location":"developer-guide/rosplane/navigation/path-manager/#modifying-the-path-manager","title":"Modifying the Path Manager","text":"<p>Changes or additions to any ROS2 interfaces should be done in the <code>path_manager_base</code> field.</p> <p>Changes to how <code>path_manager</code> \"manages\" the waypoints should be done by overriding the <code>path_manager_base::manage</code> method. If you wish to change the way paths are defined, make sure that the <code>/current_path</code> topic is rewritten to contain the required information, and then make sure the <code>path_follower</code> knows how to handle the new definition.</p>"},{"location":"developer-guide/rosplane/navigation/path-planner/","title":"Path Planner","text":""},{"location":"developer-guide/rosplane/navigation/path-planner/#path-planner","title":"Path Planner","text":""},{"location":"developer-guide/rosplane/navigation/path-planner/#overview","title":"Overview","text":"<p>The path planner is responsible for creating, managing, and publishing waypoints. In the current implementation, the path planner simply maintains a list of user-defined waypoints that the user can add to or clear. The path planner then controls when waypoints are published to the path manager.</p> <p>Another implementation of the path planner (as described in the overview) could include a visual-based path planner. In this case, the path planner would receive sensor input and create and manage its own waypoints instead of a user-defined list of waypoints. However, this new path planner would still be responsible for creating and publishing waypoints. This ensures that the interface between the path planner and the path manager would stay the same, allowing for modularity in the path planner architecture.</p>"},{"location":"developer-guide/rosplane/navigation/path-planner/#interfaces","title":"Interfaces","text":"<p>The path planner is implemented as a standalone ROS2 node, called <code>path_planner</code>. This node subscribes to the topics it needs, provides services available to the user and other nodes, and publishes waypoints to the path manager, called <code>path_manager</code>.</p> <p>The interface between <code>path_planner</code> and <code>path_manager</code> is the <code>/waypoint_path</code> topic,  which publishes messages with the <code>rosplane_msgs::msg::Waypoint</code> type. This message contains information about the waypoint's location in NED (from the origin) or GNSS (LLA) coordinates, the desired airspeed at the waypoint, and the desired heading of the aircraft at the waypoint.</p>"},{"location":"developer-guide/rosplane/navigation/path-planner/#about-waypoints","title":"About Waypoints","text":"<p>The following table contains the data members of the <code>rosplane_msgs::msg::Waypoint</code> objects and a brief description.</p> Member Description Type Required <code>header</code> Standard message header that contains a valid timestamp <code>std_msgs::msg::Header</code> Yes <code>w</code> Waypoint coordinates in NED or GNSS (LLA) <code>std::array&lt;float32, 3&gt;</code> Yes <code>lla</code> Flag to determine if the coordinates are passed in as NED or GNSS <code>bool</code> Yes <code>chi_d</code> Desired course at the waypoint <code>double</code> No <code>use_chi</code> Flag to use the <code>chi_d</code> value at the waypoint or not <code>bool</code> No - defaults to <code>false</code> <code>va_d</code> Desired airspeed at the waypoint <code>double</code> Yes <code>clear_wp_list</code> Clears all waypoints from <code>path_planner</code> and <code>path_manager</code> <code>bool</code> No"},{"location":"developer-guide/rosplane/navigation/path-planner/#notes-on-the-waypoint-object-fields","title":"Notes on the Waypoint object fields","text":"<p>The <code>w</code> field contains the coordinates of the waypoint in either NED coordinates (from the origin, defined as the place where ROSplane initialized) or GNSS coordinates given in LLA (latitude, longitude, and altitude). The GNSS coordinates are converted to NED coordinates by <code>path_planner</code> before sending them to <code>path_manager</code>.</p> <p>The <code>lla</code> field is a flag that tells <code>path_planner</code> if the coordinates provided are in the NED or world (GNSS) frame. Set it to <code>true</code> if the coordinates for the waypoint are given in GNSS coordinates. Note that GNSS and relative waypoints can be used together, meaning that one waypoint could be in the NED frame while the next one is in the global frame, since ROSplane converts global coordinates to the NED frame before publishing them to <code>path_manager</code>. </p> <p>Note</p> <p>Make sure that the <code>lla</code> field is set correctly if you decide to use GNSS coordinates, or your waypoints will be incorrect.</p> <p>The <code>chi_d</code> field controls the desired course at the waypoint. Note that this is only used if the <code>use_chi</code> flag is set to <code>true</code>. </p> <p>The <code>use_chi</code> field determines whether or not the <code>path_manager</code> should pay attention to the desired course (<code>chi_d</code>).  If <code>use_chi</code> is set to <code>true</code> then <code>path_manager</code> will use a Dubins path framework to manage the waypoint. If <code>use_chi</code> is set to <code>false</code>, then <code>path_manager</code> will ignore the desired course and will intead use straight lines and fillets to manage the transitions between waypoints. See the Path Manager documentation for more information on this behavior.</p> <p>The <code>clear_wp_list</code> is used internally by <code>path_planner</code> when the <code>/clear_waypoints</code> service is called. It is recommended to use the service call instead of using this field manually.</p> <p>Warning</p> <p>The <code>header</code>, <code>w</code>, <code>va_d</code>, and <code>lla</code> fields must be valid for every waypoint message sent. Failure to add these fields might crash the path planner or your aircraft.</p>"},{"location":"developer-guide/rosplane/navigation/path-planner/#list-of-ros2-interfaces","title":"List of ROS2 Interfaces","text":"ROS2 Interface Topic or Service Explanation Message or Service Type <code>waypoint_publisher_</code> <code>/waypoint_path</code> Publishes the waypoints to the <code>path_manager</code> <code>rosplane_msgs::msg::Waypoint</code> <code>state_subscription_</code> <code>/estimated_state</code> Subscribes to the estimated state of the aircraft <code>rosplane_msgs::msg::State</code> <code>next_waypoint_service_</code> <code>/publish_next_waypoint</code> Publishes the next stored waypoint <code>std_msgs::srv::Trigger</code> <code>add_waypoint_service_</code> <code>/add_waypoint</code> Adds a new waypoint to list and optionally publishes it <code>rosplane_msgs::srv::AddWaypoint</code> <code>clear_waypoint_service_</code> <code>/clear_waypoints</code> Clears the list of waypoints from the path planner and publishes a clear waypoint command to the <code>path_manager</code> <code>std_msgs::srv::Trigger</code> <code>print_waypoints_service_</code> <code>/print_waypoints</code> Prints the saved waypoints to the terminal. Can be useful when debugging <code>std_msgs::srv::Trigger</code> <code>load_mission_service_</code> <code>/load_mission_from_file</code> Loads a mission from a YAML file <code>rosflight_msgs::srv::ParamFile</code>"},{"location":"developer-guide/rosplane/navigation/path-planner/#parameters","title":"Parameters","text":"<p>See the Parameter Management page for more details on how parameter management works.</p>"},{"location":"developer-guide/rosplane/navigation/path-planner/#list-of-parameters","title":"List of Parameters","text":"Parameter Explanation Type Range <code>num_waypoints_to_publish_at_start</code> Number of waypoints to immediately publish at launch. If no waypoints are added, it will not publish any. int \\geq 0"},{"location":"developer-guide/rosplane/navigation/path-planner/#recommended-usage","title":"Recommended Usage","text":"<p>We recommend using a YAML file and the <code>/load_mission_from_file</code> service from the command line to load and fly waypoints. See the example mission YAML file located at <code>/path/to/rosplane/rosplane/missions/fixedwing_mission.yaml</code>.</p> <p>To call the service, run </p><pre><code>ros2 service call /load_mission_from_file rosflight_msgs::srv::ParamFile \"{filename: &lt;FILENAME&gt;}\"\n</code></pre> where <code>&lt;FILENAME&gt;</code> is the path to the mission YAML file.<p></p>"},{"location":"publications/rosflight/","title":"ROSflight","text":""},{"location":"publications/rosflight/#rosflight","title":"ROSflight","text":"This browser does not support PDFs. Please download the PDF to view it:      &amp;lt;a href=\"pdfs/ROSflight_Paper_Outline.pdf\"&amp;gt;Download PDF&amp;lt;/a&amp;gt;."},{"location":"publications/rosplane/","title":"ROSplane","text":""},{"location":"publications/rosplane/#rosplane","title":"ROSplane","text":"This browser does not support PDFs. Please download the PDF to view it:      &amp;lt;a href=\"pdfs/ROSplane_Paper_Outline.pdf\"&amp;gt;Download PDF&amp;lt;/a&amp;gt;."},{"location":"user-guide/customizing-rosflight/","title":"Customizing ROSflight","text":""},{"location":"user-guide/customizing-rosflight/#customizing-rosflight","title":"Customizing ROSflight","text":"<p>The ROSflight core functionality is intentionally lean, meaning the feature set is small. While this increases understandability and can improve research productivity, it also means that the core ROSflight functionality will not satisfy all researcher's needs. Additionally, research involves designing and testing novel features and algorithms, so no autopilot will have all the functionality desired by a researcher.</p> <p>Thus, to be useful to researchers, ROSflight has been designed to be as modular and extensible as possible. In other words, ROSflight has been designed to be modified, customized, and extended. This enables researchers to do research with minimal effort.</p> <p>This page describes how ROSflight is structured to allow researchers maximum flexibility. We also give some examples of how elements of ROSflight could be modified.</p> <p>Customizing ROSflight firmware vs ROSflight autonomy stacks</p> <p>As described in the overview page, ROSflight is split into a companion computer and an embedded flight control unit (FCU). The companion computer has the ROSflight autonomy stacks while the FCU runs the ROSflight firmware and handles sensor and actuator I/O.</p> <p>Modules on the companion computer and modules on the FCU are designed differently, so the methods for customizing the ROSflight autonomy stacks and the ROSflight firmware are different.</p> <p>ROSflight architecture</p> <p>This page will not go over the ROScopter/ROSplane/ROSflight firmware architecture, but we do reference it. Please see the respective documentation for a description of each module before reading through this page.</p>"},{"location":"user-guide/customizing-rosflight/#customizing-rosflight-firmware","title":"Customizing ROSflight firmware","text":"<p>The core ROSflight firmware resides on an embedded microcontroller. Most users of ROSflight will not need to customize the ROSflight firmware, since the vast majority of the autonomy stack is on the companion computer.</p> <p>If you need to customize the ROSflight firmware, first consider if you can accomplish what you need on the companion computer. If you still need to customize the ROSflight firmware, make your changes and then follow the building and flashing guide to flash it on your board.</p> <p>However, since ROSflight currently supports only limited hardware, users may need to write a new board-specific support package for the ROSflight firmware. The ROSflight firmware depends on an abstraction of a physical board. This means that supporting ROSflight on a new board does not require users to change the core ROSflight firmware code. Instead, users only have to write drivers for sensors and implement the board-specific functions in the interface file.</p>"},{"location":"user-guide/customizing-rosflight/#customizing-autonomy-stacks","title":"Customizing Autonomy Stacks","text":"<p>The core ROSflight autonomy stacks, ROSplane and ROScopter, reside entirely on the companion computer and are comprised of groups of core modules. Customizing these autonomy stacks involves changing, removing, or replacing a single module or groups of modules.</p>"},{"location":"user-guide/customizing-rosflight/#modifying-a-single-node","title":"Modifying a single node","text":""},{"location":"user-guide/customizing-rosflight/#dependency-on-ros-2","title":"Dependency on ROS 2","text":"<p>Each module in ROScopter and ROSplane (e.g. <code>path_planner</code>, <code>path_manager</code>, <code>controller</code>) is implemented as a ROS 2 node. Each node has a clear interface with the rest of ROSflight defined by its ROS 2 interfaces (i.e. publishers, subscribers, service servers, etc.). Each module communicates with the rest of ROSflight only over these ROS 2 interfaces.</p> <p>This dependency on ROS 2 removes dependencies between the implementations of each module. For example, regardless of how the ROScopter <code>estimator</code> node is implemented (e.g. EKF vs invariant EKF vs any other estimator variant), as long as it has the same publishers and subscribers as the core ROScopter <code>estimator</code> node, then it will integrate seamlessly with the rest of ROScopter and ROSflight.</p> <p>Researchers can replace any node in ROSflight with their application code. All that is required for the new code is that it has the same ROS 2 interfaces as the core ROSflight node.</p> Replacing a core ROScopter node <p>A researcher studying model predictive control (MPC) wants to use ROSflight. The researcher has already implemented his controller as a separate C++ library, and it takes in reference trajectories and outputs low-level controller commands.</p> <p>Since the MPC controller takes in a trajectory and returns low-level control commands, the ideal node to replace would be the ROScopter <code>trajectory_follower</code>. The researcher has already implemented it as a C++ library, so all he needs to do is write a ROS 2 wrapper around his library to have the same ROS 2 interfaces as the ROSflight <code>trajectory_follower</code>.</p> <p>Another option would be to create a derived class from the ROScopter <code>trajectory_follower</code> interface class that forwards function calls to his library.</p> <p>The dependency on ROS 2 also allows seamless cross-language support (for languages supported by ROS 2). For example, any C++ node could be replaced by a Python node---as long as the ROS 2 interfaces are the same, ROSflight will compile and run.</p> Replacing a core ROScopter node with a Python node <p>Another researcher is studying model predictive control (MPC) and wants to use ROSflight. The researcher has already implemented her controller in Python, and it takes in reference trajectories and outputs low-level controller commands.</p> <p>Since the MPC controller takes in a trajectory and returns low-level control commands, the ideal node to replace would be the <code>trajectory_follower</code>. The researcher has already implemented it in Python, so all she needs to do is write a ROS 2 wrapper around her library to have the same ROS 2 interfaces as the ROSflight <code>trajectory_follower</code>.</p> <p>The core ROSflight <code>trajectory_follower</code> is written in C++, so another option would be to rewrite the Python code in C++ and implement it as in the previous example.</p> <p>Additionally, each module in ROScopter and ROSplane has a single responsibility, further removing dependencies between modules and functionality in ROSflight.</p> Replacing a core ROSplane node - Single responsibility principle <p>A researcher interested in state estimation wants to use ROSflight.</p> <p>Since the researcher only wants to test new state estimation algorithms, the ROSplane <code>controller</code>, <code>path_manager</code>, <code>path_planner</code>, or <code>path_follower</code> modules do not need to be modified. This is because all relevant code is in the <code>estimator</code> node, whose single responsibility is to perform state estimation.</p>"},{"location":"user-guide/customizing-rosflight/#inheritance-pattern","title":"Inheritance pattern","text":"<p>Most of the modules in ROSflight have been designed with an inheritance pattern and are written in C++. The base class is an abstract class and defines the ROS 2 interfaces for the node and declares work functions for the node. These work functions are where the node does its job, like estimating the state for the <code>estimator</code> or creating a trajectory for the <code>path_manager</code>. They are declared as pure virtual functions and thus must be implemented by a derived class.</p> <p>This inheritance pattern reduces boilerplate code (i.e. rewriting the ROS 2 interfaces) for users.</p> <p>Implementing custom code in ROSflight can be done by subclassing/inheriting from the interface class and implementing the custom functionality.</p>"},{"location":"user-guide/customizing-rosflight/#modifying-groups-of-nodes","title":"Modifying groups of nodes","text":"<p>In some cases, application code can take the place of several core ROSflight nodes. The procedure for replacing groups of nodes in ROSflight is the same as it is to replace a single node. As long as the ROS 2 interfaces remain the same between the other core ROSflight nodes, the new node will interface seamlessly with the rest of ROSflight.</p> <p>The linear, cascaded flow of information through ROSflight makes this easy. Modules typically only depend on output from the module just above, so changes to upstream modules don't affect how downstream modules are implemented.</p> Replacing a group of nodes <p>A researcher studying spline-based path planning wants to use ROSplane. The new spline-based planning approach takes in information about the enviroment (i.e. obstacles, start and end locations, etc.) and outputs course, airspeed, and altitude commands.</p> <p>This new code replaces the functionality provided by the core ROSplane navigation stack (the <code>path_planner</code>, <code>path_manager</code>, and <code>path_follower</code>). The researcher can therefore replace all these nodes with the new spline-based controller. The new node just needs to output commands to the ROSplane <code>controller</code> as the ROSplane <code>path_follower</code> does.</p>"},{"location":"user-guide/customizing-rosflight/#intended-workflow-for-the-core-rosflight-autonomy-stacks","title":"Intended workflow for the core ROSflight autonomy stacks","text":"<p>When using ROScopter or ROSplane, users should first determine which core ROSflight nodes will be replaced by the new application code. Depending on the application, a single node or a group of nodes may need to be modified as described above. Some applications may not need to modify any core ROSflight nodes.</p> <p>After determining which core nodes to modify/replace, the application code should be tested in ROSflight sim. Note that the simulation makes assumptions about the vehicle's mass, size, inertia matrix, etc. For ROScopter, these values are based off a real quadcopter (the Holybro x650 frame), so they are somewhat realistic. ROSplane's aerodynamic coefficients are based off of the aerodynamic analysis of a RMRC Anaconda. If you will not do hardware experiments, these parameters will likely work just fine.</p> <p>If hardware experiments will be performed, then users should set airframe-specific parameters appropriately in ROSflight sim and also in each of the ROSflight nodes (many ROSflight nodes need to know about the mass of the vehicle). This helps ease the transition from sim to real tests.</p> <p>Remember that ROScopter and ROSplane run entirely on the companion computer, so no software changes are necessary when transitioning from simulation to hardware.</p>"},{"location":"user-guide/overview/","title":"Overview","text":""},{"location":"user-guide/overview/#overview","title":"Overview","text":"<p>New to ROS2?</p> <p>If you are new to ROS2, we recommend you start with the ROS2 tutorials. We assume that users of ROSflight have a basic understanding of ROS2 CLI tools and interfaces. We do not provide any ROS2 tutorials ourselves.</p> <p>New to ROSflight?</p> <p>If you are new to ROSflight, we recommend that you first start by setting up the simulation environment and learning to use the ROSflight ecosystem. Do this by following the installation for sim guides, and then the ROSflight tutorials.</p> <p>After you do that, you should be ready to start using ROSflight in your own research! We recommend you first read through the architecture documentation for ROSplane and ROScopter.</p> <p>Then visit the Customizing ROSflight page for more specifics on how to customize ROSflight for your research.</p>"},{"location":"user-guide/overview/#main-components-of-rosflight","title":"Main Components of ROSflight","text":"<p>ROSflight is intended to be used with both a typical flight controller and a companion Linux computer. Although it can be used with just a flight controller, this setup will not offer most of the advantages of ROSflight.</p> <p>Note</p> <p>To avoid confusion, we try to consistently use the following terminology:</p> <ul> <li>Flight controller: The embedded board that runs the ROSflight firmware and performs I/O with sensors and ESCs</li> <li>Companion computer: A Linux computer, running ROS2, that is mounted on the vehicle and has a physical, serial connection with the flight controller</li> <li>Offboard control (setpoints): The control setpoints passed from the companion computer to the flight controller. The control is \"offboard\" from the perspective of the flight controller, even though the computer providing those commands is mounted onboard the vehicle.</li> </ul> <p>The following figure illustrates the interactions between the major components of ROSflight:</p> <p></p>"},{"location":"user-guide/overview/#firmware","title":"Firmware","text":"<p>The ROSflight firmware is the low level microcontroller code that runs on the flight controller. This communicates directly with sensors and actuators and serves as the bridge between hardware and higher level software. The firmware itself is designed to do as little as possible, offloading most of the work to the companion computer.</p> <p>Although higher level control is offloaded to the companion computer, enough control and functionality is included in the firmware to enable a safety pilot to fly the UAV through any portion of the flight with or without an operating companion computer.</p>"},{"location":"user-guide/overview/#rosflight-io","title":"ROSflight IO","text":"<p>ROSflight IO is a ROS2 node that runs on the companion computer that communicates directly with the firmware over a serial connection. This serves as the bridge between the firmware and the rest of ROS2 network.</p>"},{"location":"user-guide/overview/#rosplane-and-roscopter","title":"ROSplane and ROScopter","text":"<p>ROSplane and ROScopter are ROS2 based autonomy stacks that run on the companion computer and do most of the heavy computation of the autopilot. Each portion of their autonomy stacks are organized into highly modular ROS nodes that can be easily swapped out with custom nodes.</p> <p>ROSplane and ROScopter are not required for using ROSflight and you could choose to use an entirely different autonomy stack if you so desired. See the ROSplane and ROScopter documentation for a detailed description of the respective architectures and functionality.</p>"},{"location":"user-guide/overview/#rc-safety-pilot","title":"RC Safety Pilot","text":"<p>ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer. See the RC Setup page for more information.</p>"},{"location":"user-guide/overview/#where-do-i-start","title":"Where do I start?","text":"<p>To get started with ROSflight, we recommend you first set up the simulation environment and walk through the tutorials to get familiar with the ROSflight ecosystem.</p> <p>If you are ready to start with hardware experiments, first install the required software and then follow the hardware setup guide to configure your vehicle for successful flight tests.</p>"},{"location":"user-guide/rosflight-io/","title":"ROSflightIO","text":""},{"location":"user-guide/rosflight-io/#rosflight-io","title":"ROSflight IO","text":"<p>As seen in the diagram below, the <code>rosflight_io</code> node is one of the major components in the ROSflight ecosystem. This document describes the responsibilities of the <code>rosflight_io</code> node and how users should expect to interact with the node.</p> Diagram of the major system components in ROSflight <p>The <code>rosflight_io</code> node is a ROS 2 node that runs on the companion computer. Code for this node is located in the <code>rosflight_ros_pkgs</code> repository on GitHub. This code can be installed and run following the installation and tutorial guides.</p> <p>Note</p> <p>The <code>rosflight_io</code> node is technically needed only if communication between the companion computer and the FCU is needed. In nearly all cases, however, communication is needed.</p> <p>The <code>rosflight_io</code> node provides telemetry and status updates, even when only flying manually (no companion computer control).</p>"},{"location":"user-guide/rosflight-io/#responsibility","title":"Responsibility","text":"<p>The responsibility of the <code>rosflight_io</code> node is to handle communication between the companion computer and the flight control unit (FCU), which runs the ROSflight firmware. This includes</p> <ul> <li>Sensor information (FCU \u2192 companion computer)</li> <li>Status and log messages (FCU \u2192 companion computer)</li> <li>Actuator or controller commands (companion computer \u2192 FCU)</li> </ul>"},{"location":"user-guide/rosflight-io/#running-rosflight_io","title":"Running <code>rosflight_io</code>","text":"<p>The <code>rosflight_io</code> node is one of the few nodes in the ROSflight ecosystem that \"knows\" if it is simulation or hardware. It needs to know this because it manages the serial connection between the FCU and the companion computer.</p> <p>To run <code>rosflight_io</code> when physically connected via serial to the FCU, run </p><pre><code># Replace /dev/ttyACM0 with the location of the serial device on your machine\nros2 run rosflight_io rosflight_io --ros-args -p port:=/dev/ttyACM0\n</code></pre><p></p> <p>When running in simulation, the <code>rosflight_io</code> bounces the communication against a UDP connection, thus simulating the serial connection between the FCU and companion computer. Thus, to run <code>rosflight_io</code> in simulation run </p><pre><code>ros2 run rosflight_io rosflight_io --ros-args -p udp:=true\n</code></pre><p></p> <p>Note</p> <p>Both the UDP and the serial connection parameters can be configured as described in the Parameters and Configuration section below.</p> <p>Tip</p> <p>The <code>rosflight_io</code> node prints all the logging messages it receives to the terminal where it was launched. It can be very useful to keep an eye on these messages---this is often the first indication of when something goes wrong.</p> <p>When <code>rosflight_io</code> is launched, it</p> <ol> <li>Initializes connection with the FCU (simulated or not)</li> <li>Requests all parameters from the FCU</li> <li>Requests the ROSflight version number from the FCU</li> <li>Starts sending heartbeat messages to the FCU</li> </ol> <p>On a successful connection in simulation, <code>rosflight_io</code> should output something like </p><pre><code>[INFO] [1766001828.320478247] [rosflight_io]: Connecting over UDP to \"localhost:14525\", from \"localhost:14520\"\n[WARN] [1766001828.340941543] [rosflight_io]: RC override active\n[WARN] [1766001828.341085537] [rosflight_io]: Autopilot now in ANGLE mode\n[WARN] [1766001828.346737624] [rosflight_io]: ROSflight version does not match firmware version. Errors or missing features may result\n[WARN] [1766001828.346814941] [rosflight_io]: ROSflight version: 2.0\n[WARN] [1766001828.346847340] [rosflight_io]: Firmware version: undefined\n[INFO] [1766001828.441092908] [rosflight_io]: Got HEARTBEAT, connected.\n[INFO] [1766001828.443783649] [rosflight_io]: Detected time offset of 1766001772.428 s.\n[INFO] [1766001829.353758804] [rosflight_io]: [Autopilot]: Loading saved custom values to primary mixer...\n[INFO] [1766001829.356130174] [rosflight_io]: [Autopilot]: Invalid mixer selected for secondary mixer!\n[INFO] [1766001829.356228048] [rosflight_io]: [Autopilot]: Secondary mixer defaulting to primary!\n[INFO] [1766001829.358746094] [rosflight_io]: [Autopilot]: ARM switch mapped to RC channel 4\n[INFO] [1766001829.358793040] [rosflight_io]: [Autopilot]: ATTITUDE OVERRIDE switch mapped to RC channel 5\n[INFO] [1766001829.361003054] [rosflight_io]: [Autopilot]: THROTTLE OVERRIDE switch mapped to RC channel 5\n[INFO] [1766001829.361065877] [rosflight_io]: [Autopilot]: ATTITUDE TYPE switch mapped to RC channel 6\n[INFO] [1766001831.321671676] [rosflight_io]: Received all parameters\n</code></pre><p></p> <p>Most of these messages are status or logging messages sent from the FCU to <code>rosflight_io</code> for various startup checks inside the firmware.</p> <p>Tip</p> <p>The key message in the above output is the line </p><pre><code>[INFO] [1766001831.321671676] [rosflight_io]: Received all parameters\n</code></pre> This typically means that <code>rosflight_io</code> and the FCU booted up and are communicating correctly.<p></p>"},{"location":"user-guide/rosflight-io/#serial-communication-between-the-fcu-and-the-companion-computer","title":"Serial communication between the FCU and the companion computer","text":"<p>The FCU and <code>rosflight_io</code> need to be able to communicate over the serial connection. This serial communication is currently implemented using MAVlink. Thus, one of the core responsibilities of the <code>rosflight_io</code> node is to convert ROS 2 messages to MAVlink messages and vice versa.</p> <p>Note that other serial communication protocols could be implemented, or even a system such as microROS could be used.</p>"},{"location":"user-guide/rosflight-io/#using-rosflight_ioimplementation-details","title":"Using <code>rosflight_io</code>/implementation details","text":"<p>Users interact with the <code>rosflight_io</code> node using ROS 2 interfaces, namely publishers, subscribers, and services.</p> Subscriber name Message type Description <code>aux_command</code> <code>rosflight_msgs/AuxCommand</code> Auxiliary commands to send to the FCU (aux commands are not routed through the firmware's mixer) <code>command</code> <code>rosflight_msgs/Command</code> Command setpoints from the companion computer to send to the FCU (command setpoints are routed through the firmware's mixer) <code>external_attitude</code> <code>rosflight_msgs/Attitude</code> Attitude estimates derived from some onboard estimator that are used to supplement the FCU's complementary filter Publisher name Message type Description <code>airspeed</code> <code>rosflight_msgs/Airspeed</code> Airspeed sensor data <code>attitude</code> <code>rosflight_msgs/Attitude</code> FCU complementary filter attitude estimate <code>attitude/euler</code> <code>geometry_msgs/Vector3Stamped</code> FCU complementary filter attitude estimate (using Euler angles) <code>baro</code> <code>rosflight_msgs/Barometer</code> Barometer sensor data <code>battery</code> <code>rosflight_msgs/BatteryStatus</code> Battery sensor data <code>gnss</code> <code>rosflight_msgs/GNSS</code> GNSS sensor data <code>imu/data</code> <code>sensor_msgs/Imu</code> IMU sensor data <code>imu/temperature</code> <code>sensor_msgs/Temperature</code> IMU temperature data <code>magnetometer</code> <code>sensor_msgs/MagneticField</code> Magnetometer data <code>output_raw</code> <code>rosflight_msgs/OutputRaw</code> Raw FCU PWM output <code>rc_raw</code> <code>rosflight_msgs/RCRaw</code> Raw RC input received by the FCU <code>sonar</code> <code>sensor_msgs/Range</code> Range sensor data <code>status</code> <code>rosflight_msgs/Status</code> FCU status messages <code>status/params_changed</code> <code>std_msgs/Bool</code> Flag indicating that the FCU's parameters have changed <code>status/rosflight_errors</code> <code>rosflight_msgs/Error</code> Bitfield indicating the FCU's error status <code>status/unsaved_params</code> <code>std_msgs/Bool</code> Flag indicating if the FCU has unsaved parameters <code>version</code> <code>std_msgs/String</code> FCU's firmware version number <p>Note</p> <p>The <code>rosflight_io</code> node creates sensor publishers when the sensor message is first received from the firmware. If you don't see a particular sensor publisher, it means that the firmware is not correctly sending that sensor information over the serial connection.</p>"},{"location":"user-guide/rosflight-io/#service-servers","title":"Service servers","text":"<p>The main way to interact with the FCU (running the ROSflight firmware) is through the service servers advertised by <code>rosflight_io</code>.</p> <p>The <code>rosflight_io</code> node offers the following service servers:</p> Service name Interface type Description <code>all_params_received</code> <code>std_srvs/Trigger</code> Returns true if all parameters have been received by <code>rosflight_io</code> <code>calibrate_airspeed</code> <code>std_srvs/Trigger</code> Instructs the firmware to calibrate the airspeed sensor <code>calibrate_baro</code> <code>std_srvs/Trigger</code> Instructs the firmware to calibrate the barometer <code>calibrate_imu</code> <code>std_srvs/Trigger</code> Instructs the firmware to calibrate the IMU <code>calibrate_mag</code> <code>std_srvs/Trigger</code> Instructs the firmware to calibrate the magnetometer <code>calibrate_rc_trim</code> <code>std_srvs/Trigger</code> Instructs the firmware to calibrate the RC trim values <code>param_get</code> <code>rosflight_msgs/ParamGet</code> Gets a parameter from the firmware <code>param_load_from_file</code> <code>rosflight_msgs/ParamFile</code> Sequentially loads each parameter in a parameter file to the firmware <code>param_save_to_file</code> <code>rosflight_msgs/ParamFile</code> Saves the current firmware parameters to a file <code>param_set</code> <code>rosflight_msgs/ParamSet</code> Sets an individual parameter in the firmware <code>param_write</code> <code>std_srvs/Trigger</code> Instructs the firmware to write all parameters to memory <code>reboot</code> <code>std_srvs/Trigger</code> Instructs the firmware to reboot <code>reboot_to_bootloader</code> <code>std_srvs/Trigger</code> Instructs the firmware to reboot to bootloader Example - Calibrating the IMU <p>To calibrate the IMU, run </p><pre><code>ros2 service call /calibrate_imu std_srvs/srv/Trigger\n</code></pre><p></p> <p>And after a bit you should see output like </p><pre><code>[INFO] [1766004526.090247047] [rosflight_io]: Parameter GYRO_X_BIAS has new value 0\n[WARN] [1766004526.090315867] [rosflight_io]: There are unsaved changes to onboard parameters\n[INFO] [1766004526.090336231] [rosflight_io]: Parameter GYRO_Y_BIAS has new value 0\n[INFO] [1766004526.090360339] [rosflight_io]: Parameter GYRO_Z_BIAS has new value 0\n[INFO] [1766004526.090381384] [rosflight_io]: Parameter ACC_X_BIAS has new value 0\n[INFO] [1766004526.090402445] [rosflight_io]: Parameter ACC_Y_BIAS has new value 0\n[INFO] [1766004526.090431170] [rosflight_io]: Parameter ACC_Z_BIAS has new value 0\n[INFO] [1766004528.592684699] [rosflight_io]: Parameter ACC_X_BIAS has new value -0.0493735\n[WARN] [1766004528.592814409] [rosflight_io]: There are unsaved changes to onboard parameters\n[INFO] [1766004528.592847257] [rosflight_io]: Parameter ACC_Y_BIAS has new value 0.214831\n[INFO] [1766004528.592960904] [rosflight_io]: Parameter ACC_Z_BIAS has new value 0.0190079\n[INFO] [1766004528.592987462] [rosflight_io]: [Autopilot]: IMU offsets captured\n[INFO] [1766004528.593018820] [rosflight_io]: Parameter GYRO_X_BIAS has new value -0.181556\n[INFO] [1766004528.593048466] [rosflight_io]: Parameter GYRO_Y_BIAS has new value -0.142443\n[INFO] [1766004528.593073161] [rosflight_io]: Parameter GYRO_Z_BIAS has new value 0.218234\n</code></pre><p></p>"},{"location":"user-guide/rosflight-io/#parameters-and-configuration","title":"Parameters and configuration","text":"<p>The <code>rosflight_io</code> node has the following parameters associated with it</p> Parameter name Parameter type Description <code>udp</code> <code>bool</code> Whether or not to use a UDP connection instead of the serial device <code>bind_host</code> <code>string</code> IP address of the host computer (the one running <code>rosflight_io</code>) <code>bind_port</code> <code>int</code> Port on the host computer (the one running <code>rosflight_io</code>) to use <code>remote_host</code> <code>string</code> IP address of the remote computer (the one running the simulated board) <code>remote_port</code> <code>int</code> Port on the remote computer (the one running the simulated board) to use <code>port</code> <code>string</code> Location of the serial device (e.g. <code>/dev/ttyACM0</code>) <code>baud_rate</code> <code>int</code> Baud rate for the serial connection <code>frame_id</code> <code>string</code> Frame ID for sensor messages (like IMU/magnetometer, etc.) <p>Note that if <code>udp=true</code>, then <code>rosflight_io</code> will default to a UDP connection and will not connect to a serial device located at the value of the <code>port</code> parameter.</p>"},{"location":"user-guide/rosflight-io/#convenience-parameters","title":"Convenience parameters","text":"<p>Changing the FCU's parameters via the <code>param_get</code> and <code>param_set</code> service calls is slow, and can be annoying if you are trying to tune firmware parameters rapidly. To help with this, <code>rosflight_io</code> exposes some parameters to the ROS 2 parameter system and manages setting and syncing the values of those parameters with the firmware's values.</p> <p>By default, only the firmware controller's PID gains are exposed, but others could be exposed as well. See the <code>rosflight_io</code> code for details.</p> <p>These parameters can be set using the ROS 2 parameter tools via the command line using  </p><pre><code>ros2 param set /rosflight_io &lt;PARAM_NAME&gt;\n</code></pre> or by using RQT's dynamics reconfigure plugin with <pre><code>rqt --standalone rqt_reconfigure\n</code></pre><p></p>"},{"location":"user-guide/concepts/autonomous-flight/","title":"Autonomous Flight","text":""},{"location":"user-guide/concepts/autonomous-flight/#autonomous-flight","title":"Autonomous Flight","text":"<p>To perform autonomous flight with ROSflight, we need to send control commands from our companion computer to the firmware. This can be done with ROSplane or ROScopter, which already have completed autonomy stacks developed specifically for ROSflight. We recommend starting with one of these autonomy stacks and building on them to suit your needs. If using a multirotor, follow the ROScopter setup guide to get started. If using a fixed-wing, follow the ROSplane setup guide.</p> <p>However, ROSplane and ROScopter are optional and an entirely different autonomy stack can be used if desired. To use a different autonomy stack, follow this guide.</p>"},{"location":"user-guide/concepts/autonomous-flight/#provide-control-from-a-companion-computer","title":"Provide Control from a Companion Computer","text":"<p>Control setpoints are sent to the flight controller by publishing to the <code>/command</code> topic that is advertised by the <code>rosflight_io</code> node. This topic accepts messages of type <code>rosflight_msgs/Command</code>, which have the following structure:</p> <pre><code>\u279c  ~ ros2 interface show rosflight_msgs/msg/Command\n# Offboard control command message\n\n# control mode flags\nuint8 MODE_PASS_THROUGH = 0\nuint8 MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE = 1\nuint8 MODE_ROLL_PITCH_YAWRATE_THROTTLE = 2\n\n# ignore field bitmasks\nuint8 IGNORE_NONE = 0\nuint8 IGNORE_QX = 1\nuint8 IGNORE_QY = 2\nuint8 IGNORE_QZ = 4\nuint8 IGNORE_FX = 8\nuint8 IGNORE_FY = 16\nuint8 IGNORE_FZ = 32\n\nstd_msgs/Header header\n    builtin_interfaces/Time stamp\n        int32 sec\n        uint32 nanosec\n    string frame_id\nuint8 mode # offboard control mode for interpreting value fields\nuint8 ignore # bitmask for ignore specific setpoint values\nfloat32 qx\nfloat32 qy\nfloat32 qz\nfloat32 fx\nfloat32 fy\nfloat32 fz\n</code></pre> <p>The <code>header</code> field is a standard ROS2 message header. The <code>q*</code>, and <code>f*</code> fields are the control setpoint values, which are interpreted according to the <code>mode</code> and <code>ignore</code> fields.</p> <p>The following table describes the different values the <code>mode</code> field can take, as well as how the setpoint values are interpreted for each of these modes:</p> Value Enum Description 0 <code>MODE_PASS_THROUGH</code> Passthrough directly to mixer. Units interpreted according to mixer 1 <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> Passed to firmware rate controller. <code>q*</code> is in units of rad/s 2 <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> Passed to firmware angle controller. <code>q*</code> is in units of rad <p>The <code>MODE_PASS_THROUGH</code> mode is most often used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> and <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> modes are used for multirotor vehicles to specify the attitude rates or angles, respectively.</p> <p>The <code>ignore</code> field is used if you want to specify control setpoints for some, but not all, of the axes. The <code>ignore</code> field is a bitmask that can be populated by combining the values in the <code>IGNORE_*</code> enum in the message definition.</p> <p>Example</p> <p>For example, I may want to specify throttle setpoints to perform altitude hold, while still letting the RC pilot specify the attitude setpoints. To do this, I would set the <code>ignore</code> field to a value of </p><pre><code>ignore = IGNORE_QX | IGNORE_QY | IGNORE_FZ\n</code></pre><p></p> <p>The best practice is to use enum names rather than the actual numeric values for the <code>mode</code> and <code>ignore</code> fields. For example, to specify a multirotor attitude angle command in C++ I might have: </p><pre><code>#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;rosflight_msgs/msg/command.hpp&gt;\n\nrosflight_msgs::msg::Command msg;\nmsg.header.stamp = node-&gt;get_clock()-&gt;now();\nmsg.mode = rosflight_msgs::msg::Command::MODE_ROLL_PITCH_YAWRATE_THROTTLE;\nmsg.ignore = rosflight_msgs::msg::Command::IGNORE_NONE;\nmsg.qx = 0.0;\nmsg.qy = 0.0;\nmsg.qz = 0.0;\nmsg.fz = 0.6;\n</code></pre><p></p> <p>In Python I might have: </p><pre><code>import rclpy\nfrom rosflight_msgs.msg import Command\n\nmsg = Command()\nmsg.header.stamp = node.get_clock().now().to_msg()\nmsg.mode = Command.MODE_ROLL_PITCH_YAWRATE_THROTTLE\nmsg.ignore = Command.IGNORE_NONE\nmsg.qx = 0.0\nmsg.qy = 0.0\nmsg.qz = 0.0\nmsg.fz = 0.6\n</code></pre> I would then publish this message to the <code>/command</code> topic to forward it to the embedded flight controller.<p></p> <p>Note</p> <p>If the flight controller does not receive a new command for a defined period of time, it will ignore the old commands and revert to RC control. The length of this timeout period is set by the <code>OFFBOARD_TIMEOUT</code> parameter.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/","title":"Detailed Launching Guide","text":""},{"location":"user-guide/concepts/detailed-launching-guide/#detailed-launching-guide","title":"Detailed Launching Guide","text":"<p>Detailed launching instructions for the <code>rosflight_sim</code> module. For a quick tutorial on running the <code>standalone_sim</code>, see the simulator tutorials.</p> <p>Launch parameters</p> <p>This document describes a lot of the launch-time arguments that can be passed to the launch files to configure the simulation. To see a complete list of the launch-time arguments, run a launch command with </p><pre><code>ros2 launch &lt;package_name&gt; &lt;launch_file_name&gt; --show-args\n</code></pre><p></p>"},{"location":"user-guide/concepts/detailed-launching-guide/#a-note-on-sims-and-viz","title":"A note on sims and viz","text":"<p>A simulator includes many different modules, such as dynamic propagation, sensor creation, forces and moments computation, etc. One of these modules is the visualization module, that provides the graphical element to the simulator. Different visualizers provide different functionality and require different information. For example, Gazebo Classic handles the dynamic propagation (integration) for users, while a simple visualizer like RViz does not.</p> <p>Since each visualizer in large part determines what other functionality the simulator modules need to provide, they are tightly coupled. Thus, in this guide, we will refer interchangeably between simulator and visualizer.</p> <p>The <code>rosflight_sim</code> architecture has been designed to be as modular as possible in order to adapt as easily as possible to the different needs of various visualizers. See the simulation architecture page for more information.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#sims-that-ship-with-rosflight_sim","title":"Sims that ship with <code>rosflight_sim</code>","text":"<p>The ROSflight simulation module was designed to be as modular as possible, in order to support different simulation and visualization needs. Currently, we support 2 visualizers out-of-the-box:</p> <ul> <li>A \"standalone\" visualizer using ROS2 RViz tool (recommended)</li> <li>Gazebo Classic</li> </ul> <p>Adding your own visualizer is part of what <code>rosflight_sim</code> was designed for. See the instructions on adding your own visualizer page for more information on plugging in your simulator into <code>rosflight_sim</code>.</p> <p>This following sections detail how to launch and debug these two simulators.</p> <p>New to ROSflight?</p> <p>If you are new to ROSflight, we recommend that you first start by setting up the simulation environment and learning to use the ROSflight ecosystem. Do this by following the installation for sim guides, and then the ROSflight tutorials.</p> <p>This guide assumes you have already followed these tutorials.</p> <p>Note</p> <p>To simulate a fixed-wing mav, just change all instances of <code>multirotor</code> in the steps below to <code>fixedwing</code>.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#standalone-sim","title":"Standalone Sim","text":"<p>The \"standalone\" sim is a simulator that uses ROS2 RViz to visualize aircraft motion.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#launching-instructions","title":"Launching instructions","text":"<ul> <li> <p>Set up rosflight with the software installation for sim guide guide, making sure to install the <code>-desktop</code> package of ROS2, not the <code>-ros-base</code>.</p> </li> <li> <p>The standalone sim for ROSflight SIL is usually launched using this launch file: </p><pre><code>ros2 launch rosflight_sim multirotor_standalone.launch.py\n</code></pre><p></p> </li> <li> <p>The standalone sim should now be running! RViz should open with the STL of the multirotor, and you should have the following <code>rqt_graph</code>.</p> </li> </ul> RQT graph of the nodes involved in the standalone simulator. Click on the figure to enlarge. <p>Tip</p> <p>Run <code>rqt_graph</code> with <code>rqt_graph</code> the in a new terminal, assuming the <code>-desktop</code> version of ROS2 was installed.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#explanation","title":"Explanation","text":"<p>The launch file manages launching several nodes all at once, as shown in the <code>rqt_graph</code> image:</p> <ul> <li><code>/rosflight_io</code>: Handles the communication between the companion computer and the flight controller</li> <li><code>/standalone_sensors</code>: Simulates sensor measurements given the true state of the robot</li> <li><code>/rc</code>: Simulates the RC safety pilot connection to the firmware</li> <li><code>/sil_board</code>: Instantiation of the firmware</li> <li><code>/standalone_dynamics</code>: Dynamics node for keeping track of the true robot state</li> <li><code>/multirotor_forces_and_moments</code>: Computes aerodynamic forces and moments based on motor commands</li> <li><code>/standalone_time_manager</code>: Only appears if <code>use_sim_time</code> is set true. See the launch arguments</li> <li><code>/rviz</code>: Visualizer</li> <li><code>/standalone_viz_transcriber</code>: Manages publishing <code>rosflight_sim</code> information to RViz</li> <li>3 transform listener nodes: Manage coordinate frame transformations to RViz</li> </ul> <p>For more information on each of these nodes, see the simulator architecture page.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#running-nodes-individually","title":"Running nodes individually","text":"<p>If you don't want to use the launch file, you can instead run all of the nodes individually in separate terminals with the appropriate parameters. For example, to run just the <code>/multirotor_forces_and_moments</code> node, you would run </p><pre><code>ros2 run rosflight_sim multirotor_forces_and_moments --ros-args --params-file ~/rosflight_ws/src/rosflight_ros_pkgs/rosflight_sim/params/multirotor_dynamics.yaml\n</code></pre> Check the launch files for more information on what parameters and param files get loaded by the launch file.<p></p> <p>Also note that the <code>multirotor_standalone.launch.py</code> file actually calls 2 other launch files--one specific to the standalone sim (<code>standalone_sim.launch.py</code>) and one that launches the nodes shared by both the fixedwing and multirotor simulators (<code>common_nodes_standalone.launch.py</code>). You can also launch those files separately if you want--just make sure to also run the forces and moments node in addition to those two sub-launch files.</p> <p>Warning</p> <p>If you do run all nodes separately, make sure all the needed nodes are running. You can verify this by checking that the <code>rqt_graph</code> is the same as the above image.</p> <p>This is important since the nodes are chained together to complete a simulation loop. A common source of error is forgetting to launch a node in the chain. Forgetting to run the <code>multirotor_forces_and_moments</code> node, for example, will cause the <code>standalone_dynamics</code> node to not perform any updates.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#gazebo-classic","title":"Gazebo Classic","text":"<p>Danger</p> <p>Gazebo Classic is officially EOL as of January 2025, and does not work with ROS2 Jazzy. If you are using ROS2 Jazzy, please only use the standalond sim. The following instructions assume you are using ROS2 Humble.</p> <p>We have not yet upgraded to Gazebo, which is not EOL and better. If you would like to help in this effort, please visit the GitHub issue and let us know :)</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#launching-instructions_1","title":"Launching Instructions","text":"<p>Todo</p> <p>Change the ROS2 setup instructions include details about Gazebo and skipping if you don't want it.</p> <ul> <li>Set up ROSflight by following the installation for sim guide</li> <li>Source the Gazebo Classic setup file if you haven't added it to <code>~/.bashrc</code>: <pre><code>source /usr/share/gazebo/setup.sh\n</code></pre></li> <li> <p>Launch Gazebo Classic with the ROSflight SIL: </p><pre><code>ros2 launch rosflight_sim multirotor_gazebo.launch.py aircraft:=multirotor\n</code></pre><p></p> </li> <li> <p>Gazebo Classic should now be running! Gazebo should open and you should see the STL of the multirotor at the origin. You should have the following <code>rqt_graph</code>. </p> </li> </ul> <p>Tip</p> <p>Run <code>rqt_graph</code> with the command <code>rqt_graph</code> in a new terminal, assuming the <code>-desktop</code> version of ROS2 was installed.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#explanation_1","title":"Explanation","text":"<p>The launch file manages launching several nodes all at once, as shown in the <code>rqt_graph</code> image:</p> <ul> <li><code>/rosflight_io</code>: Handles the communication between the companion computer and the flight controller</li> <li><code>/standalone_sensors</code>: Simulates sensor measurements given the true state of the robot</li> <li><code>/rc</code>: Simulates the RC safety pilot connection to the firmware</li> <li><code>/sil_board</code>: Instantiation of the firmware</li> <li><code>/gazebo</code>: Visualizer</li> <li><code>/multirotor/dynamics</code>: Dynamics plugin to Gazebo Classic, computes the aerodynamic forces and moments given motor commands</li> <li><code>/dynamics</code>: Interface node between the dynamics plugin and the rest of the <code>rosflight_sim</code> modules</li> </ul> <p>For more information on each of these nodes, see the simulator architecture page.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#running-nodes-individually_1","title":"Running nodes individually","text":"<p>The same file structure was used for the Gazebo launch files as for the standalone launch files. If you want to run nodes individually, see the explanation above.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#launch-arguments","title":"Launch arguments","text":"<p>Tip</p> <p>Command line arguments to launch files can be previewed by appending <code>--show-args</code> to the launch call: </p><pre><code>ros2 launch rosflight_sim multirotor_gazebo.launch.py --show-args\n</code></pre><p></p> <p>There are several command line arguments you can pass to customize the behavior at runtime. Here are some important ones:</p> <ul> <li><code>aircraft</code>: Defaults to \"skyhunter\". This parameter controls which dynamics and parameter files get loaded, in addition to the STL file for visualization. Make sure this is set to your correct airframe!</li> <li><code>use_sim_time</code>: By default, set false. This parameter is a parameter of all nodes in ROS2. If set to true on launch, the node will create a subscription to the <code>/clock</code> topic, and will use that as the source of time for its timers. For Gazebo Classic, it is recommended to leave this as false, since Gazebo Classic publishes a <code>/clock</code> topic at 10Hz, which is too slow for most modules. If using the standalone sim, this parameter will allow you to speed up, slow down, or pause time. See the simulation architecture page for more information.</li> <li><code>use_vimfly</code>: Node that changes the default RC behavior to use VimFly, a program that lets you use Vim commands to fly around in the sim! Vim, of course, is recommended for everyone, but VimFly especially if you don't have access to RC transmitter connected over USB. See the joystick section for more information on what joysticks are supported.</li> </ul> <p>These command line arguments should be passed using the <code>&lt;argument&gt;:=&lt;value&gt;</code> syntax.</p>"},{"location":"user-guide/concepts/detailed-launching-guide/#joysticks","title":"Joysticks","text":"<p>ROSflight supports several types of transmitters or controllers that you can use to fly around in the sim as the RC safety pilot. If one of the supported transmitters is connected via USB at launch time, then the sim will default to using that controller instead of the default, which is no RC connection. See the Hardware Setup guide for more information on joysticks.</p> <p>Note</p> <p>It is much easier to fly with a real transmitter than with an Xbox-type controller. FrSky Taranis QX7 transmitters, Radiomaster TX16s transmitters, and RealFlight controllers are also supported. Non-Xbox joysticks may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping!</p> <p>If you want to fly around in the sim and you don't have access to a transmitter, we recommend using VimFly, which allows you to fly around in the sim with your keyboard. To use VimFly, just add the <code>use_vimfly:=true</code> string to the end of the launch command.</p> <p>Example</p> <p>To launch the multirotor sim using the standalone simulator with VimFly, run </p><pre><code>ros2 launch rosflight_sim multirotor_standalone.launch.py use_vimfly:=true\n</code></pre><p></p>"},{"location":"user-guide/concepts/detailed-launching-guide/#after-launching","title":"After launching","text":"<p>Remember that the SIL tries its best to replicate hardware. That means you have to calibrate and set parameters in the same way you do in hardware. If you need a reminder, please follow the configuration and manual flight tutorial.</p> <p>See the Parameter Configuration pages in this documentation for instructions on how to perform all preflight configuration before the aircraft will arm.</p> <p>You can also run  </p><pre><code>ros2 launch rosflight_sim multirotor_init_firmware.launch.py\n</code></pre> to load all required parameters and perform initial calibrations for a quick simulation setup.<p></p> <p>Warning</p> <p>Remember to verify that all parameters are set to the value that you would expect. Wrong parameters is a common source of error in sim and in hardware.</p>"},{"location":"user-guide/concepts/flight-controller-setup/","title":"Flight Controller Setup","text":""},{"location":"user-guide/concepts/flight-controller-setup/#flight-controller-setup","title":"Flight Controller Setup","text":"<p>Note</p> <p>This page contains instructions for flashing pre-built firmware binaries. For instructions on building and flashing from source, see Building and Flashing in the Developer Guide.</p>"},{"location":"user-guide/concepts/flight-controller-setup/#compatible-hardware","title":"Compatible Hardware","text":"<p>Currently, the ROSflight firmware supports:</p> <ol> <li>An in-development board from AeroVironment, the Varmint. This board has an integrated Jetson Orin, but is not yet commercially available.</li> <li>MRO's Pixracer Pro, which has the same H7 processor.</li> </ol> <p>Supporting your own board</p> <p>It is possible to write your own board support package (BSP). If you do create your own support package for the ROSflight firmware, please contribute back!</p>"},{"location":"user-guide/concepts/flight-controller-setup/#serial-port-configuration","title":"Serial Port Configuration","text":"<p>Tip</p> <p>You can see which groups you are a member of by running <code>groups $USER</code> on the command line.</p> <p>The following bullet point is necessary:</p> <ul> <li>Be sure your user is in the <code>dialout</code> and <code>plugdev</code> groups so you have access to the serial ports. You will need to log out and back in for these changes to take effect. <pre><code>sudo usermod -aG dialout,plugdev $USER\n</code></pre></li> </ul> <p>If you experience issues, you may need one or both of the next two bullet points:</p> <ul> <li> <p>Temporarily stop the modem-manager (Sometimes, Linux thinks the device is a modem -- this command will be effective until next boot, or until you run the command again with <code>start</code> in place of <code>stop</code>) </p><pre><code>sudo systemctl stop ModemManager.service\n</code></pre><p></p> </li> <li> <p>Add the custom udev rule so Linux handles the flight controller properly (copy the following as <code>/etc/udev/rules.d/45-stm32dfu.rules</code>) </p><pre><code># DFU (Internal bootloader for STM32 MCUs)\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"df11\", MODE=\"0664\", GROUP=\"plugdev\"\n</code></pre><p></p> </li> </ul> <p>Tip</p> <p>You can permanently disable the ModemManager if you do not need it, then you won't have to disable it every time you reboot: </p><pre><code>sudo systemctl disable ModemManager.service\n</code></pre> Replace <code>disable</code> with <code>enable</code> to revert (i.e. if you find some other program you use needs access to it). Or you can uninstall it entirely from your system: <pre><code>sudo apt purge modemmanager\n</code></pre><p></p>"},{"location":"user-guide/concepts/flight-controller-setup/#building-and-flashing-the-firmware","title":"Building and Flashing the Firmware","text":"<p>Follow the building and flashing firmware guide to build the ROSflight firmware and flash it to your flight controller.</p>"},{"location":"user-guide/concepts/flight-controller-setup/#leds","title":"LEDs","text":"<p>The meaning of the various LEDs is summarized in the following table. The colors of the LEDs may change depending on your specific board:</p> LED On Off Slow Blink Fast Blink Power (Blue) Board powered - - - Info (Green) RC control Offboard control - - Warning (Red) Armed Disarmed Error (disarmed) Failsafe (armed)"},{"location":"user-guide/concepts/getting-started/","title":"Getting Started","text":""},{"location":"user-guide/concepts/getting-started/#getting-started","title":"Getting Started","text":"<p>Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages:</p> <ol> <li>Hardware setup: Set up your hardware (fixed-wing or multirotor platform, flight controller, and companion computer)</li> <li>Flight controller setup: Flash your flight controller with the latest ROSflight firmware.</li> <li>RC Configuration: Set up your RC transmitter.</li> <li>ROS2 setup: Set up ROS2 on your companion computer.</li> <li>Parameter configuration: Configure the flight controller for your setup. The configuration checklists below should help guide you through this process.</li> <li>Preflight checks: Run through your preflight checks</li> <li>Improving firmware performance (multirotors only): Tune the firmware attitude controller gains</li> <li>Autonomous flight (optional): Set up autonomous flight via offboard control</li> </ol>"},{"location":"user-guide/concepts/getting-started/#configuration-checklist","title":"Configuration Checklist","text":"<p>The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your hardware is already set up correctly.</p>"},{"location":"user-guide/concepts/getting-started/#general-setup","title":"General Setup","text":"<ol> <li>Set the <code>FIXED_WING</code> parameter (<code>1</code> if a fixed-wing, <code>0</code> if a multirotor)</li> <li>Set the <code>RC_TYPE</code> parameter (<code>0</code> if PPM, <code>1</code> if SBUS)</li> <li>Set the <code>PRIMARY_MIXER</code> parameter to the appropriate value described in the Hardware Setup page</li> <li>Set the <code>MOTOR_PWM_UPDATE</code> parameter (typically <code>490</code> for SimonK ESCs, <code>50</code> for standard servos)</li> <li>Make sure your RC transmitter is set up correctly</li> <li>Set up your RC switches<ul> <li>If you want to arm/disarm using a switch, set the <code>ARM_CHANNEL</code> parameter to the appropriate channel (0-indexed)</li> <li>If you want to use a switch to enable RC override, set the <code>RC_ATT_OVRD_CHN</code> and <code>RC_THR_OVRD_CHN</code> parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel.</li> </ul> </li> <li>Calibrate your IMU: start <code>rosflight_io</code>, then run <code>ros2 service call /calibrate_imu std_srvs/srv/Trigger</code></li> <li>Complete the multirotor-specific or fixed-wing-specific checklist below</li> <li>Save the parameters (<code>ros2 service call /param_write std_srvs/srv/Trigger</code>)</li> <li>You'll probably want to save a backup of your parameters (call <code>ros2 service call /param_save_to_file rosflight_msgs/srv/ParamFile \"{filename: \"params.yml\"}\"</code>)</li> <li>Make sure you run through the Preflight Checklist before flying</li> </ol>"},{"location":"user-guide/concepts/getting-started/#multirotor-specific-setup","title":"Multirotor-specific Setup","text":"<p>Danger</p> <p>IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!!</p> <ol> <li> <p>Calibrate ESCs</p> <ol> <li>Make sure <code>MOTOR_MIN_PWM</code> and <code>MOTOR_MAX_PWM</code> are correct (usually <code>1000</code> and <code>2000</code>)</li> <li>Set <code>PRIMARY_MIXER</code> param to <code>0</code> (ESC calibration mixer)</li> <li>Set <code>ARM_SPIN_MOTORS</code> to <code>0</code></li> <li> <p>Perform ESC calibration. For standard ESCs:</p> <ol> <li>With power disconnected from the motors, arm the flight controller</li> <li>Set throttle to maximum</li> <li>Connect power to the motors</li> <li>Drop the throttle to minimum</li> </ol> </li> <li> <p>Set the <code>PRIMARY_MIXER</code> parameter back to the appropriate value for your vehicle (see the Hardware Setup page)</p> </li> <li>Set <code>ARM_SPIN_MOTORS</code> back to <code>1</code></li> </ol> </li> <li> <p>The <code>ARM_SPIN_MOTORS</code> parameter should be set to <code>1</code> so the motors spin slowly when armed. The idle throttle setting can be adjusted with the <code>MOTOR_IDLE_THR</code> parameter.</p> </li> <li>You'll most likely want to set the <code>CAL_GYRO_ARM</code> param to <code>1</code> to enable calibrating gyros before arming</li> <li>Set the <code>RC_ATT_MODE</code> parameter to set RC control mode (<code>0</code> for rate mode, <code>1</code> for angle mode [default])</li> <li>Set torque offsets as described in the RC trim calculation section of the Improving Firmware Performance page</li> <li>Set the <code>FAILSAFE_THR</code> parameter to specify the throttle level the MAV will hold if the transmitter disconnects. Set the parameter to <code>0</code> if you just want the MAV to drop, otherwise determine the amount of throttle required to hover the MAV and set the parameter comfortably below that. DO NOT set it above, as this will result in a runaway MAV. We recommended that you test the throttle level in an enclosed space by powering off the transmitter while hovering, if you set this parameter above 0.</li> <li>Tune the controller gains as described in the Multirotor gain tuning section of the Improving Firmware Performance page</li> </ol>"},{"location":"user-guide/concepts/getting-started/#fixed-wing-specific-setup","title":"Fixed-Wing-Specific Setup","text":"<ol> <li>Reverse servo directions if necessary using the <code>AIL_REV</code>, <code>ELEVATOR_REV</code>, and <code>RUDDER_REV</code> parameters (<code>1</code> to reverse, <code>0</code> to keep current direction)</li> <li>You'll most likely want to set the <code>ARM_SPIN_MOTORS</code> parameter to <code>0</code> so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching</li> </ol>"},{"location":"user-guide/concepts/hardware-setup/","title":"Hardware Setup","text":""},{"location":"user-guide/concepts/hardware-setup/#hardware-setup","title":"Hardware Setup","text":""},{"location":"user-guide/concepts/hardware-setup/#parts-list","title":"Parts List","text":"<p>To use ROSflight to its full potential, you will need the following system components. Some components are mounted on your MAV (Miniature Aerial Vehicle), while others are on the ground. ROSflight supports both multirotor and fixed-wing vehicle types.</p> <p>Mounted on the MAV</p> <ol> <li>Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s)</li> <li>Flight Controller (FC)</li> <li>Vibration Isolation for FC</li> <li>Any external sensors</li> <li>R/C Receiver</li> <li>Companion Computer</li> <li>Wi-Fi Antenna, or access of some kind to ground-station, wireless network (e.g. Ubiquiti Bullet)</li> </ol> <p>Ground Station</p> <ol> <li>Ground-Station, Wireless Network (e.g. Wi-Fi Router, Ubiquiti Rocket)</li> <li>R/C transmitter</li> <li>Laptop or base station computer</li> <li>Joystick (Xbox controller)</li> </ol>"},{"location":"user-guide/concepts/hardware-setup/#frame-motors-escs-battery-and-propeller","title":"Frame, Motors, ESCs, Battery, and Propeller","text":"<p>We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination. There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts.</p> <p>If you are designing your own multirotor or airplane, you may want to look at ecalc, an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV.</p> <p>Some things to keep in mind as you design or build your MAV.</p> <ul> <li>Most kits do not include space for a companion computer, cameras, laser scanners or other sensors. Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV.</li> <li>You will likely also need to customize the power circuitry of your MAV to provide power to your companion computer at some specific voltage. Many people like to separate the power electronics (the ESCs and motors), from the computer and companion sensors. This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand. We will talk about this more when we talk about wiring up your MAV.</li> <li>Cheap propellers can cause a huge amount of vibration. Consider buying high-quality propellers, doing a propeller balance, or both. RCGroups, DIY Drones and YouTube have some awesome guides on how to do propeller balancing.</li> <li>ESCs will need to be calibrated from 2000 to 1000 us</li> </ul>"},{"location":"user-guide/concepts/hardware-setup/#flight-controller","title":"Flight Controller","text":"<p>The flight controller is the embedded microcontroller that runs <code>rosflight_firmware</code>. See the list of compatible hardware for more information.</p> <p>The flight controller includes an IMU and a barometer, as well as some additional sensors depending on the board.</p>"},{"location":"user-guide/concepts/hardware-setup/#external-sensors","title":"External Sensors","text":"<p>Additional Sensors you may want for your ROSflight setup include:</p> <ul> <li>Sonar</li> <li>GPS</li> <li>Digital Airspeed Sensor (Pitot Tube)</li> </ul>"},{"location":"user-guide/concepts/hardware-setup/#vibration-isolation","title":"Vibration Isolation","text":"<p>It is really important to isolate your flight controller from vehicle vibrations, such as those caused by propellers and motors. We recommend using small amounts of Kyosho Zeal to mount a fiberglass plate holding the FC to the MAV. You may also want to try adding mass to the flight control board. We have accomplished this by gluing steel washers to the fiberglass mounting plate.</p> <p></p> <p>You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the FC mounting plate. The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.</p>"},{"location":"user-guide/concepts/hardware-setup/#companion-computer","title":"Companion Computer","text":"<p>The only requirement for the companion computer is that it runs Linux (usually an Ubuntu LTS version, but using Docker on other distributions is also an option), ROS2, has at least one USB port, and can be carried by the aircraft. We have had success with the following companion computers, but by no means is this a comprehensive list; it is more by way of suggestion.</p> <ul> <li>NVIDIA Jetson</li> <li>MSI CUBI</li> <li>Intel NUC</li> <li>Rasberry Pi 3</li> </ul>"},{"location":"user-guide/concepts/hardware-setup/#wi-fi","title":"Wi-Fi","text":"<p>You will need Wi-Fi to communicate with your MAV when it is in the air. Because ROS2 communicates over UDP, it is very easy to use ROS2 to view what is going on in your MAV while it is flying by sending commands and reading sensor data. For most applications, a standard Wi-Fi router and dongle will suffice. For long-range applications, you may want to look into Ubiquiti point-to-point Wi-Fi. (We have seen ranges over a mile with these networks.)</p>"},{"location":"user-guide/concepts/hardware-setup/#rc-transmitter-and-receiver","title":"RC Transmitter and Receiver","text":"<p>For RC Control, you will need a transmitter with between 6 and 8 channels. Any additional channels will be wasted. We require RC control for safe operation, and only support arming and disarming via RC control.</p> <p>ROSflight only supports PPM (pulse position modulation) and SBUS receivers. Individual channel PWM outputs are not supported. Any configurations with PPM or SBUS and 6-8 channels will be sufficient.</p>"},{"location":"user-guide/concepts/hardware-setup/#laptop-or-base-station-computer","title":"Laptop or Base Station Computer","text":"<p>You will need a laptop which can run ROS2 to communicate with the MAV over the ground station wireless network. To do this natively you'll want a recent Ubuntu LTS version, but this can also be done with Docker containers from pretty much any Linux distribution. Linux within a virtual machine can also work, but is not recommended. </p>"},{"location":"user-guide/concepts/hardware-setup/#joystick","title":"Joystick","text":"<p>A joystick is used for software-in-the-loop (SIL) simulations. The joystick is not technically a required component because it is possible to control your MAV from the command line, but it makes things much easier. Our first recommendation is to use the same transmitter you use for hardware as a joystick by plugging it into the computer via USB. We support Taranis QX7 transmitters, Radiomaster TX16s transmitters, RealFlight controllers, and XBOX controllers. Other joysticks can be used, but you may need to create custom axis and button mappings within the ROSflight joystick utility.</p> <p>Physical vs firmware channels</p> <p>If you do write your own mapping, remember that the channel numbers need to be configured properly on both the firmware and the transmitter. This means that if the RC transmitter outputs \"throttle\" on channel 3 on the (1 indexed on the transmitter), then the firmware needs to set <code>RC_F_CHN</code> to 2 (0 indexed).</p>"},{"location":"user-guide/concepts/hardware-setup/#battery-monitor","title":"Battery Monitor","text":"<p>A battery monitor is an analog sensor that provides battery voltage and/or battery current information. This data can be used to prevent power loss in air or to measure system load. The sensor outputs an analog voltage proportional to the battery voltage and/or current through the battery. Most flight controllers come equipped with a built-in battery monitor, but if not, small PCB sensors are also available that can be connected to the flight controller.</p> <p>For ROSflight to use a battery monitor, an appropriate multiplier must be set. ROSflight multiplies the analog signal from the monitor by the multiplier to get the final reading. The monitor datasheet should contain the information needed to get the multiplier. For example, the datasheet for the AttoPilot 50V/90A sensor states that it outputs 63.69 mV / V. To get the original battery voltage, the multiplier must be 1/.06369, or 15.7. The multipliers for the voltage and current are set separately, with the <code>BATT_VOLT_MULT</code> and <code>BATT_CURR_MULT</code> parameters, respectively.</p> <p>ROSflight applies a simple low-pass filter to remove noise from the voltage and current measurements. These filters are configurable via the <code>BATT_VOLT_ALPHA</code> and <code>BATT_CURR_ALPHA</code> parameters. The alpha value for a given cutoff frequency \\(a\\), can be calulated with: \\( \\alpha =  e ^ {-.01a} \\). As battery voltages do not typically change quickly, the default of 0.995 usually suffices.</p> <p>More information on battery monitor hardware, including determining appropriate multipliers and creating a simple DIY monitor, can be found on the OpenPilot Wiki.</p>"},{"location":"user-guide/concepts/hardware-setup/#wiring-diagram","title":"Wiring Diagram","text":"<p>Below is an example wiring diagram for a multirotor using an MSI Cubi as a companion computer. This diagram also includes the motor power switch, which allows for the sensors, flight controller, and companion computer to be powered on while the motors are off. This is a safer way to test sensors, code, etc. as the motors are unable to spin while the switch is off.</p> <p></p> <p>Your needs will likely be slightly different than what is shown. This is meant as an example only and can be adapted to fit your needs.</p>"},{"location":"user-guide/concepts/hardware-setup/#motor-layouts-and-mixer","title":"Motor Layouts and Mixer","text":"<p>The mixer takes in the desired forces and torques from the firmware controller and computes the motor and servo outputs accordingly. If it is not set correctly, it will likely lead to a crash. Make sure it is set properly for your airframe!</p> <p>Quick Start</p> <p>For a quick start, use one of the \"canned mixers\". For a more accurate mixer, use a custom mixer.</p> <p>ROSflight offers some pre-computed, \"canned\" mixers that can be used off the shelf for a variety of common multirotor and fixedwing airframes. These mixers do not take into account all the parameters of your system (i.e. motor and propeller parameters), so they will be less accurate than they could be. If you want a more accurate mixer, or have easy access to the motor and prop parameters of your system, then we recommend using a custom mixer. </p> <p>Important</p> <p>A mixer must be chosen for the firmware to allow arming.</p> <p>The desired mixer can be chosen by setting the <code>PRIMARY_MIXER</code> parameter to one of the following values:</p> # Mixer 0 ESC calibration 1 Quad + 2 Quad X 3 Hex + 4 Hex X 5 Octo + 6 Octo X 7 Y6 8 X8 9 Fixed-wing (traditional AETR) 10 Inverted V-tail fixedwing (like the RMRC Anaconda frame) 11 Custom mixer <p>The associated motor layouts are shown below for each mixer. The ESC calibration mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.</p> <p></p> <p>The following parameters related to the mixer are optional:</p> <ul> <li><code>SECONDARY_MIXER</code></li> <li><code>USE_MOTOR_PARAM</code></li> <li>All the custom mixer params of the form <code>PRI_MIXER_i_j</code> or <code>SEC_MIXER_i_j</code></li> </ul> <p>The following subsections have more detail on these parameters.</p>"},{"location":"user-guide/concepts/hardware-setup/#secondary-mixer","title":"Secondary Mixer","text":"<p>ROSflight also has a secondary mixer that can be set using the options in the above table by setting the <code>SECONDARY_MIXER</code> param.</p> <p>Offboard control commands will use the secondary mixer, while commands from the RC safety pilot will use the primary mixer. Thus, both RC throttle and attitude override will affect the mixer, as shown in the following image.</p> <p></p> <p>The <code>mixer_to_use_</code> structure represents the mixer that will be used when computing the output. The header, which includes the default PWM rate and the output type for each output channel, is always set to the same as the primary mixer. See Defining a Custom Mixer for more information. Note that if the <code>SECONDARY_MIXER</code> param is not set, then it will default to the same value as the primary mixer.</p> <p>The secondary mixer might be useful when the airframe needs a different mixer for the offboard control (from the companion computer) than for RC control (from the safety pilot). It allows flexibility for more advanced mixing schemes while still having a functional mixer available to a safety pilot.</p>"},{"location":"user-guide/concepts/hardware-setup/#using-motor-parameters","title":"Using Motor Parameters","text":"<p>The parameter <code>USE_MOTOR_PARAM</code> causes the firmware to compute the actuator outputs differently than if <code>USE_MOTOR_PARAM</code> is set false. As described in Small Unmanned Aircraft: Theory and Practice by Beard and McLain, the mixing matrix is formed using equations from propeller theory, resulting in a set of equations that set the desired forces and torques equal to the square of the angular speeds of the propellers. If the motor and propeller parameters are known, then the desired voltage (and thus throttle) setting can be computed from the squared angular speeds.</p> <p>If the motor and propeller parameters are not known, then some simplifying assumptions are made to compute the desired throttle settings for each motor from the desired forces and torques. See the report on the ROSflight mixer derivation for more information on the mixer derivation and assumptions.</p> <p>Quick Start</p> <p>If using a canned mixer, set <code>USE_MOTOR_PARAM=0</code>.</p> <p>If using a custom mixer, set <code>USE_MOTOR_PARAM=1</code> only if the mixer was designed with motor parameters.</p> <p>The canned mixing matrices assume that <code>USE_MOTOR_PARAM</code> parameter is set to false. Using a canned mixer matrix and setting <code>USE_MOTOR_PARAM=1</code> (i.e. specifying that you want to mix with motor and propeller parameters) will cause the outputs to be scaled incorrectly. It is not required to use motor and propeller parameters when using a custom mixing matrix, but make sure your custom mixer makes sense.</p> <p>Also, if you selected a custom mixer and used the motor parameters to generate the mixer, make sure you set <code>USE_MOTOR_PARAM=1</code>. Otherwise, the outputs will likely be scaled incorrectly.</p> <p>Important</p> <p>We recommend flying your firmware in simulation before loading the firmware onto real hardware to make sure everything is working.</p> <p>Warning</p> <p>It is not recommended to use a canned mixer for the primary mixer and a custom mixer for the secondary mixer when the secondary mixer needs <code>USE_MOTOR_PARAM=1</code>. In other words, both <code>PRIMARY_MIXER</code> and <code>SECONDARY_MIXER</code> should use motor parameters, or neither should.</p> <p>This is important because the canned mixers make assumptions that affect the gains of the controller on the aircraft. This means that a canned mixer will require slightly different tuning than a custom mixer might.</p>"},{"location":"user-guide/concepts/hardware-setup/#defining-a-custom-mixer","title":"Defining a Custom Mixer","text":"<p>A custom mixer can be defined by:</p> <ol> <li>Set <code>PRIMARY_MIXER</code> (required) and/or <code>SECONDARY_MIXER</code> (optional) to the desired value in the mixer table</li> <li>Load the mixing matrix parameters for either/both the primary or the secondary mixer</li> </ol> <p>Note that computing the parameters of the mixing matrix can be done on the companion computer.</p> <p>The firmware loads a custom mixer by loading all mixing matrix values from parameters. Since there are 6 inputs to the mixer (F_x,F_y,F_z,Q_x,Q_y,Q_z) and 10 possible outputs, the mixer is a 6x10 matrix and there are 60 parameters associated with each custom mixer. For a standard quadrotor, however, most of these would be zero, since only the first 4 outputs (columns of the mixer matrix) would be used.</p> <p>In addition to the parameters associated with the 6x10 mixing matrix, there are two additional sets of parameters that need to be defined for each output used, the <code>PRI_MIXER_OUT_i</code> and the <code>PRI_MIXER_PWM_i</code> parameters, which define the output type and the default PWM rate, respectively, for the <code>i</code>th output. See the Parameter Configuration Page for more information on these parameters. The PWM rate is typically 490 or 50 Hz.</p> <p>Mixing Matrix PWM Header</p> <p>Depending on the hardware used, the 10 <code>PRI_MIXER_PWM_*</code> parameters need to be grouped into sections. This is because the PWM outputs are not all on separate interrupts, so it is not possible to set each PWM rate individually.</p> <p>The number of interrupts varies based on hardware. If you don't want to worry about it, just set all the <code>PRI_MIXER_PWM_i</code> to the same value, if possible.</p> <p>The recommended way to load a custom mixer is to first compute all the required parameters and save them to a file on the companion computer. The parameters are named <code>PRI_MIXER_i_j</code> or <code>SEC_MIXER_i_j</code>, where <code>(i,j)</code> is the index of the parameter in the 6x10 mixing matrix. See the Parameter Configuration Page for more information on these parameters. A convenience script is available in the <code>roscopter</code> ROS2 package that will compute the custom mixer and save the parameter values in a format ready to load.</p> <p>Once the parameters are saved to a file, load them with the ROS2 service call (make sure <code>rosflight_io</code> is running): <code>ros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"{file: absolute/or/relative/path/to/saved/param/file.yaml}\"</code></p> <p>Also make sure to save those parameters to memory with the ROS2 service call: <code>ros2 service call /param_write std_srvs/srv/Trigger</code></p> <p>Tip</p> <p>Test your mixer in simulation first when making changes, to avoid accidents.</p>"},{"location":"user-guide/concepts/hardware-setup/#connecting-to-the-flight-controller","title":"Connecting to the Flight Controller","text":"<p>The flight controller communicates with the companion computer over a serial link. ROSflight only supports one serial connection at a time and by default should be the serial link connected to the USB connector on the board.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/","title":"Improving Firmware Performance","text":""},{"location":"user-guide/concepts/improving-firmware-performance/#improving-firmware-performance","title":"Improving Firmware Performance","text":"<p>ROSflight supplies several methods to improve the performance of your aircraft. Tuning gains, adding feed-forward torques, and tuning the estimator are three ways to get your aircraft flying great!</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#gain-tuning","title":"Gain Tuning","text":"<p>Because there are a wide variety of multirotors out there, no one set of PID controller gains will be optimal for all vehicles. The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases. However, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably. There are some great tutorials online on multirotor gain tuning; this is another tried-and-true method used to great effect at BYU.</p> <p>If you are unfamiliar with PIDs, you should probably go read about them before trying to tune a multirotor. Getting an understanding for what is going on will definitely guide your decision making process as you try to find better gains.</p> <p>While tuning controller gains, it is very likely that the multirotor will oscillate out of control. To handle this scenario, we generally add what we call \"training wheels\" to the multirotors we are tuning. These amount to thin carbon rods in the shape of an X zip-tied to the landing gear. This widens out the base of the multirotor so if you come down on a hard oscillation, chances are the vehicle will land upright, hopefully without a prop strike, or worse, battery damage with a thermal runaway event. If the battery is not tucked inside the main frame, it is wise to add some foam as protection to the battery.</p> <p>Here is a video of a maiden flight of ROSflight with \"training wheels\" attached.</p> <p>Now, for the procedure on tuning.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#tuning-roll-and-pitch-angles","title":"Tuning Roll and Pitch angles","text":"<p>Here is a flowchart describing my PID tuning process for roll and pitch:</p> <p></p> <p>You may want to do another D-tuning iteration. Additionally, sometimes it is helpful to do a little tweaking on roll and pitch separately to eek out a little more performance from the differences in roll and pitch dynamics of your vehicle.</p> <p>Notice that we did not include any <code>I</code> tuning. As a general rule, try to keep the <code>I</code> gain as low as possible. It will always slow your response rate to input, and it can induce low frequency oscillations.</p> <p>You should only have <code>I</code> gain on roll and pitch if one of the following is true:</p> <ol> <li>You expect your CG to change, and/or</li> <li>You expect your rotor geometry to change</li> </ol> <p>Both of these are pretty rare. Instead, use your RC transmitter to trim the aircraft so it hovers with no stick input. In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on the roll, pitch and yaw rates.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#tuning-yaw-rate","title":"Tuning Yaw rate","text":"<p>Dynamically and algorithmically, using a <code>D</code> gain in yaw-rate control has no significant advantage. Controlling with derivative requires differentiating gyro measurements, which tends to be pretty noisy. In our experience, putting <code>D</code> in rate controllers on multirotors has always decreased performance.</p> <p>Tuning yaw rate is generally pretty easy. Basically, keep cranking it up until you feel like it's \"locked in\". Sometimes, a little bit of <code>I</code> (on the order of 0.1P) can help with this as well.</p> <p>The problem with too much <code>P</code> on yaw rate generally manifests itself in motor saturation. Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat. After you are done tuning, you might want to look at a plot of motor commands during a fairly aggressive flight. Underactuated yaw will be pretty obvious in these plots, because you will see the motor commands railing. To fix this, you can put shims between the arm mounts and the motors to tilt the motors just a little bit in the direction of yaw for that motor.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#rc-trim","title":"RC trim","text":"<p>In the vast majority of cases, your multirotor will not be built perfectly. The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different. One way to fix this is by adding an integrator. Integrators get rid of static offsets such as those just mentioned. However, as explained above, integrators also always slow vehicle response. In our case, since this offset is going to be constant, we can instead find a \"feed-forward\", or equilibrium offset, torque that you need to apply to hover without drift.</p> <p>Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level. This is done by trimming the aircraft with the RC trims. These are usually the little switches next to the sticks on your transmitter. Adjust these until you can hover the multirotor without touching the sticks.</p> <p>Next, land the multirotor, disarm, center the sticks and perform a trim calibration with <code>ros2 service call /calibrate_rc_trim std_srvs/srv/Trigger</code>. ROSflight then uses the trim settings on your transmitter to find these feed-forward, or equilibrium, torques that need to be applied post-controller to keep the multirotor level. These torques will be applied to all future commands (both from the companion computer and RC), so you will need to zero out your transmitter trims after calibration.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#estimator-tuning","title":"Estimator Tuning","text":"<p>ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \"Non-linear complementary filters on the special orthogonal group\" by Robert Mahony<sup>1</sup>,  to estimate attitude and angular rates. The implementation has been improved with suggestions from \"Attitude Representation and Kinematic Propagation for Low-Cost UAVs\" by Robert Casey<sup>2</sup>. A write-up of the derivation and implementation details can be found in the LaTeX report in <code>reports/estimator.tex</code>. (You'll need to be able to compile LaTeX sources to view the PDF).</p> <p>In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations. A block diagram of the estimator is shown below for reference. y_{gyro} and y_{acc} are gyro and accelerometer measurements, respectively and \\beta_{gyro} is the estimated gyro biases.</p> <p></p>"},{"location":"user-guide/concepts/improving-firmware-performance/#tuning-the-low-pass-filter-gains","title":"Tuning the Low-Pass Filter Gains","text":"<p>The <code>ACC_LPF_ALPHA</code> and <code>GYRO_LPF_ALPHA</code> parameters are used in the following low-pass-filter implementation (see lines <code>98-106</code> of <code>estimator.c</code>):</p> x_t = (1-\\alpha)y_t + \\alpha x_{t-1} <p>where y_t is the measurement and x_t is the filtered value. Lowering \\alpha will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \\alpha. Reducing \\alpha too far, however will result in a lot of noise from the sensors making its way into the motors. This can cause motors to get really hot, so make sure you check motor temperature if you are changing the low-pass filter constants.</p>"},{"location":"user-guide/concepts/improving-firmware-performance/#tuning-the-complementary-filter","title":"Tuning the Complementary Filter","text":"<p>The complementary filter has two gains, k_p and k_i. For a complete understanding of how these work, we recommend reading the Mahony Paper, or the technical report in the reports folder. In short, k_p can be thought of as the strength of accelerometer measurements in the filter, and the k_i gain is the integral constant on the gyro bias. These values should probably not be changed. Before you go changing these values, make sure you completely understand how they work in the filter.</p> <p>If you do decide to change these values, you should stick to the following rule of thumb.</p> k_i \\approx \\tfrac{k_p}{10}."},{"location":"user-guide/concepts/improving-firmware-performance/#external-attitude-measurements","title":"External Attitude Measurements","text":"<p>Because the onboard attitude estimator uses only inertial measurements, the estimates can deviate from truth. This is especially true during extended periods of accelerated flight, during which the gravity vector cannot be measured. Attitude measurements from an external source can be applied to the filter to help improve performance. These external attitude measurements might come from a higher-level estimator running on the companion computer that fuses additional information from GPS, vision, or a motion capture system.</p> <p>To send these updates to the flight controller, publish a <code>geometry_msgs/Quaternion</code> message to the <code>external_attitude</code> topic to which <code>rosflight_io</code> subscribes. The degree to which this update will be trusted is tuned with the <code>FILTER_KP_EXT</code> parameter.</p> <ol> <li> <p>Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0\u21a9</p> </li> <li> <p>Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.\u00a0\u21a9</p> </li> </ol>"},{"location":"user-guide/concepts/parameter-configuration/","title":"Parameter Configuration","text":""},{"location":"user-guide/concepts/parameter-configuration/#parameters","title":"Parameters","text":"<p>The ROSflight firmware has several dozen parameters which it uses to customize performance. Parameters are considered semi-static variables. That is, parameters do not change during flight, but they may change between vehicles. Examples of parameters you may wish to change are:</p> <ul> <li>Fixed-wing vehicle flag</li> <li>PID gains</li> <li>Mixer choice</li> <li>IMU low-pass filter constant</li> <li>RC receiver type (PPM or SBUS)</li> </ul> <p>and so on. Access to all parameters is enabled via ROS2 services advertised by <code>rosflight_io</code> while the flight controller is connected.</p>"},{"location":"user-guide/concepts/parameter-configuration/#parameter-interface","title":"Parameter Interface","text":""},{"location":"user-guide/concepts/parameter-configuration/#getting-parameter-values","title":"Getting Parameter Values","text":"<p>Sometimes it is handy to ask the flight controller what the current value of a parameter is. This is accomplished using the <code>param_get</code> service. As an example, let's retrieve the roll angle controller proportional (P) gain.</p> <pre><code>ros2 service call /param_get rosflight_msgs/srv/ParamGet \"{name: \"PID_ROLL_ANG_P\"}\"\n</code></pre> <p>You should get a response similar to the following (this happens to be the default value with floating-point error):</p> <pre><code>exists: True\nvalue: 0.15000000596\n</code></pre>"},{"location":"user-guide/concepts/parameter-configuration/#changing-parameters","title":"Changing Parameters","text":"<p>Parameters are changed via the <code>param_set</code> service. As an example, let's change the roll angle controller P gain. (I will assume that the flight controller is connected and <code>rosflight_io</code> is running in the root namespace.)</p> <pre><code>ros2 service call /param_set rosflight_msgs/srv/ParamSet \"{name: \"PID_ROLL_ANG_P\", value: 0.08}\"\n</code></pre> <p>You should get a prompt from <code>rosflight_io</code> saying </p><pre><code>[ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08\n[ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters\n</code></pre><p></p> <p>Notice that the parameters have been set, but not saved. Parameter changes take effect immediately, however they will not persist over a reboot unless you write them to the non-volatile memory. This brings us to the next task.</p>"},{"location":"user-guide/concepts/parameter-configuration/#changing-parameters-via-rosflight_io-ros2-params","title":"Changing Parameters via <code>rosflight_io</code> ROS2 params","text":"<p>The <code>rosflight_io</code> node has some firmware parameters exposed via the ROS2 parameter interface, enabling quick configuration of some of the firmware's parameters. This means that changing these <code>rosflight_io</code> parameters via the standard ROS2 parameter configuration will automatically change them in the firmware.</p> <p>Currently, only the controller gains have been exposed to <code>rosflight_io</code>'s parameters. To expose more, see the <code>rosflight_io.cpp</code> file.</p>"},{"location":"user-guide/concepts/parameter-configuration/#writing-parameters","title":"Writing Parameters","text":"<p>To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory. This is done by calling <code>param_write</code></p> <pre><code>ros2 service call /param_write std_srvs/srv/Trigger\n</code></pre> <p><code>rosflight_io</code> should then respond with </p><pre><code>[ INFO] [1491672597.123201952]: Param write succeeded\n[ INFO] [1491672597.123452908]: Onboard parameters have been saved\n</code></pre><p></p> <p>Warning</p> <p>It is highly recommended that you write parameters before arming and flying the vehicle. Among other things, this will ensure that in the rare case that a hard fault is encountered and the flight controller must reboot during flight, the correct configuration will be loaded on reboot.</p> <p>Tip</p> <p>Parameter writing can only happen if the flight controller is disarmed. If the param write failed for some reason, you may want to make sure your FC is disarmed and try again.</p>"},{"location":"user-guide/concepts/parameter-configuration/#backing-up-and-loading-parameters-from-file","title":"Backing Up and Loading Parameters from File","text":"<p>It is good practice to back up your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles. We can do this via the <code>param_save_to_file</code> and <code>param_load_from_file</code> services.</p> <p>First, let's back up our current parameter configuration:</p> <pre><code>ros2 service call /param_save_to_file rosflight_msgs/srv/ParamFile \"{filename: \"~/parameters.yaml\"}\"\n</code></pre> <p>Parameters are saved in YAML format. You must also specify the absolute file name of where you would like your parameters to be saved. The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller.</p> <p>Now, let's say we want to re-load this parameter file </p><pre><code>ros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"{filename: \"~/parameters.yml\"}\"\n</code></pre> Again, you must specify the absolute file name of the file to be loaded.<p></p>"},{"location":"user-guide/concepts/parameter-configuration/#fixed-wing-parameter-configuration","title":"Fixed-Wing Parameter Configuration","text":"<p>Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed-wing aircraft.</p> Parameter Description Type Fixed-Wing Value MOTOR_PWM_UPDATE Refresh rate of motor commands to motors and servos (Hz) - See motor documentation int 50 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_PWM int false MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 ARM_CHANNEL RC switch channel mapped to arming [0 indexed, -1 to disable] int 4 FIXED_WING switches on passthrough commands for fixed-wing operation int true MIXER Which mixer to choose - See Mixer documentation int 10 ELEVATOR_REV reverses elevator servo output int 0/1 AIL_REV reverses aileron servo output int 0/1 RUDDER_REV reverses rudder servo output int 0/1 CAL_GYRO_ARM Calibrate gyros when arming - generally only for multirotors int false"},{"location":"user-guide/concepts/parameter-configuration/#description-of-all-parameters","title":"Description of all Parameters","text":"<p>This is a list of all ROSflight parameters, including their types, default values, and minimum and maximum recommended values:</p> Parameter Description Type Default Value Min Max BAUD_RATE Baud rate of MAVlink communication with companion computer int 921600 9600 921600 SERIAL_DEVICE Serial Port (for supported devices) int 0 0 3 AIR_DENSITY Density of the air (kg/m^3) float 1.225f 0 1000.0 NUM_MOTORS Number of vertical-facing motors on the vehicle int 4 1 8 MOTOR_RESISTANCE Electrical resistance of the motor windings (ohms) float 0.042f 0 1000.0 MOTOR_KV Back emf constant of the motor in SI units (V/rad/s) float 0.01706f 0 1000.0 NO_LOAD_CURRENT No-load current of the motor in amps float 1.5 0 1000.0 PROP_DIAMETER Diameter of the propeller in meters float 0.381f 0 1.0 PROP_CT Thrust coefficient of the propeller float 0.075f 0 100.0 PROP_CQ Torque coefficient of the propeller float 0.0045f 0 100.0 VOLT_MAX Maximum voltage of the battery (V) float 25.0f 0 100.0 USE_MOTOR_PARAM Flag to use motor parameters in the mixer int false 0 1 PRI_MIXER_OUT_0 Output type of mixer output 0. int 0 0 1 PRI_MIXER_OUT_1 Output type of mixer output 1. int 0 0 1 PRI_MIXER_OUT_2 Output type of mixer output 2. int 0 0 1 PRI_MIXER_OUT_3 Output type of mixer output 3. int 0 0 1 PRI_MIXER_OUT_4 Output type of mixer output 4. int 0 0 1 PRI_MIXER_OUT_5 Output type of mixer output 5. int 0 0 1 PRI_MIXER_OUT_6 Output type of mixer output 6. int 0 0 1 PRI_MIXER_OUT_7 Output type of mixer output 7. int 0 0 1 PRI_MIXER_OUT_8 Output type of mixer output 8. int 0 0 1 PRI_MIXER_OUT_9 Output type of mixer output 9. int 0 0 1 PRI_MIXER_PWM_0 PWM frequenct output for mixer output 0 float 0 0 490 PRI_MIXER_PWM_1 PWM frequenct output for mixer output 1 float 0 0 490 PRI_MIXER_PWM_2 PWM frequenct output for mixer output 2 float 0 0 490 PRI_MIXER_PWM_3 PWM frequenct output for mixer output 3 float 0 0 490 PRI_MIXER_PWM_4 PWM frequenct output for mixer output 4 float 0 0 490 PRI_MIXER_PWM_5 PWM frequenct output for mixer output 5 float 0 0 490 PRI_MIXER_PWM_6 PWM frequenct output for mixer output 6 float 0 0 490 PRI_MIXER_PWM_7 PWM frequenct output for mixer output 7 float 0 0 490 PRI_MIXER_PWM_8 PWM frequenct output for mixer output 8 float 0 0 490 PRI_MIXER_PWM_9 PWM frequenct output for mixer output 9 float 0 0 490 PRI_MIXER_0_0 Value of the custom mixer at element [0,0] float 0.0f -inf inf PRI_MIXER_1_0 Value of the custom mixer at element [1,0] float 0.0f -inf inf PRI_MIXER_2_0 Value of the custom mixer at element [2,0] float 0.0f -inf inf PRI_MIXER_3_0 Value of the custom mixer at element [3,0] float 0.0f -inf inf PRI_MIXER_4_0 Value of the custom mixer at element [4,0] float 0.0f -inf inf PRI_MIXER_5_0 Value of the custom mixer at element [5,0] float 0.0f -inf inf PRI_MIXER_0_1 Value of the custom mixer at element [0,1] float 0.0f -inf inf PRI_MIXER_1_1 Value of the custom mixer at element [1,1] float 0.0f -inf inf PRI_MIXER_2_1 Value of the custom mixer at element [2,1] float 0.0f -inf inf PRI_MIXER_3_1 Value of the custom mixer at element [3,1] float 0.0f -inf inf PRI_MIXER_4_1 Value of the custom mixer at element [4,1] float 0.0f -inf inf PRI_MIXER_5_1 Value of the custom mixer at element [5,1] float 0.0f -inf inf PRI_MIXER_0_2 Value of the custom mixer at element [0,2] float 0.0f -inf inf PRI_MIXER_1_2 Value of the custom mixer at element [1,2] float 0.0f -inf inf PRI_MIXER_2_2 Value of the custom mixer at element [2,2] float 0.0f -inf inf PRI_MIXER_3_2 Value of the custom mixer at element [3,2] float 0.0f -inf inf PRI_MIXER_4_2 Value of the custom mixer at element [4,2] float 0.0f -inf inf PRI_MIXER_5_2 Value of the custom mixer at element [5,2] float 0.0f -inf inf PRI_MIXER_0_3 Value of the custom mixer at element [0,3] float 0.0f -inf inf PRI_MIXER_1_3 Value of the custom mixer at element [1,3] float 0.0f -inf inf PRI_MIXER_2_3 Value of the custom mixer at element [2,3] float 0.0f -inf inf PRI_MIXER_3_3 Value of the custom mixer at element [3,3] float 0.0f -inf inf PRI_MIXER_4_3 Value of the custom mixer at element [4,3] float 0.0f -inf inf PRI_MIXER_5_3 Value of the custom mixer at element [5,3] float 0.0f -inf inf PRI_MIXER_0_4 Value of the custom mixer at element [0,4] float 0.0f -inf inf PRI_MIXER_1_4 Value of the custom mixer at element [1,4] float 0.0f -inf inf PRI_MIXER_2_4 Value of the custom mixer at element [2,4] float 0.0f -inf inf PRI_MIXER_3_4 Value of the custom mixer at element [3,4] float 0.0f -inf inf PRI_MIXER_4_4 Value of the custom mixer at element [4,4] float 0.0f -inf inf PRI_MIXER_5_4 Value of the custom mixer at element [5,4] float 0.0f -inf inf PRI_MIXER_0_5 Value of the custom mixer at element [0,5] float 0.0f -inf inf PRI_MIXER_1_5 Value of the custom mixer at element [1,5] float 0.0f -inf inf PRI_MIXER_2_5 Value of the custom mixer at element [2,5] float 0.0f -inf inf PRI_MIXER_3_5 Value of the custom mixer at element [3,5] float 0.0f -inf inf PRI_MIXER_4_5 Value of the custom mixer at element [4,5] float 0.0f -inf inf PRI_MIXER_5_5 Value of the custom mixer at element [5,5] float 0.0f -inf inf PRI_MIXER_0_6 Value of the custom mixer at element [0,6] float 0.0f -inf inf PRI_MIXER_1_6 Value of the custom mixer at element [1,6] float 0.0f -inf inf PRI_MIXER_2_6 Value of the custom mixer at element [2,6] float 0.0f -inf inf PRI_MIXER_3_6 Value of the custom mixer at element [3,6] float 0.0f -inf inf PRI_MIXER_4_6 Value of the custom mixer at element [4,6] float 0.0f -inf inf PRI_MIXER_5_6 Value of the custom mixer at element [5,6] float 0.0f -inf inf PRI_MIXER_0_7 Value of the custom mixer at element [0,7] float 0.0f -inf inf PRI_MIXER_1_7 Value of the custom mixer at element [1,7] float 0.0f -inf inf PRI_MIXER_2_7 Value of the custom mixer at element [2,7] float 0.0f -inf inf PRI_MIXER_3_7 Value of the custom mixer at element [3,7] float 0.0f -inf inf PRI_MIXER_4_7 Value of the custom mixer at element [4,7] float 0.0f -inf inf PRI_MIXER_5_7 Value of the custom mixer at element [5,7] float 0.0f -inf inf PRI_MIXER_0_8 Value of the custom mixer at element [0,8] float 0.0f -inf inf PRI_MIXER_1_8 Value of the custom mixer at element [1,8] float 0.0f -inf inf PRI_MIXER_2_8 Value of the custom mixer at element [2,8] float 0.0f -inf inf PRI_MIXER_3_8 Value of the custom mixer at element [3,8] float 0.0f -inf inf PRI_MIXER_4_8 Value of the custom mixer at element [4,8] float 0.0f -inf inf PRI_MIXER_5_8 Value of the custom mixer at element [5,8] float 0.0f -inf inf PRI_MIXER_0_9 Value of the custom mixer at element [0,9] float 0.0f -inf inf PRI_MIXER_1_9 Value of the custom mixer at element [1,9] float 0.0f -inf inf PRI_MIXER_2_9 Value of the custom mixer at element [2,9] float 0.0f -inf inf PRI_MIXER_3_9 Value of the custom mixer at element [3,9] float 0.0f -inf inf PRI_MIXER_4_9 Value of the custom mixer at element [4,9] float 0.0f -inf inf PRI_MIXER_5_9 Value of the custom mixer at element [5,9] float 0.0f -inf inf SEC_MIXER_0_0 Value of the custom mixer at element [0,0] float 0.0f -inf inf SEC_MIXER_1_0 Value of the custom mixer at element [1,0] float 0.0f -inf inf SEC_MIXER_2_0 Value of the custom mixer at element [2,0] float 0.0f -inf inf SEC_MIXER_3_0 Value of the custom mixer at element [3,0] float 0.0f -inf inf SEC_MIXER_4_0 Value of the custom mixer at element [4,0] float 0.0f -inf inf SEC_MIXER_5_0 Value of the custom mixer at element [5,0] float 0.0f -inf inf SEC_MIXER_0_1 Value of the custom mixer at element [0,1] float 0.0f -inf inf SEC_MIXER_1_1 Value of the custom mixer at element [1,1] float 0.0f -inf inf SEC_MIXER_2_1 Value of the custom mixer at element [2,1] float 0.0f -inf inf SEC_MIXER_3_1 Value of the custom mixer at element [3,1] float 0.0f -inf inf SEC_MIXER_4_1 Value of the custom mixer at element [4,1] float 0.0f -inf inf SEC_MIXER_5_1 Value of the custom mixer at element [5,1] float 0.0f -inf inf SEC_MIXER_0_2 Value of the custom mixer at element [0,2] float 0.0f -inf inf SEC_MIXER_1_2 Value of the custom mixer at element [1,2] float 0.0f -inf inf SEC_MIXER_2_2 Value of the custom mixer at element [2,2] float 0.0f -inf inf SEC_MIXER_3_2 Value of the custom mixer at element [3,2] float 0.0f -inf inf SEC_MIXER_4_2 Value of the custom mixer at element [4,2] float 0.0f -inf inf SEC_MIXER_5_2 Value of the custom mixer at element [5,2] float 0.0f -inf inf SEC_MIXER_0_3 Value of the custom mixer at element [0,3] float 0.0f -inf inf SEC_MIXER_1_3 Value of the custom mixer at element [1,3] float 0.0f -inf inf SEC_MIXER_2_3 Value of the custom mixer at element [2,3] float 0.0f -inf inf SEC_MIXER_3_3 Value of the custom mixer at element [3,3] float 0.0f -inf inf SEC_MIXER_4_3 Value of the custom mixer at element [4,3] float 0.0f -inf inf SEC_MIXER_5_3 Value of the custom mixer at element [5,3] float 0.0f -inf inf SEC_MIXER_0_4 Value of the custom mixer at element [0,4] float 0.0f -inf inf SEC_MIXER_1_4 Value of the custom mixer at element [1,4] float 0.0f -inf inf SEC_MIXER_2_4 Value of the custom mixer at element [2,4] float 0.0f -inf inf SEC_MIXER_3_4 Value of the custom mixer at element [3,4] float 0.0f -inf inf SEC_MIXER_4_4 Value of the custom mixer at element [4,4] float 0.0f -inf inf SEC_MIXER_5_4 Value of the custom mixer at element [5,4] float 0.0f -inf inf SEC_MIXER_0_5 Value of the custom mixer at element [0,5] float 0.0f -inf inf SEC_MIXER_1_5 Value of the custom mixer at element [1,5] float 0.0f -inf inf SEC_MIXER_2_5 Value of the custom mixer at element [2,5] float 0.0f -inf inf SEC_MIXER_3_5 Value of the custom mixer at element [3,5] float 0.0f -inf inf SEC_MIXER_4_5 Value of the custom mixer at element [4,5] float 0.0f -inf inf SEC_MIXER_5_5 Value of the custom mixer at element [5,5] float 0.0f -inf inf SEC_MIXER_0_6 Value of the custom mixer at element [0,6] float 0.0f -inf inf SEC_MIXER_1_6 Value of the custom mixer at element [1,6] float 0.0f -inf inf SEC_MIXER_2_6 Value of the custom mixer at element [2,6] float 0.0f -inf inf SEC_MIXER_3_6 Value of the custom mixer at element [3,6] float 0.0f -inf inf SEC_MIXER_4_6 Value of the custom mixer at element [4,6] float 0.0f -inf inf SEC_MIXER_5_6 Value of the custom mixer at element [5,6] float 0.0f -inf inf SEC_MIXER_0_7 Value of the custom mixer at element [0,7] float 0.0f -inf inf SEC_MIXER_1_7 Value of the custom mixer at element [1,7] float 0.0f -inf inf SEC_MIXER_2_7 Value of the custom mixer at element [2,7] float 0.0f -inf inf SEC_MIXER_3_7 Value of the custom mixer at element [3,7] float 0.0f -inf inf SEC_MIXER_4_7 Value of the custom mixer at element [4,7] float 0.0f -inf inf SEC_MIXER_5_7 Value of the custom mixer at element [5,7] float 0.0f -inf inf SEC_MIXER_0_8 Value of the custom mixer at element [0,8] float 0.0f -inf inf SEC_MIXER_1_8 Value of the custom mixer at element [1,8] float 0.0f -inf inf SEC_MIXER_2_8 Value of the custom mixer at element [2,8] float 0.0f -inf inf SEC_MIXER_3_8 Value of the custom mixer at element [3,8] float 0.0f -inf inf SEC_MIXER_4_8 Value of the custom mixer at element [4,8] float 0.0f -inf inf SEC_MIXER_5_8 Value of the custom mixer at element [5,8] float 0.0f -inf inf SEC_MIXER_0_9 Value of the custom mixer at element [0,9] float 0.0f -inf inf SEC_MIXER_1_9 Value of the custom mixer at element [1,9] float 0.0f -inf inf SEC_MIXER_2_9 Value of the custom mixer at element [2,9] float 0.0f -inf inf SEC_MIXER_3_9 Value of the custom mixer at element [3,9] float 0.0f -inf inf SEC_MIXER_4_9 Value of the custom mixer at element [4,9] float 0.0f -inf inf SEC_MIXER_5_9 Value of the custom mixer at element [5,9] float 0.0f -inf inf SYS_ID Mavlink System ID int 1 1 255 PID_ROLL_RATE_P Roll Rate Proportional Gain float 0.070f 0.0 1000.0 PID_ROLL_RATE_I Roll Rate Integral Gain float 0.000f 0.0 1000.0 PID_ROLL_RATE_D Roll Rate Derivative Gain float 0.000f 0.0 1000.0 PID_PITCH_RATE_P Pitch Rate Proportional Gain float 0.070f 0.0 1000.0 PID_PITCH_RATE_I Pitch Rate Integral Gain float 0.0000f 0.0 1000.0 PID_PITCH_RATE_D Pitch Rate Derivative Gain float 0.0000f 0.0 1000.0 PID_YAW_RATE_P Yaw Rate Proportional Gain float 0.25f 0.0 1000.0 PID_YAW_RATE_I Yaw Rate Integral Gain float 0.0f 0.0 1000.0 PID_YAW_RATE_D Yaw Rate Derivative Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_P Roll Angle Proportional Gain float 0.15f 0.0 1000.0 PID_ROLL_ANG_I Roll Angle Integral Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_D Roll Angle Derivative Gain float 0.05f 0.0 1000.0 PID_PITCH_ANG_P Pitch Angle Proportional Gain float 0.15f 0.0 1000.0 PID_PITCH_ANG_I Pitch Angle Integral Gain float 0.0f 0.0 1000.0 PID_PITCH_ANG_D Pitch Angle Derivative Gain float 0.05f 0.0 1000.0 X_EQ_TORQUE Equilibrium torque added to output of controller on x axis float 0.0f -1.0 1.0 Y_EQ_TORQUE Equilibrium torque added to output of controller on y axis float 0.0f -1.0 1.0 Z_EQ_TORQUE Equilibrium torque added to output of controller on z axis float 0.0f -1.0 1.0 PID_TAU Dirty Derivative time constant - See controller documentation float 0.05f 0.0 1.0 MOTOR_PWM_UPDATE Overrides default PWM rate specified by mixer if non-zero - Requires reboot to take effect int 0 0 490 MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 0.0 1.0 FAILSAFE_THR Throttle sent to motors in failsafe condition (set just below hover throttle) float -1.0 0.0 1.0 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_THR int true 0 1 FILTER_INIT_T Time in ms to initialize estimator int 3000 0 100000 FILTER_KP_ACC estimator proportional gain on accel-based error - See estimator documentation float 0.5f 0 10.0 FILTER_KI estimator integral gain - See estimator documentation float 0.01f 0 1.0 FILTER_KP_EXT estimator proportional gain on external attitude-based error - See estimator documentation float 1.5f 0 10.0 FILTER_ACCMARGIN allowable accel norm margin around 1g to determine if accel is usable float 0.1f 0 1.0 FILTER_QUAD_INT Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors) int 1 0 1 FILTER_MAT_EXP 1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration int 1 0 1 FILTER_USE_ACC Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop) int 1 0 1 CAL_GYRO_ARM True if desired to calibrate gyros on arm int false 0 1 GYROXY_LPF_ALPHA Low-pass filter constant on gyro X and Y axes - See estimator documentation float 0.3f 0 1.0 GYROZ_LPF_ALPHA Low-pass filter constant on gyro Z axis - See estimator documentation float 0.3f 0 1.0 ACC_LPF_ALPHA Low-pass filter constant on all accel axes - See estimator documentation float 0.5f 0 1.0 GYRO_X_BIAS Constant x-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Y_BIAS Constant y-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Z_BIAS Constant z-bias of gyroscope readings float 0.0f -1.0 1.0 ACC_X_BIAS Constant x-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Y_BIAS Constant y-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Z_BIAS Constant z-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_X_TEMP_COMP Linear x-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Y_TEMP_COMP Linear y-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Z_TEMP_COMP Linear z-axis temperature compensation constant float 0.0f -2.0 2.0 MAG_A11_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A12_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A13_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A21_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A22_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A23_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A31_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A32_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A33_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_X_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Y_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Z_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 BARO_BIAS Barometer measurement bias (Pa) float 0.0f 0 inf GROUND_LEVEL Altitude of ground level (m) float 1387.0f -1000 10000 DIFF_PRESS_BIAS Differential Pressure Bias (Pa) float 0.0f -10 10 RC_TYPE Type of RC input 0 - PPM, 1 - SBUS int 0 0 1 RC_X_CHN RC input channel mapped to x-axis commands [0 - indexed] int 0 0 3 RC_Y_CHN RC input channel mapped to y-axis commands [0 - indexed] int 1 0 3 RC_Z_CHN RC input channel mapped to z-axis commands [0 - indexed] int 3 0 3 RC_F_CHN RC input channel mapped to F-axis commands [0 - indexed] int 2 0 3 RC_F_AXIS NED axis that RC F-channel gets mapped to 0 - X, 1 - Y, 2 - Z int 2 0 2 RC_ATT_OVRD_CHN RC switch mapped to attitude override [0 indexed, -1 to disable] int 4 4 7 RC_THR_OVRD_CHN RC switch channel mapped to throttle override [0 indexed, -1 to disable] int 4 4 7 RC_ATT_CTRL_CHN RC switch channel mapped to attitude control type [0 indexed, -1 to disable] int -1 4 7 ARM_CHANNEL RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable] int -1 4 7 RC_NUM_CHN number of RC input channels int 6 1 8 SWITCH_5_DIR RC switch 5 toggle direction int 1 -1 1 SWITCH_6_DIR RC switch 6 toggle direction int 1 -1 1 SWITCH_7_DIR RC switch 7 toggle direction int 1 -1 1 SWITCH_8_DIR RC switch 8 toggle direction int 1 -1 1 RC_OVRD_DEV RC stick deviation from center for override float 0.1 0.0 1.0 OVRD_LAG_TIME RC stick deviation lag time before returning control (ms) int 1000 0 100000 MIN_THROTTLE Take minimum throttle between RC and computer at all times int true 0 1 RC_MAX_THR Maximum throttle command sent by full deflection of RC sticks, to maintain controllability during aggressive maneuvers float 0.7f 0.0 1.0 RC_ATT_MODE Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set. int 1 0 1 RC_MAX_ROLL Maximum roll angle command sent by full deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_PITCH Maximum pitch angle command sent by full stick deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_ROLLRATE Maximum roll rate command sent by full stick deflection of RC sticks float 3.14159f 0.0 9.42477796077 RC_MAX_PITCHRATE Maximum pitch command sent by full stick deflection of RC sticks float 3.14159f 0.0 3.14159 RC_MAX_YAWRATE Maximum pitch command sent by full stick deflection of RC sticks float 1.507f 0.0 3.14159 PRIMARY_MIXER Which mixer to choose for primary mixer - See Mixer documentation int Mixer::INVALID_MIXER 0 11 SECONDARY_MIXER Which mixer to choose for secondary mixer - See Mixer documentation int Mixer::INVALID_MIXER 0 11 FIXED_WING switches on pass-through commands for fixed-wing operation int false 0 1 ELEVATOR_REV reverses elevator servo output int 0 0 1 AIL_REV reverses aileron servo output int 0 0 1 RUDDER_REV reverses rudder servo output int 0 0 1 FC_ROLL roll angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_PITCH pitch angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_YAW yaw angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 ARM_THRESHOLD RC deviation from max/min in yaw and throttle for arming and disarming check (us) float 0.15 0 500 BATT_VOLT_MULT Multiplier for the voltage sensor float 0.0f 0 inf BATT_CURR_MULT Multiplier for the current sensor float 0.0f 0 inf BATT_VOLT_ALPHA Alpha value for the low pass filter on the reported battery voltage float 0.995f 0 1 BATT_CURR_ALPHA Alpha value for the low pass filter on the reported battery current float 0.995f 0 1 OFFBOARD_TIMEOUT Timeout in milliseconds for offboard commands, after which RC override is activated int 100 0 100000"},{"location":"user-guide/concepts/preflight-checks/","title":"Pre-Flight Checks","text":""},{"location":"user-guide/concepts/preflight-checks/#pre-flight-checklist","title":"Pre-Flight Checklist","text":"<p>This is an example of a ROSflight pre-flight checklist. You will likely need to augment this with checks specific to both (a) your hardware and (b) the code running on your companion computer.</p>"},{"location":"user-guide/concepts/preflight-checks/#before-powering-up-motors","title":"Before powering up motors","text":"<ul> <li> ROS2 is running on the companion computer, communicating with the base station</li> <li> <code>rosflight_io</code> reports no errors</li> <li> Sensors are calibrated and publishing<ul> <li> IMU (re-calibrate every flight): <code>ros2 service call /calibrate_imu std_srvs/srv/Trigger</code></li> <li> Barometer: <code>ros2 service call /calibrate_baro std_srvs/srv/Trigger</code></li> <li> Sonar (if attached)</li> <li> Airspeed (if attached)</li> </ul> </li> <li> Estimated attitude is being published and looks accurate</li> <li> Published outputs look reasonable</li> <li> Parameter Check (if using a fixed-wing, there are about 8 parameters you will need to change from default)</li> <li> RC communication</li> <li> Failsafe behavior</li> <li> Arming and disarming</li> <li> RC override behavior</li> <li> RC range test</li> <li> Wire-wiggle test (wiggle all wires to look for bad connections)</li> <li> If desired, logging is turned on (e.g. recording a ros2 bag)</li> </ul>"},{"location":"user-guide/concepts/preflight-checks/#after-powering-up-motors","title":"After Powering Up Motors","text":"<p>Danger</p> <p>Be sure the flight controller is disarmed before powering up motors!!!</p> <ul> <li> Arm/Disarm test</li> <li> Propeller spin test (check directions and response to stick inputs)</li> <li> Control surface test (fixed-wing)</li> <li> Response to offboard controls</li> </ul>"},{"location":"user-guide/concepts/rc-configuration/","title":"RC Configuration","text":""},{"location":"user-guide/concepts/rc-configuration/#rc-configuration","title":"RC Configuration","text":""},{"location":"user-guide/concepts/rc-configuration/#rc-safety-pilot","title":"RC Safety Pilot","text":"<p>ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer:</p> <ul> <li>RC override switch: The safety pilot can flip a switch on the transmitter to take back RC control. Attitude and throttle override can be mapped independently, meaning you can choose one or the other, put them on separate switches, or put them both on the same switch.</li> <li>Stick deviations: If a stick is deviated from its center position, then that channel is overridden by RC control. This allows the safety pilot to take control without flipping a switch. This may be useful to provide a momentary correction on a single axis. The fraction of stick travel needed to activate the RC override is controlled by the <code>RC_OVRD_DEV</code> parameter. The <code>OVRD_LAG_TIME</code> parameter controls the amount of time that the override remains active after the sticks return to center.</li> <li>Minimum throttle: By default, the flight controller takes the minimum of the two throttle commands from RC and offboard control setpoints. This allows the safety pilot to drop the throttle quickly if needed. This behavior can be turned on or off with the <code>MIN_THROTTLE</code> parameter.</li> </ul>"},{"location":"user-guide/concepts/rc-configuration/#arming-errors-failsafe","title":"Arming, Errors &amp; Failsafe","text":"<p>The flight controller can only be armed and disarmed via RC control. Two mechanisms are provided: sticks (left stick down and right to arm, down and left to disarm) and switch. Only one of these options can be active at a time.</p> <p>The firmware runs a number of error checks before allowing the flight controller to arm. Completing the configuration checklist on the Getting Started page should avoid these errors. In addition to a few internal health checks, the following conditions are checked:</p> <ul> <li>Mixer: Valid mixer must have been selected (see the Hardware Setup documentation page)</li> <li>IMU calibration: The IMU must have been calibrated since firmware was flashed (it is recommended that you recalibrate often)</li> <li>RC: There must be an active RC connection</li> </ul> <p>In addition to the error checking before arming, the flight controller enters a failsafe mode if the RC connection is lost during flight while armed. While in failsafe mode the flight controller commands level flight with the throttle value defined by the <code>FAILSAFE_THR</code> parameter.</p> <p>The following is a simplified version of the finite state machine that defines logic used for the arming, error checks, and failsafe operations:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults if one were to occur, although this is unlikely with unmodified firmware. If a hard fault occurs while the flight controller is armed, the firmware has the ability to immediately rearm after rebooting to enable continued RC control of the vehicle for recovery.</p>"},{"location":"user-guide/concepts/rc-configuration/#binding-your-transmitter-to-your-receiver","title":"Binding your Transmitter to your Receiver","text":"<p>Follow the instructions in your user manual to bind your transmitter to your RC receiver. You may also be able to find a guide on YouTube with instructions; just search for your particular transmitter and receiver model.</p>"},{"location":"user-guide/concepts/rc-configuration/#rc-transmitter-calibration","title":"RC Transmitter Calibration","text":"<p>To avoid confusion and to reduce code complexity in the firmware source code, ROSflight does not perform software calibration of RC transmitters. This means that RC calibration must be done on the transmitter itself, as opposed to in software. This is pretty straight-forward for most modern transmitters.</p>"},{"location":"user-guide/concepts/rc-configuration/#configure-the-full-stick-output-for-each-channel","title":"Configure the full stick output for each channel","text":"<p>The easiest way to do this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable. You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from <code>rosflight_io</code></p> <pre><code>ros2 topic echo /rc_raw\n</code></pre> <ul> <li>Center both sticks on your transmitter</li> <li>Apply subtrim until the first four channels all read 1500 exactly (or as close as possible--some RC receivers are worse than others and cannot exactly output 1500 us)</li> <li>Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us.</li> </ul>"},{"location":"user-guide/concepts/rc-configuration/#configure-stick-directions-for-roll-pitch-and-yaw-channels","title":"Configure stick directions for roll, pitch, and yaw channels.","text":"<p>You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight.</p> <p>You may find this graphic helpful. It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from <code>rosflight_io</code>. Make sure that the stick output is in the correct direction.</p> <p></p> <p>It should be noted that channel assignment can be modified via the <code>RC_*_CHN</code> parameters. So, if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.</p>"},{"location":"user-guide/concepts/rc-configuration/#switch-configuration","title":"Switch Configuration","text":"<p>Switches can be configured for the following functions. To disable a switch for a specific, default function, set the corresponding parameter to <code>-1</code>. Be sure to check that the switch directions operate as you intend, and reverse them in your transmitter if necessary.</p>"},{"location":"user-guide/concepts/rc-configuration/#safety-pilot-configuration","title":"Safety Pilot Configuration","text":"<p>The <code>RC_ATT_OVRD_CHN</code> parameter maps a switch to override attitude commands with RC control. The <code>RC_THR_OVRD_CHN</code> parameter maps a switch to override throttle commands with RC control. To override both with a single switch, set both parameters to the same value (this is the default behavior).</p>"},{"location":"user-guide/concepts/rc-configuration/#arming","title":"Arming","text":"<p>By default, arming is done with the sticks (left stick down and right to arm, down and left to disarm). To use a switch instead, set the <code>ARM_CHANNEL</code> parameter to the desired channel. Setting an arming switch disables arming with the sticks.</p>"},{"location":"user-guide/concepts/rc-configuration/#flight-mode","title":"Flight Mode","text":"<p>If desired, you can map a switch to select between attitude control types (angle and rate) in flight by setting the <code>RC_ATT_CTRL_CHN</code> parameter to the desired channel. This can be useful if, for example, you are learning rate mode but want to be able to switch back to attitude mode to help stabilize the vehicle. This feature is disabled by default.</p>"},{"location":"user-guide/concepts/rosplane-overview/","title":"ROSplane Overview","text":""},{"location":"user-guide/concepts/rosplane-overview/#rosplane-overview","title":"ROSplane Overview","text":"<p>ROSplane is a basic fixed-wing autopilot built around ROS2 for use with the ROSflight autopilot. It is built according to the methods published in Small Unmanned Aircraft: Theory and Practice by Dr. Randy Beard and Dr. Tim McLain.</p> <p>As per the ROSflight vision, ROSplane is not a fully-featured fixed-wing autopilot. Instead, ROSplane is a simple, lean, ROS2-based fixedwing autopilot</p> <p>The core ROSplane package is a simple waypoint-following autopilot. This includes a navigation stack, a controller, and an estimator. This can be seen in the figure below.</p> Diagram of the ROSplane architecture <p>The structure of ROSplane and the nature of ROS2 interfaces allow ROSplane to be very modular, allowing you to write and integrate your own code without having to spend as much time working with interfaces and code integration.  Since it is lean, the time to learn and understand the nature of ROSplane should be small compared to other, more featured (but more complex) autopilots. This can improve research productivity, decrease debugging time, and improve the development of novel algorithms.</p>"},{"location":"user-guide/concepts/rosplane-overview/#core-functionality","title":"Core Functionality","text":"<p>The ROSplane autopilot allows users to fly waypoint missions with an RC safety pilot. The simplicity of this framework allows users to add their own autonomy stacks or mission requirements on top of the ROSplane stack.</p> <p>For example, the <code>path_manager</code> node in the navigation stack in the core ROSplane package directs the <code>path_follower</code> node to follow either straight lines or circular arcs. However, if a project needed to follow B-splines instead, the <code>path_manager</code> and the <code>path_follower</code> nodes could easily be replaced to achieve that. Instead of loading a predetermined number of waypoints, higher levels of autonomy (i.e., vision-based guidance, etc.) can also be accomodated by building on top of the ROSplane stack by dynamically feeding the <code>path_planner</code> waypoints.</p>"},{"location":"user-guide/concepts/rosplane-overview/#using-rosplane","title":"Using ROSplane","text":"<p>For detailed instructions on how to use the core ROSplane package to fly autonomous waypoint missions, see the ROSplane Setup page.  This page can be used as a guide to building and running ROSplane before you start making your own changes to the autonomy stack.</p> <p>For detailed instructions on each of the components of ROSplane, see the ROSplane Developer Guide. This page provides detailed instructions on how to use and change the code for each component of the ROSplane stack.</p>"},{"location":"user-guide/concepts/rosplane-setup/","title":"ROSplane Setup","text":""},{"location":"user-guide/concepts/rosplane-setup/#rosplane-setup","title":"ROSplane Setup","text":"<p>Note</p> <p>ROSplane v2.0.0-beta is now available! Check the github repo for the latest code.</p> <p>ROSplane is a basic fixed-wing autopilot build around ROS2 for use with the ROSflight autopilot. It is built according to the methods published in Small Unmanned Aircraft: Theory and Practice by Dr. Randy Beard and Dr. Tim McLain.</p> <p>See ROSplane Overview for more general information on ROSplane.</p>"},{"location":"user-guide/concepts/rosplane-setup/#requirements","title":"Requirements","text":"<p>ROSplane requires a working ROS2 installation on a companion computer. ROSplane will most often be used in conjunction with the ROSflight firmware and the firmware interface (aka <code>rosflight_ros_pkgs</code>).</p> <p>Follow the instructions in the installation for sim guide to install and set up ROS2 and <code>rosflight_ros_pkgs</code>.</p>"},{"location":"user-guide/concepts/rosplane-setup/#installation","title":"Installation","text":"<p>You will need to install ROSplane on the companion computer.</p> <p>First, navigate to the src directory of the ROS2 workspace and clone the git repository:</p> <pre><code>cd ~/rosflight_ws/src\ngit clone https://github.com/rosflight/rosplane.git\n</code></pre> <p>Note</p> <p>Your <code>rosflight_ws</code> file structure should now look like: </p><pre><code>rosflight_ws\n  \u2514\u2500\u2500 src \n    \u251c\u2500\u2500 rosflight_ros_pkgs\n    \u2514\u2500\u2500 rosplane \n</code></pre><p></p> <p>Then navigate to the top of the <code>rosflight_ws</code> directory and build:</p> <pre><code>cd ..\ncolcon build\n</code></pre> <p>Warning</p> <p>The build will fail if you have not built the <code>rosflight_msgs</code> previously or if you are not currently building it.</p> <p>Next, source the <code>rosflight_ws</code> install files. If you already added the source command to your <code>.bashrc</code> from the ROS2 Setup page, then you can skip this step.</p> <pre><code># source the install file\nsource install/setup.bash\n\n# add it to your .bashrc\necho \"source ~/rosflight_ws/install/setup.bash &gt;&gt; $HOME/.bashrc\"\n</code></pre> <p>Note that sourcing the <code>setup.bash</code> file in the <code>rosflight_ws</code> directory will install all ROS2 packages in any subdirectories.</p>"},{"location":"user-guide/concepts/rosplane-setup/#running-rosplane-sil","title":"Running ROSplane SIL","text":"<p>A controller or a simulated controller can be used to fly the aircraft in simulation. See the <code>README.md</code> file for the <code>rosflight_ros_pkgs</code> package for more information on RC control in simulation.</p> <p></p>"},{"location":"user-guide/concepts/rosplane-setup/#launching","title":"Launching","text":""},{"location":"user-guide/concepts/rosplane-setup/#recommended-method","title":"Recommended Method","text":"<p>A convenience bash script has been included that uses tmux to launch Gazebo, an instance of the ROSflight firmware, and ROSplane. Note that this requires tmux, so you may need to install it with <code>sudo apt install tmux</code>. Run </p><pre><code>./src/rosplane/rosplane/scripts/rosplane_gcs_launch.sh -s -r -a anaconda -b example_bag ~/rosflight_ws\n</code></pre> from the <code>rosflight_ws</code> directory to run a simulation of ROSplane (<code>-s</code>) with a simulated RC transmitter (<code>-r</code>) and the Anaconda aerodynamic and control parameters (<code>-a anaconda</code>), and also to start recording a ROSbag of all the topics (<code>-b example_bag</code>).<p></p> <p>See the script or run  </p><pre><code>~/rosflight_ws/src/rosplane/rosplane/scripts/rosplane_gcs.launch.sh -h\n</code></pre> for more information.<p></p>"},{"location":"user-guide/concepts/rosplane-setup/#alternative-method","title":"Alternative Method","text":"<p>Alternatively, you can run each of the commands in the bash script individually: </p><pre><code># Terminal 1 - Launches Gazebo and a simulated instance of the firmware\nros2 launch rosflight_sim fixedwing.launch.py\n\n# Terminal 2 - Runs rosflight_io configured for SIL to interface with the firmware\nros2 run rosflight_io rosflight_io --ros-args -p udp:=true\n\n# Terminal 3 - Launches rosplane with the Anaconda aerodynamic coefficients\nros2 launch rosplane_sim sim.launch.py aircraft:=anaconda\n</code></pre><p></p> <p>You can also replace the first two commands above with the convenience launch file that does both: </p><pre><code>ros2 launch rosflight_sim fixedwing_sim_io_joy.launch.py aircraft:=anaconda\n</code></pre> Remember to launch ROSplane if you use this method.<p></p>"},{"location":"user-guide/concepts/rosplane-setup/#additional-setup","title":"Additional Setup","text":""},{"location":"user-guide/concepts/rosplane-setup/#recommended-method_1","title":"Recommended Method","text":"<p>If this is your first time launching ROSplane, make sure to run the convenience launch script to initialize the firmware parameters and calibrate the IMU. </p><pre><code>ros2 launch rosflight_sim fixedwing_init_firmware.launch.py\n</code></pre><p></p>"},{"location":"user-guide/concepts/rosplane-setup/#alternative-method_1","title":"Alternative Method","text":"<p>Alternatively, you can run the following commands to initialize firmware parameters and calibrate the IMU. Firmware parameters should first be loaded using </p><pre><code>ros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"filename: ~/rosflight_ws/src/rosflight_ros_pkgs/rosflight_sim/params/fixedwing_firmware.yaml\"\n</code></pre><p></p> <p>The IMU should then be calibrated to remove the random biases generated at startup. Note that the random number generator used to create these biases is seeded with a constant value, so this calibration should only need to be performed once. See the code to change the way these biases are calculated. </p><pre><code>ros2 service call /calibrate_imu std_srvs/srv/Trigger\n</code></pre><p></p> <p>After calibrating, write the parameters to a file using: </p><pre><code>ros2 service call /param_write std_srvs/srv/Trigger\n</code></pre> This command will create a directory named <code>rosflight_memory</code> where the parameters are written. The ROSflight firmware will automatically check if the <code>rosflight_memory</code> directory is present when launched and will use those parameters if available.<p></p> <p>Note</p> <p>The ROSflight firmware will only look for the <code>rosflight_memory</code> directory in the directory where the simulation launch command is run. You must launch <code>rosflight_sim</code> in the same directory to use the saved parameters; otherwise, reload and re-write the parameters.</p>"},{"location":"user-guide/concepts/rosplane-setup/#flying-in-sim","title":"Flying in Sim","text":"<p>Once you have the simulation booted up, use channel 4 of a connected transmitter to arm. If you are using a simulated transmitter, use <code>ros2 service call /toggle_arm std_srvs/srv/Trigger</code> to toggle arm/disarm.</p> <p>After arming, the plane will operate under RC control. Verify that the commands are working and that the aircraft is responding as expected.</p> <p>To fly autonomously, use channel 5 to disable RC override. If using a simulated transmitter, use <code>ros2 service call /toggle_override std_srvs/srv/Trigger</code> to toggle RC override on/off.</p> <p>The plane should then take off or fly autonomously in the simulator!</p> <p>Note</p> <p>The ROSflight firmware requires that the vehicle is armed before disabling RC override. Make sure that the RC override is toggled off before arming. This can be done using the <code>ros2 service call</code> above or an RC switch, if you have one set up.</p>"},{"location":"user-guide/concepts/rosplane-setup/#running-rosplane-on-hardware","title":"Running ROSplane on Hardware","text":"<p>Ensure <code>rosflight_io</code> is running on the companion computer, and that the flight controller is connects to the companion computer.</p> <p>Launch ROSplane using </p><pre><code>ros2 launch rosplane rosplane.launch.py\n</code></pre><p></p> <p>Arm the aircraft using channel 4 of the safety RC transmitter. When ready to let ROSplane take control, use channel 5 of the RC transmitter to disable RC override.</p> <p>Warning</p> <p>Disabling RC override on hardware will turn control over to ROSplane. A safety pilot should always be ready to take control, especially when running untested code.</p>"},{"location":"user-guide/concepts/rosplane-setup/#flying-waypoint-missions-in-sim-and-hardware","title":"Flying Waypoint Missions (in sim and hardware)","text":"<p>Autonomous waypoint missions can easily be flown using ROSplane. The waypoints of a mission are controlled by the <code>path_planner</code> node. These waypoints are sent to the <code>path_manager</code> node. Low level path-following is done by the <code>path_follower</code> node. See \"Small Unmanned Aircraft: Theory and Practice\" by Dr. Randy Beard and Dr. Tim McLain for more information on the architecture. See Path Planning for more information on how to use and tune the path planner, manager, and follower.</p>"},{"location":"user-guide/concepts/rosplane-setup/#adding-waypoints","title":"Adding waypoints","text":""},{"location":"user-guide/concepts/rosplane-setup/#recommended-method_2","title":"Recommended Method","text":"<p>ROSplane initializes with no waypoints added to the <code>path_planner</code>. We recommend using a mission .yaml file (an example mission can be found in <code>rosplane/missions/fixedwing_mission.yaml</code>). Loading the mission can be done using </p> <pre><code>ros2 service call /load_mission_from_file rosflight_msgs/srv/ParamFile \"{filename: &lt;FILENAME&gt;}\"\n</code></pre> <p>where <code>FILENAME</code> is the absolute path to the mission .yaml file. Note that the origin (0,0,0) is placed at the GNSS location where ROSplane was initialized.</p> <p>Note</p> <p>All waypoints must include a valid <code>[X, Y, Z]</code>, <code>va_d</code>, and <code>lla</code> values.</p>"},{"location":"user-guide/concepts/rosplane-setup/#alternative-method_2","title":"Alternative Method","text":"<p>Alternatively, you can add a waypoint one at a time by calling the appropriate service</p> <pre><code>ros2 service call /add_waypoint rosplane_msgs/srv/AddWaypoint \"{w: [X, Y, Z], chi_d: CHI_D, lla: USE_LLA, use_chi: USE_CHI, va_d: VA_D}\"\n</code></pre> <p>where <code>[X, Y, Z]</code> is the NED position of the waypoint from the origin (in meters) OR the GNSS location of the waypoint (LLA), <code>CHI_D</code> is the desired heading at the waypoint, and <code>VA_D</code> is the airspeed at the waypoint. Set the <code>lla</code> field to <code>true</code> if the waypoint <code>[X, Y, Z]</code> field is given in GNSS coordinates and <code>false</code> if given in NED coordinates. Corners in the path are controlled by <code>USE_CHI</code>, where a value of <code>True</code> will cause ROSplane to use a Dubins path planner and a value of <code>False</code> will cause a fillet path planner to be used. Adding waypoints can be done at any time, even after loading from a file.</p> <p>Clearing waypoints can be done using  </p><pre><code>ros2 service call /clear_waypoints std_srvs/srv/Trigger\n</code></pre><p></p>"},{"location":"user-guide/concepts/rosplane-setup/#publishing-waypoints","title":"Publishing Waypoints","text":"<p>The <code>path_planner</code> node automatically publishes a small number of waypoints (default is 3) at the beginning of this mission. This number is controlled by the <code>num_waypoints_to_publish_at_start</code> ROS2 parameter. </p> <p>Additional waypoints can be published using  </p><pre><code>ros2 service call /publish_next_waypoint std_srvs/srv/Trigger\n</code></pre><p></p>"},{"location":"user-guide/concepts/rosplane-setup/#rosplane-gcs-visualization-tools","title":"ROSplane GCS / Visualization Tools","text":"<p>Running and tuning an autopilot requires good tools. These are the tools we use in our workflow to test and debug the performance of our autopilot. Let us know if you have better tools!</p>"},{"location":"user-guide/concepts/rosplane-setup/#plotjuggler","title":"Plotjuggler","text":"<p>Plotjuggler is a tool to visualize data. It is versatile and powerful and can plot many different time series at the same time. It allows you to directly stream ROS2 topics, making it an ideal plotting utility in the field. We use Plotjuggler extensively to tune our control and estimation loops, and to monitor the status of the airplane.</p> <p></p> <p>While Plotjuggler is not a ROS application, Plotjuggler ROS packages have been created. See the Plotjuggler GitHub page for more information or install the ROS2 packages with: </p><pre><code>sudo apt install ros-$ROS_DISTRO-plotjuggler-ros\n</code></pre><p></p> <p>We also use a layout file to automatically open up the plots we are interested in. Use the <code>Import Layout</code> button on the Plotjuggler GUI to import the <code>plotjuggler_layout.xml</code> file.</p>"},{"location":"user-guide/concepts/rosplane-setup/#rviz-waypoint-plotter","title":"RViz Waypoint Plotter","text":"<p>Rviz is a ROS2 tool that can visualize 3D information. We use Rviz to visualize waypoints and the aircraft's performance in achieving those waypoints.</p> <p></p> <p>Run the Rviz publisher and Rviz configuration file with </p><pre><code>ros2 launch rosplane_gcs rosplane_gcs.launch.py\n</code></pre> to launch Rviz and the publisher node. Note that the waypoint publisher from the <code>path_planner</code> node and the subscriber in the publisher node have been set up to work like a \"latched publisher/subscriber\", so you should see the most recently published 20 waypoints, even if you launched RViz after publishing the waypoints.<p></p>"},{"location":"user-guide/concepts/running-simulations-with-rosflight/","title":"ROSflight Sim Overview","text":""},{"location":"user-guide/concepts/running-simulations-with-rosflight/#running-simulations-with-rosflight","title":"Running Simulations with ROSflight","text":"<p>ROSflight is a modular simulation package allowing it to perform software-in-the-loop (SIL) simulations of the ROSflight firmware.</p> <p>Todo</p> <p>add a good image of the sim here.</p>"},{"location":"user-guide/concepts/running-simulations-with-rosflight/#motivation","title":"Motivation","text":"<p>The goals of the ROSflight simulation module (called <code>rosflight_sim</code>) are to</p> <ul> <li>Enable easy and extensive SIL testing of an aircraft,</li> <li>Provide to the sim the exact same software that flies the physical aircraft,</li> <li>Support a variety of simulators out of the box -- from photorealistic to bare-bones, and</li> <li>Enable users to support their own simulator needs.</li> </ul> <p>See the simulator architecture description page for more information on adding your own simulator to <code>rosflight_sim</code>. This page also has more information on the modular structure of <code>rosflight_sim</code>.</p> <p>The detailed launching guide contains information on how to launch the simulation environment, more detailed than what is available in the simulation tutorials.</p> <p>New to ROSflight?</p> <p>If you are new to ROSflight, we recommend that you first start by setting up the simulation environment and learning to use the ROSflight ecosystem. Do this by following the installation for sim guides, and then the ROSflight tutorials.</p> <p>After you do that, you should be ready to start using ROSflight in your own research! Visit the developer guide pages for more specifics on how to use ROSflight for your research.</p>"},{"location":"user-guide/concepts/simulator-architecture/","title":"Simulator Architecture","text":""},{"location":"user-guide/concepts/simulator-architecture/#simulator-architecture","title":"Simulator Architecture","text":"<p>This document describes the architecture of the simulator code. It describes each node's function and role in the simulator, as well as how different visualizers require different configurations of nodes.</p> <p>It also details what you would need to do to customize the sim to your needs.</p> <p>Prerequisites</p> <p>This guide assumes that you have installed and set up the ROSflightSim, as detailed in the tutorials.</p>"},{"location":"user-guide/concepts/simulator-architecture/#big-picture-sim-architecture","title":"Big Picture - Sim Architecture","text":""},{"location":"user-guide/concepts/simulator-architecture/#design-philosophy","title":"Design Philosophy","text":"<p>The design goal of the simulator is to mimic hardware as closely as possible. This means that the same code that flies on hardware should also be flying the aircraft in sim. This is a essential to ensure that the transition from sim to hardware goes as smoothly as possible.</p> <p>To that end, each module in the simulator mimics a physical module on the aircraft or in the real world. For example, the physical sensors are replaced with a \"simulated sensors\" module, and the physical dynamics are replaced by a \"dynamics\" module. Apart from these simulated modules, the rest of the ROSflight code is the same between hardware and simulation.</p> <p>To best mimic the hardware experience of ROSflight, the SIL plugin actually implements the firmware source code as a library. We just implemented a different \"board layer\" which uses the <code>sil_board</code> functions instead of hardware calls for things like <code>imu_read()</code> and <code>pwm_write()</code>. Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between <code>rosflight_io</code> and the firmware. This means the interface to the SIL plugin is identical to that of hardware. The <code>rosflight_io</code> node is the main gateway to the firmware in simulation, just as it is in hardware.</p> <p>The following table summarizes the correlation between connections in hardware and simulation:</p> Connection Type Hardware Simulation Serial communications to <code>rosflight_io</code> USB / UART UDP RC PPM/SBUS Receiver ROS2 <code>RC</code> topic (<code>rosflight_msgs/RCRaw</code>) Motors PWM Handled by <code>forces_and_moments</code> Sensors SPI/I2C <code>sensors</code> module"},{"location":"user-guide/concepts/simulator-architecture/#architecture","title":"Architecture","text":"<p>The simulator architecture is diagrammed below.</p> Fig 1: Architecture of the simulator. Note that the blue dashed box refers to the only parts that are active when running on hardware, while every module runs in sim. <p>Throughout this guide, we will refer to modules in the simulator. In Fig 1, each module is represented by a green box, and replaces a process or component present on a real, physical system. A detailed description of each module is found below. Each module is implemented as a separate ROS2 node, making the simulator more modular and flexible.</p> <p>The modules communicate with each other via the arrows shown in Fig 1. Most of the time, these arrows refer to publisher/subscriber interfaces between the nodes. Other arrows refer to service calls. Note that not all communication lines are shown. See the code or use <code>rqt_graph</code> for a more complete description of how the simulation nodes communicate with each other.</p> <p>The dashed black box represents <code>rosflight_sim</code>, where the green nodes are all the components of the simulator. The dashed blue box denotes the modules that are the only nodes present when using ROSflight on real hardware. In other words, these blue nodes are still used in sim, but the green nodes are not present when using real hardware.</p> <p>Information separation</p> <p>It is important to note that the blue nodes do not \"know\" that they are in sim, making a more realistic simulator. In other words, the blue nodes depend only on information passed between themselves, so the code is the same in sim as it is on hardware.</p> <p>For example, the <code>rosflight_firmware</code> box (in blue) is located inside the <code>rosflight_sim</code> box, since the <code>sil_board</code> node has an instantiation of the <code>rosflight_firmware</code> object. When the <code>rosflight_firmware</code> code calls functions that usually would interact with physical components on hardware, the <code>sil_board</code> instead calls the corresponding simulated module.</p> <p>One example is the <code>imu_read</code> function. Normally on hardware, the <code>imu_read</code> function reads the IMU data from a buffer that is filled asynchronously over serial by the physical IMU. In sim, however, this IMU data is created by the <code>sensors</code> module, and is sent to the <code>sil_board</code> via a pub/sub interface. Then, when the firmware calls <code>imu_read</code>, the <code>sil_board</code> passes up the simulated information, in the same way that the physical board would have read the data from the serial buffer.</p> <p>In a similar fashion, when the firmware calls <code>pwm_write</code>, instead of writing the PWM command to the servos/ESCs (as is done on hardware), the <code>sil_board</code> instead publishes the PWM commands over the <code>sim/pwm_output</code> topic to the <code>forces_and_moments</code> node.</p> <p>Implications of information separation</p> <p>Separating the flow of information in a realistic manner has some consequences. One such consequence in sim is that there is duplicate information flowing over the ROS2 network.</p> <p>For example, when the <code>sensors</code> module creates IMU data, it is sent over the ROS2 network via a pub/sub interface to the <code>sil_board</code>. When the firmware reads that information via the <code>imu_read</code> function call, it does some processing but ultimately sends that information via MAVlink to <code>rosflight_io</code>. The <code>rosflight_io</code> node then publishes that information on a separate topic to the ROS2 network. Thus, two copies of the same IMU data are sent across the ROS2 network.</p> <p>While having duplicate information is not ideal, it is more important (from our view) that the simulation is realistic--acting the same way as physical hardware, thereby decreasing the cost to transition from sim to hardware.</p> <p>Note also that <code>rosflight_io</code> publishes the IMU data to the ROS2 network since in hardware, users often need to know or plot that information.</p>"},{"location":"user-guide/concepts/simulator-architecture/#flow-of-information","title":"Flow of information","text":"<p>A single simulation loop starts with the <code>sil_board</code> node. The <code>sil_board</code> by default executes a simulation loop when a ROS2 timer fires. This corresponds to a single iteration of the main loop in the ROSflight firmware (see the relevant source code, the <code>run()</code> function).</p> <p>On a tick, the <code>rosflight_firmware</code> code reads sensors when available, performs calculations, communicates over MAVlink, or anything else in the code. Note that most actions in the firmware are on timers, so not everything happens every time <code>sil_board</code> ticks. For example, the GPS sensor only creates information at 5-10 Hz, so it only gets read at that rate, not every time <code>sil_board</code> ticks.</p> <p>During this tick, the <code>rosflight_firmware</code> also communicates with the <code>rosflight_io</code> node using MAVlink. In hardware, this communication happens over a serial connection, but we simulate this serial connection with a UDP connection when in sim.</p> <p>After a tick completes, the <code>sil_board</code> publishes the resulting PWM commands over the <code>sim/pwm_output</code> topic to the <code>forces_and_moments</code> node. The <code>forces_and_moments</code> node first unmixes the PWM commands and then computes the aerodynamic forces and moments acting on the airframe based on motor/prop characteristics and the aerodynamic coefficients of the aircraft. Note that these calculations are only as accurate as the model in the <code>forces_and_moments</code> code.</p> <p>The <code>forces_and_moments</code> node produces forces and moments, which it publishes over the <code>sim/forces_and_moments</code> topic to the <code>dynamics</code> node. The <code>dynamics</code> node then adds other forces, like gravity and any collision forces, and integrates the state of the aircraft using an RK4 integration step. The new truth state is published to whatever node is subscribed to the <code>sim/truth_state</code> topic. Note that the <code>dynamics</code> node also creates and publishes wind truth to the <code>sim/truth_wind</code> topic.</p> <p>The <code>visualizer</code> node refers to the visualizer used, i.e. RViz, Gazebo Classic, HoloOcean, etc. The visualizer usually just subscribes to the true state and adjusts the visualization accordingly.</p> <p>A note on visualizers</p> <p>Remember that different visualizers implement different modules. Gazebo Classic, for example, handles the dynamic integration while the <code>standalone_sim</code> (using RViz as the visualizer) just visualizes the model and the trajectory.</p> <p>The \"visualizer\" box in Fig 1 is therefore a placeholder, since the actual visualizer node might take up more than one module.</p> <p>The <code>sensors</code> module receives the true state data and generates sensor data according to the true state. This sensor data gets sent over various topics (i.e. <code>sim/standalone_sensors/XXX</code>) to the <code>sil_board</code>. RC commands are communicated to the <code>sil_board</code> similarly, where the RC commands are generated by the <code>rc</code> node.</p> <p>Finally, the <code>time_manager</code> node is in charge of regulating the simulation time, and publishes the <code>clock</code> topic to all nodes. Note that if you don't want simulation time to be different than system time, you don't need the <code>time_manager</code> node.</p>"},{"location":"user-guide/concepts/simulator-architecture/#module-descriptions","title":"Module Descriptions","text":"<p>This section has more specific information on what each module does and its responsibilities in <code>rosflight_sim</code>.</p>"},{"location":"user-guide/concepts/simulator-architecture/#time-manager","title":"Time Manager","text":"<p>The <code>time_manager</code> node is in charge of regulating simulation time. In ROS2, every node has a default parameter named <code>use_sim_time</code> (note that you don't have to declare this parameter--it comes by default). By default, this parameter is set <code>false</code>.</p> <p>When <code>use_sim_time == true</code>, however, the node will listen to the <code>clock</code> topic as its internal time source. This means that all timers, calls to <code>get_clock()</code>, or any other time for that node will be based off of the <code>clock</code> topic.</p> <p>ROSflight sim can be run with or without the <code>time_manager</code>. If you are using the <code>time_manager</code>, note that you can toggle pause/play of the simulation using the <code>/time_manager/toggle_pause</code> service call.</p> <p>When to use the <code>time_manager</code></p> <p>The <code>time_manager</code> is really only useful when you care about running faster or slower than real time or pausing and starting the simulation. If you don't care about this, don't run the <code>time_manager</code> node, and don't set the <code>use_sim_time</code> parameter of other nodes to <code>true</code>. This will free up resources otherwise used by the <code>time_manager</code>.</p> <p>The <code>time_manager</code>'s main job is to publish the current time to the <code>clock</code> topic. It needs to publish fast enough so that other timers on other nodes aren't stalled because the <code>clock</code> topic isn't coming fast enough.</p> <p>The <code>time_manager</code> has some built in functionality to enable faster or slower than real time simulations. This is done by configuring the parameters associated with the <code>time_manager</code> node.</p> Parameter name Default value Description <code>default_pub_rate_us</code> 100.0 Default interval the time manager will publish to the <code>clock</code> topic (in microseconds) <code>real_time_multiplier</code> 1.0 Multiplier for configuring faster or slower than real time simulations <p>Pub rate example</p> <p>Let's say I know that the fastest timer in my simulation environment runs at 400 Hz. Thus, that timer has to tick every 2.5 ms. The <code>default_pub_rate</code> parameter therefore needs to be smaller than 2500 so that the timer runs reliably.</p> <p>Note that we have not tested all of the timing intricacies of the <code>clock</code> topic--set it to publish faster than you need and you probably won't run into issues.</p> <p>Real time multiplier example</p> <p>If I want to run a simulation 2 times faster than real time, I would set <code>real_time_multiplier = 2.0</code>. If I wanted to run it 0.5 times as fast as real time, I would set it to 0.5.</p>"},{"location":"user-guide/concepts/simulator-architecture/#sil-board","title":"SIL Board","text":"<p>The <code>sil_board</code> is the simulated version of the physical flight controller. It is composed of two parts: the software-in-the-loop (SIL) board, and a ROS2 wrapper that manages the interfaces with the rest of the simulation.</p> <p>A more accurate image of the <code>sil_board</code> node than what is in Figure 1 can be seen below in Figure 2. This figure is discussed in detail in the following subsections.</p> Fig 2: More accurate description of the SIL board architecture with its two major parts: the ROS2 wrapper and the SIL board. Note that this is pseudocode--the \"variable\" and function names do not necessarily correspond to the actual variable names in the code. <p>Naming</p> <p>In implementation, the ROS2 executable corresponding to the \"ROS2 wrapper\" half of the overall SIL Board module is called <code>sil_board</code>. In this guide, we will refer to the ROS2 wrapper as <code>sil_board_ros</code>, and the actual board implementation as SIL board.</p>"},{"location":"user-guide/concepts/simulator-architecture/#sil-board_1","title":"SIL Board","text":"<p>Important</p> <p>\"Board\" here refers to a module that inherits from \"board.h\", the interface file defining all the functions a physical board must implement in order to run the <code>rosflight_firmware</code>.</p> <p>The SIL board's responsibility is to perform the same tasks as the physical board. It does this by inheriting from \"board.h\", thus implementing all of the same functionality as the board implementations that run on physical hardware.</p> <p>In the implementation of the ROSflight firmware, any <code>firmware</code> object created is passed a reference to a <code>board</code> object (which is an object that inherits from \"board.h\"). This happens the same way in hardware and in simulation. The firmware uses this reference to the <code>board</code> object at the appropriate times to do things like get the current clock time, read sensor information, write motor commands, and so on. In Fig 2, this is shown by the arrows flowing from the \"ROSflight firmware\" box to the \"SIL Board\" box.</p> <p>Thus, the SIL board implements functions like <code>imu_read</code>, <code>gnss_read</code>, <code>rc_read</code>, <code>pwm_write</code>, etc. Since we are in sim, instead of reading from the physical IMU when <code>imu_read()</code> is called, the <code>sil_board</code> loads the IMU data from the information received via subscription to the <code>sensors</code> node, which is responsible for creating the simulated sensor information. Similarly, instead of writing PWM signals to the physical pins, the SIL board publishes those commands to the <code>sim/pwm_output</code> topic, which the <code>forces_and_moments</code> node uses to compute the aerodynamic forces and moments. These publisher/subscriber interfaces are denoted in Fig 2.</p>"},{"location":"user-guide/concepts/simulator-architecture/#ros2-wrapper","title":"ROS2 Wrapper","text":"<p>As shown in Fig 2, the ROS2 wrapper contains:</p> <ul> <li>An instantiation of the ROSflight firmware, which is the same code that runs on the physical flight controller.</li> <li>The SIL board object (discussed previously)</li> <li>The communication link module (not shown in Fig 2)</li> </ul> <p>Its main responsibility is to manage when the ROSflight firmware's <code>run()</code> function gets called.</p> <p>The <code>run()</code> function</p> <p>Remember that this <code>run()</code> function corresponds to a single execution loop of the firmware. In hardware, this <code>run()</code> function runs very fast (~350kHz on some hardware), though not everything in the firmware runs at that same rate since most functionality is hooked to hardware interrupts. It is unnecessary to run it this fast in sim, so we typically run it at the IMU rate, ~400Hz.</p> <p>In the <code>sil_board_ros</code>, the <code>run()</code> function can get called in two ways:</p> <ol> <li>From a ROS2 timer callback, or</li> <li>From a ROS2 service served up by the <code>sil_board_ros</code> node.</li> </ol> <p>Only one of these methods should be used at a time when running the firmware. The timer is used in the standard configuration, as it models what happens in the real hardware. The service server is useful when taking one step of the firmware at a time in order to analyze the effects step by step.</p> <p>The timer frequency can be adjusted using the ROS2 parameter system.</p>"},{"location":"user-guide/concepts/simulator-architecture/#sensors","title":"Sensors","text":"<p>The <code>sensors</code> module is responsible for generating simulated sensor measurements based on the current true state. These sensor measurements are published to the <code>/sim/sensors/XXX</code> topics, where <code>XXX</code> is each sensor, i.e. <code>imu/data</code> or <code>baro</code>, etc.</p> <p>The <code>sensors</code> node adds noise, walk, and biases to each sensor measurement to simulate the real-world data. See the code for more information on how the noise is added.</p> <p>Note that the <code>sensors</code> node subscribes to the <code>sim/forces_and_moments</code> topic (for the IMU measurement), the truth states, and the <code>status</code> topic. The <code>status</code> topic is used to approximate when the motors are spinning so high-frequency noise can be added to the gyros.</p> <p>Also note that the <code>sensors</code> node could have been implemented as a separate node for each sensor. If you are adding a new sensor (e.g. camera), you could either change the <code>sensor</code> source code or create an entirely separate ROS2 node for your sensor.</p>"},{"location":"user-guide/concepts/simulator-architecture/#rc-node","title":"RC node","text":"<p>The <code>rc</code> module is responsible for publishing RC commands to the <code>sil_board</code>. It takes the place of the physical RC receiver in hardware that typically communicates with the flight controller over SBUS or PPM.</p> <p>As described in the ROSflight tutorials and hardware concept pages pages, the <code>rc</code> node supports using a physical joystick or a simulated joystick like VimFly. See the linked documents for more information.</p> <p>If VimFly is not specified and a physical transmitter is not connected when the simulation is launched, it will default to no direct RC control. This means that the arming and RC override functionality (usually performed by switches on the transmitter) need to be done using the below ROS2 service calls: </p><pre><code># Toggle arm\nros2 service call /toggle_arm std_srvs/srv/Trigger\n\n# Toggle RC override\nros2 service call /toggle_override std_srvs/srv/Trigger\n</code></pre><p></p> <p>Note</p> <p>These service calls are only available when neither VimFly nor a physical transmitter are used.</p> <p>Regardless of whether or not a transmitter is connected, the <code>rc</code> node publishes RC data to the <code>/rc</code> topic. Each channel of this data is a value between 1000-2000, corresponding to the pulse width of the PWM signal (in microseconds). As described above, this data is subscribed to by the <code>sil_board</code> directly. RC data does not flow through <code>rosflight_io</code>.</p>"},{"location":"user-guide/concepts/simulator-architecture/#forces-and-moments","title":"Forces and Moments","text":"<p>The <code>forces_and_moments</code> node is responsible for computing the aerodynamic forces and moments based on a model of the aircraft. Other forces like gravity and collision forces are not included in the <code>forces_and_moments</code> node.</p> <p>The <code>forces_and_moments</code> node takes in raw PWM commands published by the <code>sil_board</code> node over the <code>sim/pwm_output</code> topic, computes the forces and moments, and publishes those values over the <code>sim/forces_and_moments</code> topic. These PWM commands correspond to what would be either servo deflections or motor throttle values on the physical aircraft. To compute the forces and moments generated by those actuator commands, we need to convert the PWM commands into inputs used by our model.</p>"},{"location":"user-guide/concepts/simulator-architecture/#fixedwing","title":"Fixedwing","text":"<p>For fixedwing aircraft, our aerodynamic model is the model proposed in Small Unmanned Aircraft: Theory and Practice by Beard and McLain. It takes in 4 commands, \\delta_a, \\delta_e, \\delta_r, \\in [-1,1] and \\delta_t \\in [0,1], corresponding to aileron, elevator, rudder servo commands, and throttle setting, respectively. Thus, we need to convert the relevant PWM commands on the corresponding channels into these four servo and throttle setpoints.</p> <p>For the \"standard\" airframe this is trivial, since the standard airframe maps a single PWM command to one of the 4 inputs to our model. We just need to know what PWM channels correspond to which servo, and then convert the PWM command to within the correct range (i.e. [-1,1] or [0,1]).</p> <p>For a non-standard airframe (i.e. vtail, like the RMRC Anaconda), the information sent by the firmware over the <code>pwm_output</code> topic does not correspond to the \"standard\" inputs required by our model. This means we first have to unmix the actual PWM commands to get the equivalent \"standard\" commands.</p> <p>The <code>forces_and_moments</code> node accomplishes this by querying the <code>sil_board</code> node through <code>rosflight_io</code> to determine the current values of the mixer. It saves the mixer and unmixes the input PWM commands back to the \"standard\" commands. We then can use our aerodynamic model to compute the forces and torques.</p> <p>This process is shown in Fig 3.</p> Fig 3: Flow of information through the <code>forces_and_moments</code> node. The \\delta_{r1} and \\delta_{r2} values in the data of the <code>/sim/pwm_output</code> section refer to the right and left ruddervator commands used for a vtail aircraft. Note how the mixer is used in two places. <p>Note</p> <p>We could skip all the mixing and unmixing and subscribe directly to the incoming \"standard\" commands before they go into the <code>sil_board</code> node. This, however, reduces the realism of the simulator, since it neglects any changes that could have been made by the firmware to those commands.</p> <p>Max servo deflection</p> <p>Make sure the <code>max_aileron_deflection_angle</code>, <code>max_elevator_deflection_angle</code>, and <code>max_rudder_deflection_angle</code> parameters are set correctly. This scales the PWM command from [-1, 1] to the actual physical angle used by the aerodynamic model.</p> <p>If these are incorrect, the simulated aircraft will behave very differently than the physical one.</p>"},{"location":"user-guide/concepts/simulator-architecture/#multirotors","title":"Multirotors","text":"<p>The model used for the multirotor is simpler than the fixedwing aerodynamic model. It consists of a model of the motor and propeller as well as some drag parameters.</p> <p>Since each PWM command from the firmware maps directly to a single motor, we don't have to unmix the commands to compute the forces and moments. Instead, we use the position and direction of the rotors to directly compute the forces and moments using the motor/prop equations. More information on these equations can be found in chapters 4 and 14 of Small Unmanned Aircraft: Theory and Practice.</p> <p>However, we do need to accurately set the positions of the motors. This is done through the <code>rotor_dists</code>, <code>rotor_radial_angles</code>, and <code>rotor_rotation_directions</code> parameters of the <code>forces_and_moments</code> node.</p>"},{"location":"user-guide/concepts/simulator-architecture/#dynamics","title":"Dynamics","text":"<p>The <code>dynamics</code> node is responsible for maintaining the true state of the vehicle and for adding environmental effects. It can be thought of as the \"world node\", since it is the node that implements physical phenomena like gravity, collisions, state integration, etc.</p> <p>Note</p> <p>At the time of writing, collisions have not been added to the <code>dynamics</code> node. If you are interested in fixing this, please see the GitHub issue.</p> <p>The <code>dynamics</code> node subscribes to the <code>sim/forces_and_moments</code> topic and publishes to the <code>sim/truth_state</code> and <code>sim/truth_wind</code> topics. The <code>sim/truth_state</code> topic contains the 19-DoF state for a generic rigid body (3 for position, 4 for quaternion orientation, 6 for angular and linear velocities, 6 for angular and linear accelerations). The <code>sim/truth_wind</code> topic contains a 3-vector for each component of the wind (in the inertial frame).</p> <p>Wind in sim</p> <p>Currently, no wind is generated by default, but a wind model like the one in chapter 4.4 of Small Unmanned Aircraft: Theory and Practice by Beard and McLain.</p>"},{"location":"user-guide/concepts/simulator-architecture/#setting-the-simulation-state","title":"Setting the simulation state","text":"<p>It can be useful to instantiate the simulation at a particular point in state space, to run a particular experiment, to avoid takeoff, and so on.</p> <p>The <code>dynamics</code> node has a service server that allows users to set the simulation state (the 19-DoF state) to whatever value you want, called the <code>dynamics/set_sim_state</code> service. Note that if an estimator is running, it will likely do something crazy if you set the sim state while it is running.</p>"},{"location":"user-guide/concepts/simulator-architecture/#customizing-the-simulator","title":"Customizing the simulator","text":"<p>Because of the modular nature of ROS2, nodes can be swapped out with minimal effort. As long as the inputs and outputs (the ROS2 interfaces, i.e. publishers, subscribers, services) remain the same, the new module should fit in seamlessly with the rest of the simulator.</p>"},{"location":"user-guide/concepts/simulator-architecture/#important-implementation-details","title":"Important implementation details","text":"<p>Each module described above (except for the <code>sil_board</code>) has been implemented as a C++ node with an interface class and a single derived class. For example, the <code>sensors</code> module has an interface class, <code>SensorInterface</code>, which the implemented class, <code>StandaloneSensors</code> inherits from.</p> <p>The interface class defines all of the ROS2 interfaces and the key functions that a derived class must implement for the code to function correctly.</p> <p>Why is it done this way?</p> <p>Designing the architecture in this way defines a \"contract\" in the interface class. If that contract is satisfied (which is enforced by the compiler), then the derived class code will work with the rest of <code>rosflight_sim</code> (assuming, of course, that the code in the derived class is correct).</p> <p>This makes it easier and quicker to create different implementations of the same interface class. For example, the <code>forces_and_moments</code> node has a different implementation of the aerodynamic model for the fixedwing and for the multirotor. Instead of duplicating all of the code for the ROS2 interfaces, we move it to the interface class. Additionally, we require that derived classes implement some key functions like <code>update_forces_and_torques</code>. Thus, for the fixedwing and multirotor forces and moments, all we do is inherit from the interface class and implement the required functions, and we're good to go!</p> <p>The following table lists each module and the corresponding interface class, as well as the functions required by the interface class. These functions are the functionality that you would be required to implement if you were to swap out a module for a different one.</p> Module Interface Required functions Time Manager <code>TimeManagerInterface</code> <code>update_time</code>, <code>get_seconds</code>, <code>get_nanoseconds</code> SIL Board None None Sensors <code>SensorInterface</code> <code>imu_update</code>, <code>imu_temperature_update</code>, <code>mag_update</code>, <code>baro_update</code>, <code>gnss_update</code>, <code>sonar_update</code>, <code>diff_pressure_update</code>, <code>battery_update</code> Forces and Moments <code>ForcesAndMomentsInterface</code> <code>update_forces_and_torques</code>, <code>get_firmware_parameters</code> Dynamics <code>DynamicsInterface</code> <code>apply_forces_and_torques</code>, <code>compute_truth</code>, <code>compute_wind_truth</code> <p>Programming languages</p> <p>The majority of the simulation code is written in C++. If you want to use a different language when replacing a module, you will have to implement the interface class in that language (i.e. Python).</p> <p>In most cases, you should be able to go line by line and replace syntax. Or you could have an LLM do it for you.</p>"},{"location":"user-guide/concepts/simulator-architecture/#example-customizations","title":"Example customizations","text":"Example use case: Different aerodynamic model <p>The aerodynamic model in the forces and moments node is not a high fidelity model, but makes some assumptions in order to simplify the resulting equations. Let's say I wanted to implement a different aerodynamic model in order to increase the fidelity of my simulator.</p> <p>All I would need to do would be to create a new class that inherits from the forces and moments interface class (<code>ForcesAndMomentsInterface</code>), which handles the ROS2 interfaces and defines the functions that my forces and moments node needs to have. All I do is then</p> <ol> <li>implement those functions with my custom aerodynamic model,</li> <li>add it to the <code>CMakeLists.txt</code> (so that it is built),</li> <li>add it to the launch file instead of the default <code>forces_and_moments</code> node, and I'm done!</li> </ol> Example use case: JSBsim <p>JSBsim is an open-source, widely used flight dynamics software. For example, both Ardupilot and PX4 both support JSBsim in their simulation envirnoments. This is an example of how JSBsim could be integrated into ROSflight for better aerodynamics.</p> <p>JSBsim would replace both the <code>forces_and_moments</code> and the <code>dynamics</code> nodes. The first step would be to combine the interface classes for both modules into a single ROS2 wrapper. The next step would be to incorporate the JSBsim API into that ROS2 wrapper. Remember that as long as the inputs (<code>sim/forces_and_moments</code> topic) and outputs (<code>sim/truth_state</code>) are correct, it will work with the rest of ROSflight!</p>"},{"location":"user-guide/concepts/simulator-architecture/#node-configuration-for-the-different-visualizers","title":"Node configuration for the different visualizers","text":"<p>This section describes how each visualizer natively supported by ROSflight uses the different modules described above.</p>"},{"location":"user-guide/concepts/simulator-architecture/#standalone-sim","title":"Standalone Sim","text":"<p>The \"standalone sim\" is a lightweight version of the simulator that uses ROS2 RViz as the visualization engine (i.e. to visualize the 3D flight path of the vehicle).</p> Fig 4: Standalone sim software modules <p>The standalone simulator uses every module described above and optionally uses the <code>standalone_time_manager</code> to manage the simulation time.</p>"},{"location":"user-guide/concepts/simulator-architecture/#gazebo-classic","title":"Gazebo Classic","text":"<p>Gazebo Classic is a (now EOL'd) robotic simulator. It was previously supported by ROSflight, so it is supported now. However, it currently does not work on versions of above ROS2 Humble, and should be replaced with Gazebo (the currently maintained version of Gazebo). In this guide, we often refer to \"Gazebo Classic\" as Gazebo.</p> Fig 4: Standalone sim software modules <p>Gazebo uses plugins to interface with Gazebo world attributes. Furthermore, Gazebo handles dynamic integration internally, meaning we don't have to do it. Thus, the dynamics node is written as a plugin to Gazebo, and only manages publishing the true state and the true wind state.</p> <p>Also note that Gazebo publishes the <code>/clock</code> topic, so the <code>standalone_time_manager</code> should not be used with Gazebo. Additionally, the Gazebo node only publishes this topic at ~10Hz, which is too slow for most applications (especially the sensors). Thus, we recommend not setting the <code>use_sim_time</code> parameter to true when using Gazebo, or you will get timing errors.</p>"},{"location":"user-guide/concepts/simulator-architecture/#holoocean","title":"HoloOcean","text":"<p>HoloOcean is a photorealistic simulator built off of Unreal Engine 5.</p> Fig 4: Standalone sim software modules <p>The structure of HoloOcean is very similar to the standalone simulator, and can be used identically. HoloOcean can do much more (e.g. dynamic integration or other sensors), and would require the user to modify relevant ROSflight sim nodes. Camera nodes could be added by creating a separate ROS2 publisher with the camera data (instead of adding the camera to the sensor module).</p> <p>Currently, we use the HoloOcean API to \"teleport\" the model between the true states computed by the dynamics node.</p>"},{"location":"user-guide/concepts/simulator-architecture/#adding-your-own-visualizer","title":"Adding your own visualizer","text":"<p>Though ROSflight supports three different simulators out of the box, we anticipate that users may need to use ROSflight with their own simulator. The process for using ROSflight with your own simulator follows the same principles as the customization section above.</p> <p>The first step is to determine what modules in the standalone simulator you can leverage without modification. Then, determine any modules that need to be merged with your visualizer (e.g. the dynamics node or others).</p> <p>When merging the ROSflight modules into your code, make sure to maintain the same ROS2 interfaces (publishers, subscribers, services, etc.). If you do, it is likely the rest of the ROSflight simulation will \"just work\" with your implementation.</p> <p>Happy simulating! \u2708\ufe0f</p>"},{"location":"user-guide/installation/installation-hardware/","title":"Installation on Hardware","text":""},{"location":"user-guide/installation/installation-hardware/#software-installation-for-hardware","title":"Software Installation for Hardware","text":"<p>This guide is meant for users preparing to conduct hardware flight experiments, not just simulation. For the simulation guide, see Software Installation for Sim. Note that these two installation guides have minor differences.</p> <p>The first step to get started with ROSflight will be to set up and install the necessary dependencies and software. On hardware, we need to set up two devices: the companion computer and the flight controller. For more information on the difference between these two devices, see the overview page.</p> <p>Starting in sim</p> <p>If you haven't done so yet, we recommend setting up the simulation environment first before getting started with hardware. The simulation environment makes it easier to get familiar with the ROSflight ecosystem without needing to debug any potential hardware issues.</p>"},{"location":"user-guide/installation/installation-hardware/#overview","title":"Overview","text":"<p>We will need to install these packages on the companion computer:</p> <ul> <li>ROS2</li> <li>ROSflightIO</li> <li>ROScopter</li> <li>ROSplane</li> </ul> <p>We will install just the firmware on the flight controller.</p> <p>Note</p> <p>You probably don't need both ROSplane and ROScopter. If that is the case, just install the one that makes sense for your application.</p>"},{"location":"user-guide/installation/installation-hardware/#installing-ros2","title":"Installing ROS2","text":"<p>Unsuprisingly, ROS2 is a required dependency for ROSflight. You can do this with a native installation of ROS2 or by following the ROSflight Docker guide. To install ROS2 natively, check out the official ROS2 Installation page for details.</p> <p>If you don't plan to run simulations or GUI applications on your companion computer, <code>ros-&lt;ros-distro&gt;-ros-base</code> can be used instead of <code>ros-&lt;ros-distro&gt;-desktop</code>.</p> <p>Note</p> <p>ROSflight currently officially supports only LTS versions of ROS2, so ROS2 Humble running on Ubuntu 22.04 or ROS2 Jazzy running on Ubuntu 24.04. If you want to run a different version of ROS2, some of the below instructions may not work. ROS2 Rolling is not fixed-release and is therefore not officially supported. </p>"},{"location":"user-guide/installation/installation-hardware/#companion-computer-setup","title":"Companion Computer Setup","text":"<p>Do the following on your companion computer.</p> <ol> <li> <p>Create your ROSflight workspace:     </p><pre><code>mkdir -p ~/rosflight_ws/src\n</code></pre><p></p> </li> <li> <p>Clone the <code>rosflight_ros_pkgs</code> repository, as well as <code>roscopter</code> and <code>rosplane</code>:     </p><pre><code>cd ~/rosflight_ws/src\ngit clone https://github.com/rosflight/rosflight_ros_pkgs --recursive\ngit clone https://github.com/rosflight/roscopter\ngit clone https://github.com/rosflight/rosplane\n</code></pre><p></p> <p>File structure</p> <p>Your ROSflight workspace file structure should now look like </p><pre><code>rosflight_ws/\n  \u2514\u2500\u2500 src/\n      \u251c\u2500\u2500 roscopter/\n      \u251c\u2500\u2500 rosflight_ros_pkgs/\n      \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> <li> <p>Install dependencies using <code>rosdep</code>:</p> <p>Warning</p> <p>Make sure you have properly sourced the ROS2 environment in the terminal you are working in, or the <code>rosdep</code> and <code>colcon</code> commands will fail. </p><pre><code># Replace &lt;ros-distro&gt; with your ROS2 distro (probably 'humble' or 'jazzy')\nsource /opt/ros/&lt;ros-distro&gt;/setup.bash\n</code></pre><p></p> <p>Tip</p> <p>If you are not planning on using the simulation environment on your companion computer, you can delete the <code>rosflight_sim</code> package safely. This will speed up build times. </p><pre><code>cd ~/rosflight_ws/src/rosflight_ros_pkgs\nrm -rf rosflight_sim\n</code></pre><p></p> <pre><code>cd ~/rosflight_ws\nsudo rosdep init\nrosdep update\nrosdep install --from-path . -y --ignore-src\n</code></pre> <p>If you have already done <code>sudo rosdep init</code> previously, it will return an error. In most cases, you do not need to reinitialize.</p> </li> <li> <p>Build using the colcon build tool:     </p><pre><code>cd ~/rosflight_ws\ncolcon build\n</code></pre><p></p> <p>After the build, you should see output similar to: </p><pre><code>---\nFinished &lt;&lt;&lt; roscopter [1min 34s]\nStarting &gt;&gt;&gt; rosflight_pkgs\nFinished &lt;&lt;&lt; rosflight_pkgs [0.42s]                        \n\nSummary: 18 packages finished [1min 44s]\n4 packages had stderr output: roscopter rosflight_io rosplane rosplane_extra\n</code></pre> There may be warnings or <code>stderr</code> output, but as long as each package says <code>Finished</code>, the build was successful.<p></p> <p>Resource Usage</p> <p>Building the whole repository at once uses a lot of memory. If you get build errors, try running the build command with the following argument: </p><pre><code>colcon build --executor sequential\n</code></pre><p></p> <p>Success</p> <p>The <code>colcon</code> build tool will create <code>build</code>, <code>log</code>, and <code>install</code> folders, even if the build fails. Your ROSflight workspace file structure should now look like </p><pre><code>rosflight_ws/\n  \u251c\u2500\u2500 build/\n  \u251c\u2500\u2500 install/\n  \u251c\u2500\u2500 log/\n  \u2514\u2500\u2500 src/\n      \u251c\u2500\u2500 roscopter/\n      \u251c\u2500\u2500 rosflight_ros_pkgs/\n      \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> <li> <p>Add the source files to your <code>.bashrc</code> (so you don't have to source the files every time you open a terminal):     </p><pre><code># add the sourcing commands to your .bashrc. Replace bash with zsh if using zsh.\necho \"source /opt/ros/humble/setup.bash\" &gt;&gt; $HOME/.bashrc\necho \"source $HOME/rosflight_ws/install/setup.bash\" &gt;&gt; $HOME/.bashrc\n\nsource $HOME/.bashrc\n</code></pre>     If you are using a different ROS 2 distribution, replace <code>humble</code> with your distro name.<p></p> <p>Make sure to reopen current terminals after adding these commands to your <code>.bashrc</code> file (or run <code>source $HOME/.bashrc</code> file in every open terminal).</p> </li> </ol>"},{"location":"user-guide/installation/installation-hardware/#flight-controller-setup","title":"Flight controller setup","text":"<p>ROS2 will not be installed on the flight controller unit (FCU). We will only need to build and flash the FCU with the <code>rosflight_firmware</code>.</p> <p>See the flight controller guide for instructions on how to do this.</p>"},{"location":"user-guide/installation/installation-hardware/#next-steps","title":"Next Steps","text":"<p>At this point, you have successfully installed ROS2 and set up ROSflight on the companion computer, including all required dependencies.</p> <p>For guidance on running simulations, see the tutorials.</p>"},{"location":"user-guide/installation/installation-sim/","title":"Installation for Sim","text":""},{"location":"user-guide/installation/installation-sim/#software-installation-for-sim","title":"Software Installation for Sim","text":"<p>The first step to get started with ROSflight will be to set up and install the necessary dependencies and software. This guide will detail how to install these packages as if preparing to run a simulation. This means we will cover setting up the following packages on either the companion computer or any other Linux computer:</p> <ul> <li>ROS2</li> <li>ROSflight Sim (and other software from <code>rosflight_ros_pkgs</code>)</li> <li>ROScopter</li> <li>ROSplane</li> </ul> <p>We will not cover flashing firmware or other hardware-specific instructions. For instructions on setting up the software on real hardware, see the hardware installation guide.</p> <p>Note</p> <p>You probably don't need both ROSplane and ROScopter. If that is the case, just install the one that makes sense for your application.</p>"},{"location":"user-guide/installation/installation-sim/#installing-ros2","title":"Installing ROS2","text":"<p>Unsuprisingly, ROS2 is a required dependency for ROSflight. You can do this with a native installation of ROS2 or by following the ROSflight Docker guide. To install ROS2 natively, check out the official ROS2 Installation page for details.</p> <p>If you don't plan to run simulations or GUI applications on your companion computer, <code>ros-&lt;ros-distro&gt;-ros-base</code> can be used instead of <code>ros-&lt;ros-distro&gt;-desktop</code>.</p> <p>Note</p> <p>ROSflight currently officially supports only LTS versions of ROS2, so ROS2 Humble running on Ubuntu 22.04 or ROS2 Jazzy running on Ubuntu 24.04. If you want to run a different version of ROS2, some of the below instructions may not work. ROS2 Rolling is not fixed-release and is therefore not officially supported. </p>"},{"location":"user-guide/installation/installation-sim/#installing-rosflight-roscopter-and-rosplane","title":"Installing ROSflight, ROScopter, and ROSplane","text":"<p>In this section, when we refer to ROSflight we are referring to the <code>rosflight_ros_pkgs</code> repository, which includes the <code>rosflight_sim</code>, <code>rosflight_io</code>, and <code>rosflight_firmware</code> modules.</p> <p>In the hardware installation guide, each of these packages will be installed separately, or not at all.</p> <ol> <li> <p>Create your ROSflight workspace:     </p><pre><code>mkdir -p ~/rosflight_ws/src\n</code></pre><p></p> </li> <li> <p>Clone the <code>rosflight_ros_pkgs</code> repository, as well as <code>roscopter</code> and <code>rosplane</code>:     </p><pre><code>cd ~/rosflight_ws/src\ngit clone https://github.com/rosflight/rosflight_ros_pkgs --recursive\ngit clone https://github.com/rosflight/roscopter\ngit clone https://github.com/rosflight/rosplane\n</code></pre><p></p> <p>File structure</p> <p>Your ROSflight workspace file structure should now look like </p><pre><code>rosflight_ws/\n  \u2514\u2500\u2500 src/\n      \u251c\u2500\u2500 roscopter/\n      \u251c\u2500\u2500 rosflight_ros_pkgs/\n      \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> <li> <p>Install dependencies using <code>rosdep</code>:</p> <p>Warning</p> <p>Make sure you have properly sourced the ROS2 environment in the terminal you are working in, or the <code>rosdep</code> and <code>colcon</code> commands will fail. </p><pre><code># Replace &lt;ros-distro&gt; with your ROS2 distro (probably 'humble' or 'jazzy')\nsource /opt/ros/&lt;ros-distro&gt;/setup.bash\n</code></pre><p></p> <pre><code>cd ~/rosflight_ws\nsudo rosdep init\nrosdep update\nrosdep install --from-path . -y --ignore-src\n</code></pre> <p>If you have already done <code>sudo rosdep init</code> previously, it will return an error. In most cases, you do not need to reinitialize.</p> </li> <li> <p>Build using the colcon build tool:     </p><pre><code>cd ~/rosflight_ws\ncolcon build\n</code></pre><p></p> <p>After the build, you should see output similar to: </p><pre><code>---\nFinished &lt;&lt;&lt; roscopter [1min 34s]\nFinished &lt;&lt;&lt; rosflight_sim [1min 35s]                                \nStarting &gt;&gt;&gt; rosflight_pkgs\nFinished &lt;&lt;&lt; rosflight_pkgs [0.42s]                        \n\nSummary: 18 packages finished [1min 44s]\n4 packages had stderr output: roscopter rosflight_io rosplane rosplane_extra\n</code></pre> There may be warnings or <code>stderr</code> output, but as long as each package says <code>Finished</code>, the build was successful.<p></p> <p>Resource Usage</p> <p>Building the whole repository at once uses a lot of memory. If you get build errors, try running the build command with the following argument: </p><pre><code>colcon build --executor sequential\n</code></pre><p></p> <p>Success</p> <p>The <code>colcon</code> build tool will create <code>build</code>, <code>log</code>, and <code>install</code> folders, even if the build fails. Your ROSflight workspace file structure should now look like </p><pre><code>rosflight_ws/\n  \u251c\u2500\u2500 build/\n  \u251c\u2500\u2500 install/\n  \u251c\u2500\u2500 log/\n  \u2514\u2500\u2500 src/\n      \u251c\u2500\u2500 roscopter/\n      \u251c\u2500\u2500 rosflight_ros_pkgs/\n      \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> <li> <p>Add the source files to your <code>.bashrc</code> (so you don't have to source the files every time you open a terminal):     </p><pre><code># add the sourcing commands to your .bashrc. Replace bash with zsh if using zsh.\necho \"source /opt/ros/humble/setup.bash\" &gt;&gt; $HOME/.bashrc\necho \"source $HOME/rosflight_ws/install/setup.bash\" &gt;&gt; $HOME/.bashrc\n\nsource $HOME/.bashrc\n</code></pre>     If you are using a different ROS 2 distribution, replace <code>humble</code> with your distro name.<p></p> <p>Make sure to reopen current terminals after adding these commands to your <code>.bashrc</code> file (or run <code>source $HOME/.bashrc</code> file in every open terminal).</p> </li> </ol>"},{"location":"user-guide/installation/installation-sim/#next-steps","title":"Next Steps","text":"<p>At this point, you have successfully installed ROS2 and set up the ROSflight simulation environment, including all required dependencies. Your workspace is built and ready to run simulations with ROSflight, ROScopter, or ROSplane. The next step is to launch a simulation scenario or integrate your own simulated vehicle.</p>"},{"location":"user-guide/installation/using-docker-with-rosflight/","title":"Using Docker with ROSflight","text":""},{"location":"user-guide/installation/using-docker-with-rosflight/#using-docker-with-rosflight","title":"Using Docker with ROSflight","text":"<p>If you aren't running a compatible version of Linux for ROS2, don't want to make changes to your system, want to be able to easily switch between ROS verions, or just want to containerize your applications, then you can use Docker containers.</p> <p>Docker works by running self-contained systems called containers, which act kind of like a separate computer system but without all the overhead of a full virtual machine. Docker containers are based on Docker images, which provide the initial operating system, files, and programs for the Docker container. Fortunately, the developers of ROS provide Docker images for nearly all versions of ROS, which makes it very easy to get any version of ROS up and running on your system very quickly.</p> <p>Docker Tutorials</p> <p>This guide is not a Docker tutorial. There are a lot of great tutorials and resources for learning what Docker is and how to use it. For more information on Docker, see the Docker docs.</p> <p>In this section, we will focus explicitly on how we use our Docker containers to set up a simulation environment, with some explanation of what we are doing.</p> <p>Docker on Windows</p> <p>If you are using Docker on Windows natively, be aware that GUI tools may not work. We have not tested GUI applications while using a Docker container in WSL. GUI applications in WSL (without Docker) work fine with a \"native\" installation of ROS2.</p> <p>Using Docker instead of a native installation</p> <p>If you choose to use Docker, you will need to be attached to your Docker container any time you run ROS2 commands in the following tutorials.</p> <p>Note also that we have set up the container so that the build, install, log, and source files are mounted from the host system to the container, which enables you to have changes and builds that are persistent across Docker sessions.</p>"},{"location":"user-guide/installation/using-docker-with-rosflight/#installing-docker","title":"Installing Docker","text":"<p>To get started, install Docker Engine, sometimes referred to as Docker server. You can install the desktop version (Docker Desktop), but just the engine works fine. Make sure you also have the <code>docker compose</code> utility installed.</p> <p>You can check by running <code>docker compose</code> in a terminal.</p>"},{"location":"user-guide/installation/using-docker-with-rosflight/#building","title":"Building","text":"<p>We have provided the Docker files that we use here.</p> <ol> <li> <p>Follow the steps 1-2 from the sim installation guide to set up the file structure.     It should look like:     </p><pre><code>rosflight_ws/\n    \u2514\u2500\u2500 src/\n        \u251c\u2500\u2500 roscopter/\n        \u251c\u2500\u2500 rosflight_ros_pkgs/\n        \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> <li> <p>Navigate to the <code>rosflight_ws</code> directory:     </p><pre><code>cd ~/rosflight_ws\n</code></pre><p></p> </li> <li> <p>Build the Docker container:     </p><pre><code>docker compose -f src/rosflight_ros_pkgs/docker/compose.yaml build\n</code></pre><p></p> <p>Filepaths</p> <p>Here we use the build and other <code>docker compose</code> commands from the <code>rosflight_ws</code> directory. You can run all these commands from the <code>src/rosflight_ros_pkgs/docker</code> directory (or any other directory), but make sure to update the relative paths appropriately.</p> </li> </ol>"},{"location":"user-guide/installation/using-docker-with-rosflight/#running-the-docker-container","title":"Running the Docker container","text":"<p>To run the Docker container, we will first start the container in the background with: </p><pre><code>docker compose -f src/rosflight_ros_pkgs/docker/compose.yaml up -d\n</code></pre><p></p> <p>Attach to the container with: </p><pre><code>docker compose -f src/rosflight_ros_pkgs/docker/compose.yaml exec rosflight zsh\n</code></pre><p></p> <p>Tip</p> <p>You can attach as many times as you want from different terminals!</p>"},{"location":"user-guide/installation/using-docker-with-rosflight/#building-the-rosflight-workspace","title":"Building the ROSflight workspace","text":"<ol> <li> <p>Attach to the container using the above commands.</p> </li> <li> <p>Build the packages in <code>rosflight_ws</code> using the colcon build tool:     </p><pre><code>cd ~/rosflight_ws\ncolcon build\n</code></pre><p></p> <p>After the build, you should see output similar to: </p><pre><code>---\nFinished &lt;&lt;&lt; roscopter [1min 34s]\nStarting &gt;&gt;&gt; rosflight_pkgs\nFinished &lt;&lt;&lt; rosflight_pkgs [0.42s]                        \n\nSummary: 18 packages finished [1min 44s]\n4 packages had stderr output: roscopter rosflight_io rosplane rosplane_extra\n</code></pre> There may be warnings or <code>stderr</code> output, but as long as each package says <code>Finished</code>, the build was successful.<p></p> <p>Resource Usage</p> <p>Building the whole repository at once uses a lot of memory. If you get build errors, try running the build command with the following argument: </p><pre><code>colcon build --executor sequential\n</code></pre><p></p> <p>Success</p> <p>The <code>colcon</code> build tool will create <code>build</code>, <code>log</code>, and <code>install</code> folders, even if the build fails. Your ROSflight workspace file structure should now look like </p><pre><code>rosflight_ws/\n  \u251c\u2500\u2500 build/\n  \u251c\u2500\u2500 install/\n  \u251c\u2500\u2500 log/\n  \u2514\u2500\u2500 src/\n      \u251c\u2500\u2500 roscopter/\n      \u251c\u2500\u2500 rosflight_ros_pkgs/\n      \u2514\u2500\u2500 rosplane/\n</code></pre><p></p> </li> </ol> <p>Warning</p> <p>During testing, we found some strange behavior with ROS when running a GUI enabled container on a system with ROS already installed. If you need a GUI enabled system, try to do so on a system without ROS installed (or at the very least avoid sourcing/using ROS on your system). Also avoid having multiple GUI enabled containers running at once.</p>"},{"location":"user-guide/roscopter/roscopter-controller/","title":"ROScopter Controller","text":""},{"location":"user-guide/roscopter/roscopter-controller/#controller","title":"Controller","text":""},{"location":"user-guide/roscopter/roscopter-controller/#responsibility","title":"Responsibility","text":"<p>The responsibility of the <code>controller</code> is to</p> <ol> <li>produce low-level commands from high-level commands</li> <li>Maintain a state machine to manage autonomous takeoff</li> </ol>"},{"location":"user-guide/roscopter/roscopter-controller/#interface-with-roscopter","title":"Interface with ROScopter","text":"Reference diagram of the ROScopter architecture <p>The <code>controller</code> interfaces with the rest of ROScopter using publishers and subscribers.</p> Subscriber name Message type Description <code>estimated_state</code> <code>roscopter_msgs/State</code> Estimated state for the vehicle (needs everything) <code>status</code> <code>rosflight_msgs/Status</code> Status message from the ROSflight firmware (needs to know when RC control is active or when the vehicle is armed) <code>high_level_command</code> <code>roscopter_msgs/ControllerCommand</code> Input controller command Publisher name Message type Description <code>command</code> <code>rosflight_msgs/Command</code> Output commands to the downstream ROSflight firmware controller <p>To summarize, the ROScopter <code>controller</code> takes in the estimated state and high-level command setpoints and computes low-level command setpoints that are sent to the ROSflight firmware on the flight control unit. Note that the output command messages are sent to ROSflight firmware (on the flight control unit) via the <code>rosflight_io</code> node.</p>"},{"location":"user-guide/roscopter/roscopter-controller/#using-the-controllerimplementation-details","title":"Using the <code>controller</code>/implementation details","text":"<p>Many different control schemes exist for multirotor vehicles. Since application code (i.e. code that you write) has slightly different outputs, the ROScopter controller has the architecture shown in the following figure.</p> Diagram of the ROScopter controller architecture and how the cascaded controller chain interacts with the ROSflight firmware controller <p>The above figure shows the cascaded architecture of the ROScopter controller. In this diagram, the arrows represent how one controller output feeds into the next controller's input, all the way down to one of three basic control types. For example, if the user passes control setpoints corresponding to Controller 0 (inertial-frame north, east, down position and yaw commands), Controller 0 converts them to Controller 3 inputs, which then converts to Controller 2 inputs, and so on.</p> <p>The following table describes the inputs to each type of controller.</p> Number Name Description of reference commands 0 NED-Pos Yaw Inertial north, east, down (NED) positions and yaw 1 NE-Vel D-Pos YawR Inertial N-E velocities, D position, and yaw rate 2 FRD-Accel YawR Vehicle-1 frame<sup>1</sup> (labeled front-right-down) accelerations and yaw rate 3 NED-Vel YawR Inertial NED velocities and yaw rate 4 NE-Pos D-Vel Yaw Inertial N-E velocities and yaw 5 Roll Pitch Yaw Throttle Roll, pitch, yaw, and throttle 6 Roll Pitch YawR Throttle Roll, pitch, yaw rate, and throttle 7 RollR PitchR YawR Throttle Roll rate, pitch rate, yaw rate, throttle 8 Pass-through Pass-through to ROSflight firmware mixer 9 Roll Pitch Yaw Thrust Roll, pitch, yaw, and thrust to pass-through 10 Roll Pitch YawR Thrust Roll, pitch, yaw rate, and thrust to pass-through 11 RollR PitchR YawR Thrust Roll rate, pitch rate, yaw rate, and thrust to pass-through <p>Reference frames</p> <p>Knowing which reference frame you are sending commands in is essential for safe operation. The <code>NED</code> frame in the table refers to the inertial north, east, and down reference frame.</p> <p>Thus, if I send commands to the controller 1 entrypoint, I am sending inertial north and east velocities and inertial down position, regardless of how the aircraft is oriented.</p> <p>Accelerations (controller 2), however, are in the vehicle 1 frame<sup>1</sup>, which we call the FRD (front-right-down) frame in the above table. Because it is the vehicle 1 frame, front means whichever direction the vehicle is facing (but not that it does not matter how the vehicle is pitched or rolled).</p> <p>All of the roll, pitch, and yaw commands are defined in their usual reference frames.</p> <p>The <code>controller</code>'s cascaded architecture allows users to \"insert\" control commands at many different levels, depending on the needs of their application code. Each insertion point thus produces a different controller chain.</p> <p>Note</p> <p>We'll call the sequence of controllers used as a controller chain.</p> <p>For example, inserting at Controller 4 would have the controller chain of Controller 4 -&gt; Controller 3 -&gt; Controller 2 -&gt; Controller 6.</p> <p>Each insertion point is chosen via the <code>mode</code> field in the <code>roscopter_msgs/ControllerCommand</code> message. Thus, each ROS 2 message determines which controller it inserts at. This means that different controller chains can be chosen at runtime, and can be mixed and matched throughout the flight.</p> <p>Using different controller chains during a flight</p> <p>Since the insertion points are chosen via the <code>mode</code> field in each ROS 2 message sent to the <code>controller</code>, controller chains can be mixed and matched throughout the flight.</p> <p>For example, in the default implementation of ROScopter, the <code>controller</code> inserts commands at Controller 4 during takeoff and Controller 10 during the other portions of the flight.</p> <p>As seen in the above ROScopter <code>controller</code> diagram, the output of the <code>controller</code> node is sent directly to the ROSflight firmware via the <code>rosflight_io</code> node (note that the <code>rosflight_io</code> node is not shown in the diagram). The output of all controller chains needs to be one of the modes that the firmware controller can accept. Thus, the output of the ROScopter controller is one of the following output types: $$     u_\\text{angle} = [\\phi^d, \\theta^d, r^d, \\delta_t^d]^T $$ $$     u_\\text{rate} = [p^d, q^d, r^d, \\delta_t^d]^T $$ $$     u_\\text{pass-through} = [Q_x^d, Q_y^d, Q_z^d, T_z^d]^T $$ where \\phi, \\theta, and \\psi are roll, pitch, and yaw commands, p, q, r are roll rate, pitch rate, and yaw rate, and \\delta_t \\in [0,1] is the throttle setpoint. Q and T are the body-frame torques and forces, respectively.</p>"},{"location":"user-guide/roscopter/roscopter-controller/#controller-state-machine","title":"Controller State Machine","text":"<p>The <code>controller</code> node also has a simple state machine to manage safe takeoff and landing.</p> Diagram of the <code>controller</code>'s state machine. <p>The <code>controller</code> state machine starts in the disarmed state until the user arms the vehicle. Additionally, the state machine requires a valid command setpoint sent to the <code>high_level_command</code> topic. This is determined by the <code>cmd_valid</code> field in the <code>roscopter_msgs/ControllerCommand</code> message definition.</p> <p>The state machine then transitions to takeoff mode, where the vehicle will climb at a constant velocity until it reaches a particular height. Once the vehicle reaches the desired height (within a given threshold), takeoff is considered complete and the vehicle transitions to position hold mode.</p> <p>After a brief pause in position hold mode, the vehicle then enters \"offboard control\" mode, which means that the controller will output control commands to track the commands on the <code>high_level_command</code> topic.</p> <p>During the takeoff and position hold states, the commands sent to the <code>high_level_command</code> topic are overridden. This ensures that the vehicle is at a safe height before attempting to follow any path commands. Note that if the <code>cmd_valid</code> field is set to <code>false</code> in messages from the <code>high_level_command</code> topic, then the offboard control state will transition to position hold.</p> <p>The behavior of the state machine can be configured via the <code>controller</code>'s parameters. This includes the takeoff down velocity, the height the controller will climb to, the threshold that the state machine considers the takeoff waypoint complete, and the time that the state machine will spend in takeoff before transitioning to offboard control mode.</p>"},{"location":"user-guide/roscopter/roscopter-controller/#parameters-and-configuration","title":"Parameters and configuration","text":"<p>The parameters associated with the <code>controller</code> are listed below. Parameters that have notes/special considerations are discussed below the table.</p> Parameter name Parameter type Description <code>equilibrium_throttle</code> <code>double</code> Throttle value required to maintain hover. Between 0-1 <code>gravity</code> <code>double</code> Gravity in m/s^2 <code>mass</code> <code>double</code> Vehicle mass (in kg) <code>max_descend_accel</code> <code>double</code> Maximum descent acceleration. Applies to the acceleration controller <code>max_descend_rate</code> <code>double</code> Maximum down velocity. Applies to the velocity PID controllers <code>max_pitch_deg</code> <code>double</code> Maximum pitch angle (in degrees). Applies to the angle PID controllers. <code>max_pitch_rate_deg</code> <code>double</code> Maximum pitch rate (in degrees/sec). Applies to the rate PID controllers. <code>max_pitch_torque</code> <code>double</code> Maximum pitch torque (in N-m). Applies to the torque controllers. <code>max_roll_deg</code> <code>double</code> Maximum roll angle (in degrees). Applies to the angle PID controllers. <code>max_roll_rate_deg</code> <code>double</code> Maximum roll rate (in degrees/sec). Applies to the rate PID controllers. <code>max_roll_torque</code> <code>double</code> Maximum roll torque (in N-m). Applies to the torque controllers. <code>max_throttle</code> <code>double</code> Maximum allowed throttle setpoint. Should be between 0-1 <code>max_yaw_rate_deg</code> <code>double</code> Maximum yaw rate (in degrees/sec). Applies to the rate PID controllers. <code>max_yaw_torque</code> <code>double</code> Maximum yaw torque (in N-m). Applies to the torque PID controllers. <code>min_altitude_for_attitude_ctrl</code> <code>double</code> Minimum altitude before attitude control. Roll and pitch commands are zero when the vehicle is lower than this number. Helps to reduce crashes on takeoff. <code>min_throttle</code> <code>double</code> Minimum throttle setpoint. Should be between 0-1 <code>takeoff_d_pos</code> <code>double</code> Down position to achieve (in takeoff) before turning control over to the \"offboard control\". <code>takeoff_d_vel</code> <code>double</code> Down velocity during takeoff (until vehicle reaches the <code>takeoff_d_pos</code> position. <code>takeoff_height_threshold</code> <code>double</code> Radius (in m) that the vehicle must achieve around the <code>takeoff_d_pos</code> setpoint before the state machine considers takeoff to be complete. <code>takeoff_landing_pos_hold_time</code> <code>double</code> Time (in seconds) the state machine will hold before switching to offboard control (after takeoff) or landing. Holding for a brief time before switching over helps with stability. <code>tau</code> <code>double</code> Bandwidth of the dirty derivative (for the PID controllers). See the ControlBook. <p>Max/min parameters</p> <p>The parameters associated with max and min values (e.g. <code>max_descend_accel</code>) only apply if the control loop associated with those parameters is run.</p> <p>For example, the <code>max_descend_rate</code> parameter is a saturation limit on the down velocity controller, meaning that the output of the down velocity controller is saturated to never be greater than this number. However, if the velocity controller is not run (meaning a controller lower in the controller chain is used), then the velocity controller will not run and this max velocity limit will not be respected.</p> <p>Please note which control loops you are using before tuning these parameters, as some will not be used based on where you are inserting into the control chain.</p> <p>The <code>max_throttle</code> parameter is usually set to be lower than 1 to reserve some actuator effort for attitude control. The <code>min_throttle</code> parameter is usually set to a value higher than 0 to avoid the motors \"shutting off\" for particular maneuvers.</p> <p>Warning</p> <p>Make sure the <code>mass</code> parameter is correct and that it is the same between all nodes (e.g. the <code>trajectory_follower</code>).</p> <p>The following parameters are listed for completeness. Each of the PID control types from the implementation details section has 3 gains associated with it.</p> <p>Note that the control loops that are used depends on where the high-level command setpoints are inserted into the controller chain. Thus, not all of the PID gains below will need to be tuned when using ROScopter. Make sure to check which gains are used based on where you are inserting command setpoints.</p> Parameter name Parameter name Parameter name Rate to torque <code>pitch_rate_to_torque_kd</code> <code>roll_rate_to_torque_kd</code> <code>yaw_rate_to_torque_kd</code> <code>pitch_rate_to_torque_ki</code> <code>roll_rate_to_torque_ki</code> <code>yaw_rate_to_torque_ki</code> <code>pitch_rate_to_torque_kp</code> <code>roll_rate_to_torque_kp</code> <code>yaw_rate_to_torque_kp</code> Angle to torque <code>pitch_to_torque_kd</code> <code>roll_to_torque_kd</code> <code>yaw_to_torque_kd</code> <code>pitch_to_torque_ki</code> <code>roll_to_torque_ki</code> <code>yaw_to_torque_ki</code> <code>pitch_to_torque_kp</code> <code>roll_to_torque_kp</code> <code>yaw_to_torque_kp</code> Position to velocity <code>pos_n_to_vel_kd</code> <code>pos_d_to_vel_kd</code> <code>pos_e_to_vel_kd</code> <code>pos_n_to_vel_ki</code> <code>pos_d_to_vel_ki</code> <code>pos_e_to_vel_ki</code> <code>pos_n_to_vel_kp</code> <code>pos_d_to_vel_kp</code> <code>pos_e_to_vel_kp</code> Velocity to acceleration <code>vel_d_to_accel_kd</code> <code>vel_e_to_accel_kd</code> <code>vel_n_to_accel_kd</code> <code>vel_d_to_accel_ki</code> <code>vel_e_to_accel_ki</code> <code>vel_n_to_accel_ki</code> <code>vel_d_to_accel_kp</code> <code>vel_e_to_accel_kp</code> <code>vel_n_to_accel_kp</code> Yaw to yaw rate <code>yaw_to_rate_kd</code> <code>yaw_to_rate_ki</code> <code>yaw_to_rate_kp</code> <p>Note</p> <p>Each PID gain is named according to what it takes in and what it returns.</p> <p>For example, the derivative gain for the PID loop that takes in position commands and returns velocity commands in the down direction is called <code>pos_d_to_vel_kd</code>.</p> <ol> <li> <p>R. W. Beard and T. W. McLain, Small Unmanned Aircraft: Theory and Practice, 2012, Princeton University Press, see also https://github.com/byu-magicc/mavsim_public.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/roscopter/roscopter-estimator/","title":"ROScopter Estimator","text":""},{"location":"user-guide/roscopter/roscopter-estimator/#roscopter-estimator","title":"ROScopter Estimator","text":"<p>Warning</p> <p>This  section is still under development. Please check back soon!</p>"},{"location":"user-guide/roscopter/roscopter-overview/","title":"ROScopter Overview","text":""},{"location":"user-guide/roscopter/roscopter-overview/#roscopter-overview","title":"ROScopter Overview","text":"<p>Quick Summary</p> <p>Ready to get fly your code with ROScopter? Start here:</p> <ol> <li>Follow the ROSflight tutorials to set up ROScopter fly waypoint missions in sim.</li> <li>Read through the following ROScopter architecture pages to understand the responsibilities of each node.</li> <li>Find examples of how to customize ROScopter in the Customizing ROSflight page.</li> </ol> <p>ROScopter is a basic multirotor autopilot built on ROS2 for use with the ROSflight flight controller. It is built according to the methods published in Small Unmanned Aircraft: Theory and Practice by Dr. Randy Beard and Dr. Tim McLain.</p> <p>As per the ROSflight vision, ROScopter is not a fully-featured multirotor autopilot, but rather a simple, lean, ROS2-based autopilot.</p> <p>The core ROScopter package is a simple waypoint-following autopilot. This includes a navigation stack (path planner, path manager, and trajectory follower), a controller, and an estimator. This can be seen in the figure below.</p> Diagram of the ROScopter architecture <p>The structure of ROScopter and the nature of ROS2 interfaces allow ROScopter to be modular, allowing you to write and integrate your own code without having to spend as much time working with interfaces and code integration.  Since it is lean, the time to learn and understand the nature of ROScopter should be small compared to other, more featured (but more complex) autopilots. This can improve research productivity, decrease debugging time, and improve the development of novel algorithms.</p>"},{"location":"user-guide/roscopter/roscopter-overview/#core-functionality","title":"Core Functionality","text":"<p>The ROScopter autopilot allows users to fly waypoint missions with an RC safety pilot. These waypoints are defined by desired 3-D locations and a desired heading. The simplicity of this framework allows users to add their own autonomy stacks or mission requirements on top of the ROScopter stack.</p> <p>For example, the <code>path_planner</code> module in the ROScopter navigation stack is responsible for compiling high-level waypoints and sending them to the <code>path_manager</code>. The <code>path_planner</code> by default just takes in user-defined waypoints. Instead of loading these user-defined waypoints, higher levels of autonomy (i.e., vision-based guidance, etc.) could be accommodated by building on top of the ROScopter stack by dynamically feeding the <code>path_planner</code> waypoints.</p> <p>See the ROScopter autonomy stack documentation pages for a detailed description of the default functionality and description of each module.</p>"},{"location":"user-guide/roscopter/roscopter-overview/#using-roscopter-as-is","title":"Using ROScopter as-is","text":"<p>ROScopter's default waypoint-following functionality may be useful to some users. The ROSflight tutorials walk users through setting up ROSflight and ROScopter in sim, all the way through flying waypoint missions. Follow those tutorials first to get a feel for the default ROScopter behavior and workflow before you start making your own changes to the autonomy stack.</p> <p>A detailed description of the ROScopter autonomy stack and each module is found in the ROScopter architecture pages.</p>"},{"location":"user-guide/roscopter/roscopter-overview/#customizing-roscopter","title":"Customizing ROScopter","text":"<p>ROScopter's default functionality may not be sufficient for many users. Because of this, ROScopter has been designed to be understandable, modular, and customizable.</p> <p>The customizing ROflight page describes how ROScopter is meant to be modified to assist in your research. The page also includes examples and scenarios where each node can be modified, removed, or combined to accomplish different tasks.</p>"},{"location":"user-guide/roscopter/roscopter-overview/#roscopter-architecture-overview","title":"ROScopter Architecture Overview","text":"<p>Warning</p> <p>The following guides assume at least basic knowledge of ROS 2. See the ROS 2 tutorials if you have questions about the terminology in the following sections.</p> <p>As seen in the figure, the flow of information through ROScopter cascades from module to module, with the estimator module feeding required information to all modules. Each box in the figure represents a separate module or ROS 2 node that interfaces over the ROS 2 network using publishers, subscribers, and service calls.</p> <p>In the default configuration of ROScopter, users supply waypoints to the <code>path_planner</code>, which then sends waypoints to the <code>path_manager</code>, which sends trajectory commands to the <code>trajectory_follower</code>. The <code>controller</code> receives control setpoints from the <code>trajectory_follower</code> and sends those commands to the flight control unit (FCU) via the <code>rosflight_io</code> node.</p> <p>Each module is described in detail in the following sections.</p> <p>Tip</p> <p>For any ROS 2 interface definition in the following sections (message/service definition, etc.), you can find the message definition using  </p><pre><code>ros2 interface show &lt;interface type&gt;\n</code></pre><p></p>"},{"location":"user-guide/roscopter/roscopter-path-manager/","title":"ROScopter Path Manager","text":""},{"location":"user-guide/roscopter/roscopter-path-manager/#path-manager","title":"Path Manager","text":""},{"location":"user-guide/roscopter/roscopter-path-manager/#responsibility","title":"Responsibility","text":"<p>The responsibility of the ROScopter <code>path_manager</code> is:</p> <ol> <li>Take waypoints published by the <code>path_planner</code> and produce a trajectory between waypoints, and</li> <li>Monitor waypoint completion/switching to the next leg. </li> </ol>"},{"location":"user-guide/roscopter/roscopter-path-manager/#interface-with-roscopter","title":"Interface with ROScopter","text":"Reference diagram of the ROScopter architecture <p>The <code>path_manager</code> interfaces with the rest of ROScopter using publishers and subscribers.</p> Subscriber name Message type Description <code>estimated_state</code> <code>roscopter_msgs/State</code> Estimated state for the vehicle (needs position and orientation) <code>waypoints</code> <code>roscopter_msgs/Waypoint</code> Waypoints to manage Publisher name Message type Description <code>trajectory_command</code> <code>roscopter_msgs/TrajectoryCommand</code> Output commanded trajectory <p>To summarize, the <code>path_manager</code> takes in waypoints (from the <code>path_planner</code>) and the estimated state (from the <code>estimator</code>) and computes a desired trajectory, which it publishes on the <code>trajectory_command</code> topic.</p>"},{"location":"user-guide/roscopter/roscopter-path-manager/#using-the-path_managerimplementation-details","title":"Using the <code>path_manager</code>/implementation details","text":"<p>Note</p> <p>In this section, we will refer to the path/trajectory between two waypoints as a \"waypoint leg\" of the mission</p> <p>Given a set of waypoints and the position of the vehicle, the <code>path_manager</code> needs to compute a trajectory to get from one waypoint to the next. We would like trajectory setpoints u_\\text{traj} of the form $$     u_\\text{traj} = [p, \\dot{p}, \\ddot{p}, \\psi, \\dot{\\psi}, \\ddot{\\psi}]^T, $$ where p is the 3-D position, and \\psi is the desired heading. The velocity and acceleration parts are essentially feed-forward terms that can be used by the downstream trajectory follower.</p> <p>Note</p> <p>The following path derivation is very similar to the one in Small Unmanned Aircraft: Theory and Practice, Ch. 14 by Beard and McLain.</p> <p>In the default implementation of ROScopter, the path the <code>path_manager</code> produces is simply a linear interpolation between waypoints, parametrized by the path parameter \\sigma(\\tau). This results in a straight line in 3D space, as well as a straight \"line\" between desired headings at the waypoints. Thus, the commanded position, p^c, and heading, \\psi^c, setpoints at the current time is computed as $$     p^c = \\sigma(\\tau) p_i + (1 - \\sigma(\\tau)) p_{i-1} $$ $$     \\psi^c = \\sigma(\\tau) \\psi_i + (1 - \\sigma(\\tau)) \\psi_{i-1} $$ where p_i is the waypoint at the end of the current leg, p_{i-1} is the waypoint at the start of the waypoint leg, \\sigma(\\tau) \\in [0,1] is a monotonically increasing function, and \\tau = \\frac{t}{T} \\in [0,1]. Here, t is the current time along the current waypoint leg, and T is the total time taken to travel the waypoint leg.</p> <p>We can then compute the commanded derivatives as $$     \\dot{p}^c = \\frac{1}{T}\\dot{\\sigma}(\\tau)(p_i - p_{i-1}) $$ $$     \\dot{\\psi}^c = \\frac{1}{T}\\dot{\\sigma}(\\tau)(\\psi_i - \\psi_{i-1}) $$ $$     \\ddot{p}^c = \\frac{1}{T^2}\\ddot{\\sigma}(\\tau)(p_i - p_{i-1}) $$ $$     \\ddot{\\psi}^c = \\frac{1}{T^2}\\ddot{\\sigma}(\\tau)(\\psi_i - \\psi_{i-1}) $$ Note that the \\frac{1}{T} term shows up because \\tau = t/T.</p> <p>To compute the desired output trajectory, we then need to define \\sigma(\\tau). We have some freedom to choose how \\sigma(\\tau) behaves. If we let \\sigma(\\tau) = \\tau = \\frac{t}{T}, then p^c would interpolate linearly in time from p_{i-1} to p_i. However, this would mean \\dot{p}^c (i.e. the velocity) would be constant, and the vehicle would have that same velocity at p_i, causing it to overshoot as it continued on to the next leg.</p> <p>Instead, we will define \\sigma(\\tau) to be a 5<sup>th</sup> order smoothstep function, which smoothly interpolates time from 0 to 1. The smoothstep function guarantees that the velocity and acceleration are zero at \\tau=0 and \\tau=1, resulting in a smooth transition between waypoint legs.</p> <p>The 5<sup>th</sup> order smoothstep scaling function (and derivatives) are defined as $$  \\sigma(\\tau) = 6\\tau^5 - 15\\tau^4 + 10\\tau^3 $$ $$  \\dot{\\sigma}(\\tau) = 30\\tau^4 - 60\\tau^3 + 30\\tau^2 $$ $$  \\ddot{\\sigma}(\\tau) = 120\\tau^3 - 180\\tau^2 + 60\\tau $$</p> <p>We can almost compute the desired trajectory setpoints. The last piece to consider is how to pick T, the total time to travel a given waypoint path leg. The smaller T is, the faster the path parameter \\sigma(\\tau) will transition, and the faster the vehicle will need to fly. For good performance, we would like to pick a T such that the vehicle can feasibly follow the path given some constraints.</p> <p>One way to do this is to pick T so that it is based off of some user-defined maximum velocity and acceleration parameters. To do this, let's first find where the maximums of \\dot{\\sigma}(\\tau) and \\ddot{\\sigma}(\\tau) are by setting derivatives equal to zero and solving for \\tau $$ \\frac{\\partial}{\\partial \\tau}\\dot{\\sigma}(\\tau) = \\ddot{\\sigma}(\\tau) = 120\\tau^3 - 180\\tau^2 + 60\\tau = 0 \\implies \\tau = \\frac{1}{2} = 0.5 $$ $$ \\frac{\\partial}{\\partial \\tau}\\ddot{\\sigma}(\\tau) = 360\\tau^2 - 360\\tau + 60 = 0 \\implies \\tau = \\frac{3 - \\sqrt{3}}{6} = 0.2113  $$</p> <p>Now let's compute the magnitude of the desired velocity and acceleration commands generated at these \\tau points. $$     \\lVert \\dot{p}^c(\\tau = 0.5) \\rVert = \\frac{1}{T_v}\\dot{\\sigma}(0.5) \\lVert p_i - p_{i-1} \\rVert = v_\\text{max} $$ $$     \\lVert \\ddot{p}^c(\\tau = 0.2113) \\rVert = \\frac{1}{T^2_a}\\ddot{\\sigma}(0.2113) \\lVert p_i - p_{i-1} \\rVert = a_\\text{max} $$</p> <p>Now we solve for T_v and T_a to get $$ T_v = \\dot{\\sigma}(0.5) * \\lVert p_i - p_{i-1} \\rVert / v_\\text{max} $$ $$ T_a = \\sqrt{\\ddot{\\sigma}(0.2113) * \\lVert p_i - p_{i-1} \\rVert / a_\\text{max}} $$ Note that both v_\\text{max} and a_\\text{max} are user-defined parameters.</p> <p>We can then choose the biggest T so that both constraints are satisfied: $$ T = \\max (T_v, T_a) $$</p> <p>Tuning v_\\text{max} and a_\\text{max}</p> <p>The two parameters v_\\text{max} and a_\\text{max} are highly vehicle-specific. The <code>path_manager</code> uses them to make sure that the commanded trajectory never produces velocity and acceleration commands higher than these parameters (as described above).</p> <p>If these parameters are set too high for downstream controllers to track, it will cause poor performance (especially when using a controller that uses the velocity and acceleration feed-forward commands in the trajectory command vector).</p> <p>For example, if these parameters are too high, then the path parameter \\sigma will propagate faster than downstream controllers are able to track. As the vehicle falls behind the commanded trajectory setpoint, the feed-forward terms (velocity and acceleration commands) will get out-of-sync with the current position of the vehicle along the trajectory.</p> <p>This is especially noticeable when the setpoint reaches the end of the waypoint path. The feed-forward terms are designed to slow the vehicle as it reaches the end of the waypoint path (this is the purpose of the smoothstep function). If the vehicle is far behind the final position when the path parameter \\sigma reaches it, then those feed-forward terms will cause the vehicle to slow down, even though the vehicle is still somewhere in the middle of the waypoint path. This results in visually poor performance. </p> <p>The solution? Tune the v_\\text{max} and a_\\text{max} parameters appropriately.</p> <p>We can now plug along and compute our desired trajectory commands at each leg. To set up each leg,</p> <ol> <li>Compute T</li> <li>Set t = 0</li> </ol> <p>For each waypoint leg in our path, we</p> <ol> <li>Compute \\tau = t/T</li> <li>Compute \\sigma(\\tau) and derivatives</li> <li>Compute p^c, \\psi^c and derivatives</li> <li>Publish trajectory command</li> </ol> <p>When the vehicle arrives at the next leg, simply set up the next leg and continue.</p> <p>Note that the <code>path_manager</code> publishes trajectory commands at the rate specified by the <code>path_update_frequency</code> ROS 2 parameter.</p>"},{"location":"user-guide/roscopter/roscopter-path-manager/#path-manager-services","title":"Path Manager Services","text":"<p>The <code>path_manager</code> offers the following service servers:</p> Service name Interface type Description <code>clear_waypoints</code> <code>std_srvs/Trigger</code> Clears the waypoints internal to the <code>path_manager</code> <code>print_waypoints</code> <code>std_srvs/Trigger</code> Prints all waypoints received to the terminal <p>Clearing waypoints</p> <p>As described in the <code>path_planner</code> section, when the <code>path_planner</code> publishes a message with the <code>clear_wp_list</code> set true, the <code>path_manager</code> internally clears its waypoints. This does the same thing as the <code>clear_waypoints</code> service call.</p> <p>Thus, there is no need to publish a waypoint with <code>clear_wp_list=true</code> and call the <code>clear_waypoints</code> service.</p> <p>Danger</p> <p>To avoid long descriptions, we omitted the namespace from the service calls in the documentation. All of the <code>path_manager</code> service servers are namespaced by <code>/path_manager</code>.</p> <p>In other words, to run the <code>clear_waypoints</code> service, you would run </p><pre><code>ros2 service call /path_manager/clear_waypoints ...\n</code></pre> not <pre><code>ros2 service call /clear_waypoints ...\n</code></pre><p></p>"},{"location":"user-guide/roscopter/roscopter-path-manager/#parameters-and-configuration","title":"Parameters and configuration","text":"<p>The parameters associated with the <code>path_planner</code> are</p> Parameter name Parameter type Description <code>default_altitude</code> <code>double</code> Altitude of the default waypoint (see note). Should be a positive number (not in NED frame)! <code>hold_last</code> <code>bool</code> Determines if the <code>path_manager</code> will hold at the last waypoint or if it will cycle back to the first <code>path_update_frequency</code> <code>double</code> Rate (in Hz) at which to publish trajectory setpoints <code>waypoint_tolerance</code> <code>double</code> Distance (in m) from the target waypoint at which the waypoint is considered complete <code>do_linear_interpolation</code> <code>bool</code> Determines if a linear time scaling or a 5<sup>th</sup> order smoothstep time scaling will be used. <code>max_acceleration</code> <code>double</code> Max acceleration value in m/s^2 (used when generating trajectory) <code>max_velocity</code> <code>double</code> Max velocity value in m/s (used when generating trajectory) <p>When no waypoints are provided to the <code>path_manager</code>, it will create a default waypoint to send to downstream tasks. This default waypoint is at the origin (i.e. where the vehicle was armed), with an altitude determined by the <code>default_altitude</code> parameter.</p> <p>The <code>hold_last</code> parameter determines whether or not the <code>path_manager</code> will hold the vehicle at the last waypoint. If this is set to <code>false</code>, then the <code>path_manager</code> will repeatedly cycle through the waypoints once it reaches the last one.</p> <p>The <code>path_update_frequency</code> parameter determines how often the <code>path_manager</code> publishes the trajectory commands. Setting this rate does not determine how fast the trajectory setpoints interpolate between waypoints (see the implementation details). Settings this to a high value just increases the frequency commands are published.</p> <p>The last two parameters, <code>max_acceleration</code> and <code>max_velocity</code> are user-defined parameters that are highly vehicle-specific. These two parameters determine the total time a given waypoint leg will take. The <code>max_acceleration</code> parameter limits the acceleration computed by the <code>path_manager</code>. The <code>max_velocity</code> parameter limits the velocity computed by the <code>path_manager</code>. See the implementation details for more information on how they are used/defined.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/","title":"ROScopter Path Planner","text":""},{"location":"user-guide/roscopter/roscopter-path-planner/#path-planner","title":"Path Planner","text":""},{"location":"user-guide/roscopter/roscopter-path-planner/#responsibility","title":"Responsibility","text":"<p>The <code>path_planner</code>'s responsibility is to define and publish a planned path consisting of waypoints. Each waypoint is defined by a 3D location and orientation.</p> <p>Thus, the <code>path_planner</code> maintains the list of all waypoints and publishes a subset to downstream nodes. Note that the <code>path_planner</code> does not manage the path, meaning it does not determine how to transition from one waypoint to another. It is simply in charge of maintaining and publishing waypoints.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#interface-with-roscopter","title":"Interface with ROScopter","text":"Reference diagram of the ROScopter architecture <p>The <code>path_planner</code> interfaces with the rest of ROScopter using publishers and subscribers.</p> Subscriber name Message type Description <code>estimated_state</code> <code>roscopter_msgs/State</code> Estimated state for the vehicle (needs GPS location of initial position) Publisher name Message type Description <code>waypoints</code> <code>roscopter_msgs/Waypoint</code> Waypoints in the planned path <p>The <code>path_planner</code> takes in user-defined waypoints and publishes those waypoints to the <code>path_manager</code> over the <code>waypoints</code> topic.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#parameters-and-configuration","title":"Parameters and configuration","text":"<p>The parameters associated with the <code>path_planner</code> are</p> Parameter name Parameter type Description <code>num_waypoints_to_publish_at_start</code> <code>int</code> Number of waypoints from plan to initially publish <p>The <code>num_waypoints_to_publish_at_start</code> parameter determines how many waypoints are automatically published when a path plan is loaded.</p> <p>If a given plan has 10 waypoints but the <code>num_waypoints_to_publish_at_start</code> is set to 5, then only the first 5 waypoints will be published right away. The other waypoints will then be published sequentially using the appropriate service call listed below.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#using-the-path_plannerimplementation-details","title":"Using the <code>path_planner</code>/implementation details","text":"<p>In the default configuration of ROScopter, the <code>path_planner</code> expects waypoints to be loaded using ROS 2 service calls. This can be done by another node or manually by the user. In our testing of the default ROScopter behavior, we usually manually load these waypoints by hand.</p> <p>A planned path can be modified using the following service calls:</p> Service name Interface type Description <code>/add_waypoint</code> <code>roscopter_msgs/AddWaypoint</code> Add a single waypoint to the planned path <code>/clear_waypoints</code> <code>std_srvs/Trigger</code> Clear all waypoints from the planned path <code>/load_mission_from_file</code> <code>rosflight_msgs/ParamFile</code> Clear all waypoints and load a new plan from a file <code>/print_waypoints</code> <code>std_srvs/Trigger</code> Print all waypoints in the plan to the screen <code>/publish_next_waypoint</code> <code>std_srvs/Trigger</code> Publish the next waypoint in the plan <p>Danger</p> <p>To avoid long descriptions, we omitted the namespace from the service calls in the documentation. All of the <code>path_planner</code> service servers are namespaced by <code>/path_planner</code>.</p> <p>In other words, to run the <code>add_waypoint</code> service, you would run </p><pre><code>ros2 service call /path_planner/add_waypoint ...\n</code></pre> not <pre><code>ros2 service call /add_waypoint ...\n</code></pre><p></p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#add-waypoint","title":"Add waypoint","text":"<p>The <code>add_waypoint</code> service adds a single waypoint to the path. See the <code>roscopter_msgs/AddWaypoint</code> interface definition to see what information is contained in the service call.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#clear-waypoints","title":"Clear waypoints","text":"<p>This service clears all waypoints from the planned path.</p> <p>Under the hood, this service call publishes a new waypoint that sets the <code>clear_wp_list</code> field to true (see the <code>roscopter_msgs/msg/Waypoint</code> message definition). It is the responsibility of any node subscribing to the waypoints to clear any internal list of waypoints. For example, in order to function properly, both the <code>path_manager</code> and the ROScopter ground control station (GCS) maintain internal lists of what waypoints have been published. These nodes need to clear the internal storage of the waypoints when the <code>path_planner</code> publishes a waypoint with the <code>clear_wp_list</code> field set true.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#load-mission-from-file","title":"Load mission from file","text":"<p>This service loads a mission file to the <code>path_planner</code>. The mission file is a YAML file containing the waypoint definitions.</p> <p>This service call also clears all existing waypoints first, so the new waypoints will not be appended to the old waypoints. If you want to append waypoints instead of clearing, use the <code>add_waypoints</code> service.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#print-waypoints","title":"Print waypoints","text":"<p>It can be helpful during debugging to know what waypoints are currently loaded to the <code>path_planner</code>. This service call will print the waypoints to the terminal (the terminal running the <code>path_planner</code>, not the one that calls this service).</p> <p>Note that printing to the screen is automatically done when using the <code>load_mission_from_file</code> service.</p>"},{"location":"user-guide/roscopter/roscopter-path-planner/#publish-next-waypoint","title":"Publish next waypoint","text":"<p>The <code>publish_next_waypoint</code> service server is used to publish the next unpublished waypoint in the planned path. Note that the first &lt;<code>num_waypoints_to_publish_at_start</code>&gt; number of waypoints are automatically published whenever the <code>path_planner</code> gets new waypoints.</p>"},{"location":"user-guide/roscopter/roscopter-trajectory-follower/","title":"ROScopter Trajectory Follower","text":""},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#trajectory-follower","title":"Trajectory Follower","text":""},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#responsibility","title":"Responsibility","text":"<p>The responsibility of the <code>trajectory_follower</code> is to produce controller setpoints to follow a given trajectory.</p> <p>Note that the <code>trajectory_follower</code> does not take in an entire trajectory, but rather a trajectory setpoint at a particular instant in time.</p>"},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#interface-with-roscopter","title":"Interface with ROScopter","text":"Reference diagram of the ROScopter architecture <p>The <code>trajectory_follower</code> interfaces with the rest of ROScopter using publishers and subscribers.</p> Subscriber name Message type Description <code>estimated_state</code> <code>roscopter_msgs/State</code> Estimated state for the vehicle (needs position and orientation) <code>status</code> <code>rosflight_msgs/Status</code> Status message from the ROSflight firmware (needs to know when RC control is active) <code>trajectory_command</code> <code>roscopter_msgs/TrajectoryCommand</code> Input trajectory command Publisher name Message type Description <code>high_level_command</code> <code>roscopter_msgs/ControllerCommand</code> Output commands to the downstream ROScopter controller <p>To summarize, the <code>trajectory_follower</code> takes in the estimated state (from the <code>estimator</code>) and trajectory setpoints (from the <code>path_manager</code>), and computes and publishes the commands to the <code>controller</code> node.</p>"},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#using-the-trajectory_followerimplementation-details","title":"Using the <code>trajectory_follower</code>/implementation details","text":"<p>The input trajectory commands are vectors of the form $$     u_\\text{traj} = [p, \\dot{p}, \\ddot{p}, \\psi, \\dot{\\psi}, \\ddot{\\psi}]^T, $$ where p and \\psi are the desired 3-D position and heading setpoints, respectively. The derivative terms are feed-forward terms for each setpoint.</p> <p>The output of the <code>trajectory_follower</code> is controller setpoints of the form $$     u_\\text{out} = [\\phi^c, \\theta^c, r^c, T^c] $$ where \\phi^c and \\theta^c are the desired roll and pitch in radians, respectively, and r^c is the desired yaw rate in radians per second. T^c is the desired thrust, in Newtons.</p> <p>The trajectory follower is based off of the \"Differential flatness based control of a rotorcraft for aggressive maneuvers\" by Ferrin, et al<sup>1</sup>. We refer the reader to that paper for information on the implementation and how it works.</p> <p>There are a number of differences in the ROScopter <code>trajectory_follower</code> not present in the work by Ferrin, et al.</p> <ol> <li> <p>The ROScopter <code>trajectory_follower</code> uses four PID controllers (north, east, down, and yaw) as the nominal controllers, not an LQR controller (as seen in Fig. 2 of the paper). This means that there are 4 sets of separate PID gains for each controller.</p> <p>Info</p> <p>The nominal controllers (the PID controllers) have integrators. To avoid integrator wind-up, the <code>trajectory_follower</code> clears the integrator values when the RC safety pilot has RC override.</p> <p>The <code>trajectory_follower</code> determines if the safety pilot has control of the vehicle using the <code>status</code> message.</p> </li> <li> <p>Eq. (16)<sup>1</sup> requires computing \\dot{\\theta} (note this is not q!). The <code>trajectory_follower</code> assumes constant acceleration over the timestep to compute this derivative.</p> </li> <li>Before computing \\boldsymbol{z} in Eq. (13)<sup>1</sup>, we first saturate u_{p_3} to avoid instabilities near the origin for Eq. (15)<sup>1</sup>.</li> </ol> <p>Note</p> <p>Saturating u_{p_3} is necessary to prevent poor performance when the trajectory follower tries to track large down setpoints.</p> <p>The total desired down acceleration is computed as $$ u_{p_3} = \\ddot{p}^c - g $$ where g=9.81 is gravity.</p> <p>When \\ddot{p}^c approaches +g, then u_{p_3} approaches 0, and Eq. (15)<sup>1</sup> returns large values of \\theta for small changes in z_1. Physically, this results in large, rapidly changing pitch commands, resulting in undesirable performance. Note that this can happen for large nominal (PID) controller output, but also for large feedforward input.</p> <p>To fix this, we need to make sure u_{p_3} does not approach 0, or equivalently, \\ddot{p}^c does not approach +g. Since free-fall is also usually not desirable (i.e. \\ddot{p}^c=0), we saturate u_{p_3} so that $$ u_{p_3} \\in [u_\\text{max}, -\\infty] $$ where u_\\text{max} is a negative number controlled by the <code>max_commanded_down_accel_in_gs</code> parameter.</p> <p>Note that the <code>max_commanded_down_accel_in_gs</code> parameter should be a negative number, e.g. -0.4. This means that the maximum down command is -0.4g. Since we are using the NED frame, this translates to a minimum of 0.4g commanded output acceleration up, so a maximum 0.6g actual acceleration down.</p>"},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#trajectory-follower-services","title":"Trajectory Follower Services","text":"<p>The <code>trajectory_follower</code> offers the following service server:</p> Service name Interface type Description <code>clear_integrators</code> <code>std_srvs/Trigger</code> Clears the integrator values in the nominal PID controllers"},{"location":"user-guide/roscopter/roscopter-trajectory-follower/#parameters-and-configuration","title":"Parameters and configuration","text":"<p>The parameters associated with the <code>trajectory_follower</code> are</p> Parameter name Parameter type Description <code>down_command_window</code> <code>double</code> If input down command to down controller is larger than this parameter, input command gets saturated to this value. <code>gravity</code> <code>double</code> Gravity in m/s^2 <code>mass</code> <code>double</code> Mass of the system in kg <code>max_commanded_down_accel_in_gs</code> <code>double</code> Maximum down acceleration the <code>trajectory_follower</code> can command (in g's). See the implementation details. <code>tau</code> <code>double</code> Bandwidth of the dirty derivative (for the PID controllers). See the ControlBook. <code>u_n_kp</code> <code>double</code> k_p gain for the north PID controller <code>u_n_ki</code> <code>double</code> k_i gain for the north PID controller <code>u_n_kd</code> <code>double</code> k_d gain for the down PID controller <code>u_e_kp</code> <code>double</code> k_p gain for the east PID controller <code>u_e_ki</code> <code>double</code> k_i gain for the east PID controller <code>u_e_kd</code> <code>double</code> k_d gain for the east PID controller <code>u_d_kp</code> <code>double</code> k_p gain for the down PID controller <code>u_d_ki</code> <code>double</code> k_i gain for the down PID controller <code>u_d_kd</code> <code>double</code> k_d gain for the down PID controller <code>yaw_to_rate_kp</code> <code>double</code> k_p gain for the yaw angle to yaw rate PID controller <code>yaw_to_rate_ki</code> <code>double</code> k_i gain for the yaw angle to yaw rate PID controller <code>yaw_to_rate_kd</code> <code>double</code> k_d gain for the yaw angle to yaw rate PID controller <p>Mass and gravity parameters</p> <p>The <code>gravity</code> and <code>mass</code> parameters must be correct. Otherwise, the <code>trajectory_follower</code> will output incorrect controller commands.</p> <p>Make sure the <code>mass</code> parameter is the same between all other nodes.</p> <p>As described in the implementation details section, there are 4 PID controllers, one for north, east, down position, and one for yaw to yaw-rate. Each controller has a set of PID gains associated with it, and each should be tuned separately.</p> <p>Tip</p> <p>For multirotors, the north and east configuration of the vehicle is usually symmetric, so the control gains for those two loops are likely to be very similar.</p> <p>The <code>down_command_window</code> parameter saturates the input command for the down nominal (PID) controller to avoid large input commands (and thus large output commands). In other words, if the input command is larger than <code>down_command_window</code>, then the input is saturated to this value. This parameter exists to help stabilize the drone as it descends.</p> <p>Important</p> <p>The <code>down_command_window</code> parameter only applies on the descent, not on the ascent. This is because when the vehicle descends through the prop wash, the airflow can cause instability and shaking.</p> <ol> <li> <p>J. Ferrin, R. Leishman, R. Beard and T. McLain, \"Differential flatness based control of a rotorcraft for aggressive maneuvers,\" 2011 IEEE/RSJ International Conference on Intelligent Robots and Systems, San Francisco, CA, USA, 2011, pp. 2688-2693, doi: 10.1109/IROS.2011.6095098.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/","title":"Manually flying ROSflight Sim","text":""},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#manually-flying-in-rosflight-sim","title":"Manually flying in ROSflight Sim","text":"<p>The purpose of this tutorial is to enable users to configure the ROSflight firmware through the parameter interface and fly in sim using a keyboard or a supported transmitter.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#prerequisites","title":"Prerequisites:","text":"<ul> <li>Setting up ROSflight sim</li> </ul>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#overview","title":"Overview","text":"<p>This tutorial walks through the complete process of manually flying an aircraft in ROSflight simulation. You will learn to:</p> <ul> <li>Load firmware parameters appropriate for your aircraft</li> <li>Calibrate the IMU</li> <li>Saving parameters to memory</li> <li>Fly using a supported RC transmitter or keyboard controls via VimFly</li> <li>Troubleshoot common issues during manual flight</li> </ul> <p>By the end of this tutorial, you will have a fully configured simulation environment ready for manual flight operations.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#loading-firmware-parameters","title":"Loading firmware parameters","text":"<p>After launching the simulator, you must load the firmware parameters. Parameters control the behavior of the firmware and how users will interact with the firmware. The ROSflight is highly configurable, but we have provided YAML files that contain a good default configuration for both multirotors and fixedwing vehicles.</p> <p>Parameter configuration is handled by the <code>rosflight_io</code> node, which exposes some of the firmware's parameters to the ROS2 parameter system. In addition, <code>rosflight_io</code> has many services that allow users to configure the firmware. Ensure <code>rosflight_io</code> (and the rest of the simulation is running) using </p><pre><code>ros2 node list\n</code></pre> and verifying that the <code>rosflight_io</code> and <code>sil_board</code> nodes are included in the list.<p></p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#loading-parameters-manually","title":"Loading parameters manually","text":"<p>You can load parameters one-by-one or with a YAML file, as described in the parameter configuration guide. We will load parameters from a file.</p> <ol> <li> <p>Navigate to the params directory:   </p><pre><code>cd ~/rosflight_ws/src/rosflight_ros_pkgs/rosflight_sim/params\n</code></pre><p></p> </li> <li> <p>Load the multirotor or fixedwing parameter YAML files:   </p><pre><code># For multirotor\nros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"{filename: $(pwd)/multirotor_firmware/multirotor_combined.yaml}\"\n\n# For fixedwing\nros2 service call /param_load_from_file rosflight_msgs/srv/ParamFile \"{filename: $(pwd)/fixedwing_firmware.yaml}\"\n</code></pre><p></p> </li> </ol> <p>Note that we first navigated to the directory so we could use the built-in <code>pwd</code> Linux command. It just saves time instead of having to type the full path to the file.</p> <p>Here are some of the parameters you just loaded. For a full list of the firmware's parameters, see the parameter list.</p> <ul> <li>Aircraft configuration: Sets <code>FIXED_WING: 0</code> for multirotor operation</li> <li>RC channels: configures 8 RC channels with appropriate mappings</li> <li>Mixer configuration: Uses custom mixer (<code>PRIMARY_MIXER: 11</code>) with motor parameters</li> <li>Control gains: Loads PID gains for roll, pitch, and yaw rate and angle controllers</li> <li>Safety settings: Sets minimum throttle and failsafe configurations</li> <li>RC override: Configures attitude and throttle override channels</li> </ul> <p>See the <code>*.yaml</code> files in the <code>rosflight_ros_pkgs/rosflight_sim/params</code> directory for more information on exactly what parameters were loaded, and what the values were.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#calibrating-the-imu","title":"Calibrating the IMU","text":"<p>The IMU (inertial measurement unit) calibration is essential for proper attitude estimation and flight control. The firmware will not arm until the IMU has been calibrated.</p> <p>To manually calibrate the IMU, use the calibration service provided by <code>rosflight_io</code>:</p> <pre><code># Calibrate IMU\nros2 service call /calibrate_imu std_srvs/srv/Trigger\n\n# Optional: Calibrate barometer\nros2 service call /calibrate_baro std_srvs/srv/Trigger\n</code></pre> <p>These commands may take a few seconds to complete. Pay attention to the output from the terminal where you launched the <code>rosflight_io</code> node. You should see something like: </p><pre><code>[rosflight_io-9] [INFO] [1751393533.505232221] [rosflight_io]: Parameter ACC_X_BIAS has new value -0.0507161\n[rosflight_io-9] [WARN] [1751393533.505511027] [rosflight_io]: There are unsaved changes to onboard parameters\n[rosflight_io-9] [INFO] [1751393533.505577958] [rosflight_io]: Parameter ACC_Y_BIAS has new value 0.215514\n[rosflight_io-9] [INFO] [1751393533.505683879] [rosflight_io]: Parameter ACC_Z_BIAS has new value 0.0193333\n[rosflight_io-9] [INFO] [1751393533.505775730] [rosflight_io]: [Autopilot]: IMU offsets captured\n[rosflight_io-9] [INFO] [1751393533.505820657] [rosflight_io]: Autopilot RECOVERED ERROR: Uncalibrated IMU\n[rosflight_io-9] [INFO] [1751393533.506043698] [rosflight_io]: Parameter GYRO_X_BIAS has new value -0.18134\n[rosflight_io-9] [INFO] [1751393533.506251903] [rosflight_io]: Parameter GYRO_Y_BIAS has new value -0.142449\n[rosflight_io-9] [INFO] [1751393533.506363563] [rosflight_io]: Parameter GYRO_Z_BIAS has new value 0.218309\n</code></pre><p></p> <p>Calibration when armed</p> <p>Calibration will fail if the aircraft is armed. ROSflight will also not allow the aircraft to be armed if the calibration is not performed, so this is uncommon.</p> <p>Calibrating for each flight</p> <p>In hardware, IMU calibration should be performed before each flight session. This ensures your IMU is well calibrated. In sim, if you don't save the parameters to a file (as described below), then you will need to recalibrate.</p> <p>Additionally, the aircraft will not arm until firmware parameters are properly loaded. These steps are mandatory for every simulation session (if you don't write the params as described below).</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#saving-parameters-to-memory","title":"Saving parameters to memory","text":"<p>ROSflight sim tries to mimic hardware as much as possible. By default, parameters in the firmware are not saved to flash memory, so they do not persist across reboots of the sim.</p> <p>Parameter initialization when booting up the sim</p> <p>In hardware, when the flight control unit (FCU) boots up, it looks in the SD card to detect a parameter file. If it doesn't find the file, then it initializes all firmware parameters to their default values. Likewise, when <code>rosflight_sim</code> boots up, it looks for the <code>rosflight_memory</code> folder in the location where <code>rosflight_sim</code> was booted. If it does not find the <code>rosflight_memory</code> folder, it creates one and initializes firmware parameters to the default values.</p> <p>While it doesn't really matter where you launch <code>rosflight_sim</code> from, you probably will want to launch it from the same place each time (so you don't have to load parameters to the firmware every time you boot). We recommend always launching <code>rosflight_sim</code> from the <code>rosflight_ws</code> directory for convenience.</p> <p>To save firmware parameters (including calibration values) to memory, use the <code>rosflight_io</code> service call: </p><pre><code>ros2 service call /param_write std_srvs/srv/Trigger\n</code></pre><p></p> <p>In hardware, this service call will write all the firmware's parameters to the SD card, where they will load on boot. In sim, however, it will generate a directory called <code>rosflight_memory</code> in the directory where the command to launch the sim occurred (not the directory where you ran the service call).</p> <p>To load those same parameters by default the next time that <code>rosflight_sim</code> is launched, just launch <code>rosflight_sim</code> from the directory that contains the <code>rosflight_memory</code> directory.</p> <p>Example</p> <p>Suppose I am in a directory with the following file structure: </p><pre><code>rosflight_ws\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u2514\u2500\u2500 src\n</code></pre><p></p> <p>And I launch the simulation from the <code>rosflight_ws</code> directory using </p><pre><code>ros2 launch rosflight_sim multirotor_standalone.launch.py\n</code></pre> I then write the params with <code>ros2 service call /param_write std_srvs/srv/Trigger</code>.<p></p> <p>My new file structure will be: </p><pre><code>rosflight_ws\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 install\n\u251c\u2500\u2500 log\n\u251c\u2500\u2500 rosflight_memory\n\u2514\u2500\u2500 src\n</code></pre><p></p> <p>To load those parameters by default when I launch <code>rosflight_sim</code> in the future, I just need to launch it from the directory that contains the <code>rosflight_sim</code> directory (in this case, <code>rosflight_ws</code>).</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#convenience-script","title":"Convenience script","text":"<p>We have provided a convenience script that does the above actions for you (loading parameters, calibrating the IMU, and writing params to memory). To use it, open a new terminal and run:</p> <pre><code># For multirotor\nros2 launch rosflight_sim multirotor_init_firmware.launch.py\n\n# For fixed-wing\nros2 launch rosflight_sim fixedwing_init_firmware.launch.py\n</code></pre> <p>This launch file performs three critical tasks:</p> <ol> <li>Loads parameters that are aircraft-specific from YAML files</li> <li>Automatically calibrates the IMU</li> <li>Saves the loaded parameters to firmware memory</li> </ol> <p>You can use this instead of doing the three actions manually.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#flying","title":"Flying","text":"<p>Once you have followed the steps above, you should be able to fly the aircraft manually. You can either do this using a keyboard or a supported RC transmitter, connected via USB.</p> <p>Flying requires you to arm the vehicle, meaning that the motors will be active. Prior to arming, motors will not spin and will not be powered.</p> <p>If you can arm and take off, you are good to go! Note that the firmware control loops can be tuned if necessary. See the tuning guide for more information.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#keyboard-control-with-vimfly","title":"Keyboard Control with VimFly","text":"<p>VimFly provides keyboard-based control for manual flight operations. Launch your simulation with VimFly enabled:</p> <pre><code># Launch with VimFly keyboard control\ncd ~/rosflight_ws\nros2 launch rosflight_sim multirotor_standalone.launch.py use_vimfly:=true\n</code></pre>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#vimfly-control-mapping","title":"VimFly Control Mapping","text":"Key Function Description <code>a</code> Increase Thrust Raises throttle increments <code>s</code> Decrease Thrust Lowers throttle increments <code>h</code> Roll Left Commands left roll stick input <code>l</code> Roll Right Commands right roll stick input <code>j</code> Pitch Backward Commands backward pitch stick input <code>k</code> Pitch Forward Commands forward pitch stick input <code>d</code> Yaw Left (CCW) Commands left yaw stick <code>f</code> Yaw Right (CW) Commands right yaw stick <code>t</code> Arm/Disarm Toggle Arms or disarms the aircraft <code>r</code> RC Override Toggle Toggles RC override mode <p>VimFly Window Focus</p> <p>The VimFly window must be in focus to receive keyboard input. Click on the VimFly terminal window to ensure it's active before attempting to control the aircraft.</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#rc-transmitter-control","title":"RC Transmitter Control","text":"<p>ROSflight supports several types of transmitters or controllers that you can use to fly around in the sim as the RC safety pilot:</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#supported-transmitters","title":"Supported Transmitters","text":"<ul> <li>FrSky Taranis Q-X7</li> <li>RadioMaster TX16S</li> <li>RadioMaster Boxer</li> <li>Xbox Controller</li> <li>RealFlight InterLink Controller</li> </ul> <p>If one of the supported transmitters is connected via USB at launch time, then the sim will default to using that controller instead of the default, which is no RC connection. See the Hardware Setup guide for more information on joysticks.</p> <p>Have a joystick not on the list?</p> <p>Joysticks not on the above list may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping!</p>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"Aircraft Won't Arm <p>Symptoms: Aircraft refuses to arm despite proper setup</p> <p>Possible Causes and Solutions:</p> <ul> <li>IMU not calibrated: Run <code>ros2 service call /calibrate_imu std_srvs/srv/Trigger</code></li> <li>Parameters not loaded: Execute the appropriate firmware initialization launch file</li> <li>RC not connected: Verify RC transmitter connection or use VimFly</li> <li>Safety checks failing: Check for error messages in the <code>rosflight_io</code> node output</li> </ul> VimFly Not Responding <p>Symptoms: Keyboard inputs not controlling the aircraft</p> <p>Solutions:</p> <ul> <li>Window focus: Click on the VimFly terminal window to ensure it has focus</li> <li>Pygame dependency: Verify pygame is installed: <code>pip install pygame</code></li> <li>Launch parameter: Ensure <code>use_vimfly:=true</code> is set in launch command</li> <li>RC override: Check if RC override is enabled and disable if necessary</li> </ul> RC Transmitter Not Detected <p>Symptoms: No RC input detected in simulation</p> <p>Solutions:</p> <ul> <li>USB connection: Verify transmitter is connected via USB</li> <li>Device permissions: Check USB device permissions and udev rules</li> <li>Joystick mode: Ensure transmitter is in USB joystick mode</li> <li>Monitor output: Use <code>ros2 topic echo /rc_raw</code> to verify RC signals</li> </ul> Poor Flight Performance <p>Symptoms: Aircraft is unstable or difficult to control</p> <p>Solutions:</p> <ul> <li>Parameter verification: Ensure correct firmware parameters are loaded</li> <li>IMU recalibration: Recalibrate IMU if attitude estimation appears incorrect</li> <li>Control gains: Check if PID gains are appropriate for aircraft type. See the tuning guide</li> <li>Simulation rate: Verify simulation is running at proper real-time rate</li> </ul> Simulation Lag or Stuttering <p>Symptoms: Jerky or delayed response to control inputs</p> <p>Solutions:</p> <ul> <li>System resources: Close unnecessary applications to free CPU/memory</li> <li>Simulation complexity: Reduce visual complexity in Gazebo simulation</li> <li>Network latency: Check for network issues if using remote display</li> <li>Hardware acceleration: Ensure graphics drivers are properly installed</li> </ul>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#review","title":"Review","text":"<p>You have successfully completed the manual flight tutorial for ROSflight simulation. You should now be able to:</p> <ul> <li>Initialize Firmware: Load appropriate parameters for multirotor or fixed-wing aircraft</li> <li>Calibrate Sensors: Perform IMU calibration for proper attitude estimation</li> <li>Control Aircraft: Fly using either VimFly keyboard controls or RC transmitter</li> <li>Troubleshoot Issues: Diagnose and resolve common simulation problems</li> </ul>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#next-steps","title":"Next Steps","text":"<p>Once you have the simulator running, you can:</p> <ol> <li>Autonomous flight: Integrate with the ROScopter or ROSplane autonomy stacks</li> <li>Custom applications: Use your own ROS2 nodes with ROSflight</li> <li>Parameter/Gain tuning: Use the RQT plugins to tune PID controllers and other parameters</li> </ol>"},{"location":"user-guide/tutorials/manually-flying-rosflight-sim/#additional-resources","title":"Additional Resources","text":"<ul> <li>ROSflight Parameter Reference: Detailed parameter descriptions</li> <li>Hardware Setup Guide: Preparing real hardware for flight</li> </ul>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/","title":"Running ROScopter in Sim","text":""},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#setting-up-roscopter-in-sim","title":"Setting up ROScopter in Sim","text":"<p>This tutorial guides you through setting up ROScopter, the multirotor autopilot system, in simulation. ROScopter provides basic autonomous flight capabilities for multirotor vehicles.</p> <p>This tutorial will walk you through:</p> <ul> <li>Launching the <code>roscopter</code> autonomy stack</li> <li>Flying waypoint missions</li> <li>Some basic analysis of what is going on</li> </ul>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#prerequisites","title":"Prerequisites","text":"<ul> <li>Manually flying in ROSflight Sim </li> </ul>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#roscopter-overview","title":"ROScopter Overview","text":"<p>ROScopter is a ROS2-based autopilot system designed for multirotor vehicles.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#major-system-components","title":"Major System Components","text":"<ul> <li>Estimator: EKF for state estimation</li> <li>Controller: Cascading PID controller with multiple control modes</li> <li>Trajectory Follower: Trajectory tracking between waypoints (like a path follower)</li> <li>Path Manager: Waypoint following and trajectory management</li> <li>Path Planner: High-level mission planning and execution</li> </ul>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#control-hierarchy","title":"Control Hierarchy","text":"<p>The ROScopter controller is designed so that uses can interface with it at a variety of levels. See the <code>roscopter_msgs/msg/ControllerCommand</code> message definition for more information.</p> Tip <p>Use <code>ros2 interface show roscopter_msgs/msg/ControllerCommand</code> to see the message definition.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#launching-standalone_sim","title":"Launching <code>standalone_sim</code>","text":"<p>The standalone simulator provides a lightweight simulation environment using RViz for visualization. This is the recommended starting point for ROScopter simulation.</p> <p>Launch the multirotor simulation:</p> <pre><code># Start the standalone simulator with ROSflight firmware simulation\ncd ~/rosflight_ws\nros2 launch rosflight_sim multirotor_standalone.launch.py use_vimfly:=true\n</code></pre> <p>The RViz simulation environment should launch.</p> <p>See the manually flying guide for instructions on launching, configuring, and arming in sim.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#launching-roscopter-autonomy-stack","title":"Launching ROScopter Autonomy Stack","text":"<p>The ROScopter autonomy stack is a collection of ROS2 nodes that provide autonomous flight capabilities on top of the basic simulation.</p> <p>In a new terminal, run:</p> <pre><code>ros2 launch roscopter_sim sim.launch.py\n</code></pre> <p>This launch file does 2 things:</p> <ol> <li>Launches <code>roscopter</code> autonomy stack by calling the <code>roscopter.launch.py</code> file. This file launches most of the nodes we'll explore later.</li> <li>Starts the <code>sim_state_transcriber</code> node. This node publishes the truth state from the simulation as a <code>roscotper/msg/State</code> message so we can easily compare estimated and true state.</li> </ol>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#understanding-the-roscopter-stack","title":"Understanding the ROScopter Stack","text":"<p>Let's take a look at the nodes that we just ran:</p> <pre><code># Check ROScopter-specific nodes\nros2 node list\n</code></pre> <p>You should see the following output: </p><pre><code>\u279c  ~ ros2 node list\n/autopilot\n/estimator\n/external_attitude_transcriber\n/path_manager\n/path_planner\n/roscopter_truth\n/trajectory_follower\n</code></pre><p></p> Node Descriptions <ul> <li><code>/autopilot</code>: Main controller node that implements cascading PID control loops (position \u2192 velocity \u2192 attitude \u2192 rate) and manages flight modes</li> <li><code>/estimator</code>: EKF that fuses IMU, GPS, and barometer data to provide state estimation (position, velocity, attitude)</li> <li><code>/external_attitude_transcriber</code>: Converts external attitude references from the estimator to <code>external_attitude</code> messages that are sent to the firmware estimator (helps the firmware estimator not drift)</li> <li><code>/path_manager</code>: Manages waypoint sequences and generates smooth trajectory segments between waypoints</li> <li><code>/path_planner</code>: High-level mission planning node that handles waypoint loading</li> <li><code>/roscopter_truth</code>: Simulation truth state publisher that provides ground truth data for comparison with estimated state</li> <li><code>/trajectory_follower</code>: Tracks generated trajectory segments and outputs position/velocity commands to the autopilot</li> </ul> <p>Let's now take a look at the topics specific to <code>roscopter</code>: </p><pre><code># Check ROScopter-specific topics\nros2 topic list\n</code></pre><p></p> <p>You should see the following output (note that these are topics from only the <code>roscopter</code> launch file): </p><pre><code>\u279c  ~ ros2 topic list\n/baro\n/command\n/estimated_state\n/external_attitude\n/gnss\n/high_level_command\n/imu/data\n/magnetometer\n/parameter_events\n/rosout\n/sim/roscopter/state\n/sim/truth_state\n/sim/truth_wind\n/status\n/trajectory_command\n/waypoints\n</code></pre><p></p> Some Key Topic Descriptions <ul> <li>Messages that the <code>estimator</code> subscribes to:<ul> <li><code>/baro</code>: Barometric pressure sensor data for altitude estimation</li> <li><code>/gnss</code>: GPS position and velocity measurements</li> <li><code>/imu/data</code>: IMU sensor data (accelerometer, gyroscope measurements)</li> <li><code>/magnetometer</code>: Magnetometer readings for heading estimation</li> </ul> </li> <li><code>/command</code>: Commands sent to ROSflight firmware (see rosflight_msgs/msg/Command for details)</li> <li><code>/estimated_state</code>: Complete vehicle state from EKF (position, velocity, attitude, angular rates)</li> <li><code>/external_attitude</code>: External attitude reference sent to firmware estimator to prevent drift</li> <li><code>/high_level_command</code>: High-level control commands from <code>trajectory_follower</code> to <code>autopilot</code></li> <li><code>/sim/roscopter/state</code>: ROScopter-formatted state message from simulation truth</li> <li><code>/trajectory_command</code>: Trajectory commands from path manager to trajectory follower</li> <li><code>/waypoints</code>: Current waypoint list and mission information</li> </ul> <p>When we fly waypoint missions, we will load waypoints to the <code>path_planner</code> using a service call. The chain of information flows from the <code>path_planner</code> to the <code>path_manager</code>, <code>trajectory_follower</code>, <code>autopilot</code>, and finally on to the firmware. You can see this in the <code>rqt_graph</code> image (by running <code>rqt_graph</code> in a new terminal):</p> <p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#publish-waypoints-to-rviz","title":"Publish waypoints to RViz","text":"<p>The ROScopter ground control station package (<code>roscopter_gcs</code>) has some useful executables to visualize waypoints in RViz. The <code>roscopter_gcs</code> package was designed so that it can be used out in the field (in other words, it doesn't depend on <code>rosflight_sim</code>). It can be helpful to run this so we can see if ROScopter is actually doing what we want it to do.</p> <pre><code># In a new terminal (source workspace first)\nros2 run roscopter_gcs rviz_waypoint_publisher\n</code></pre> <p>This node will subscribe to all of the waypoints published by the ROScopter <code>path_planner</code>, and will publish them to RViz.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#loading-missions","title":"Loading Missions","text":"<p>ROScopter supports loading waypoint missions through waypoints defined in YAML files or set through ROS services. These waypoints will be uploaded to the <code>path_planner</code> node using the <code>path_planner</code>'s ROS2 services.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#using-waypoint-files","title":"Using Waypoint Files","text":"<p>Waypoints can be loaded in batch manner from a file.</p> <p>Create or modify waypoint files: </p><pre><code># Edit the default waypoint file\nvim ~/rosflight_ws/src/roscopter/roscopter/params/multirotor_mission.yaml\n</code></pre><p></p> <p>Example waypoint file structure: </p><pre><code># WAYPOINTS\nwp:\n  type: 1                   # Waypoint type (0=hold, 1=go to)\n  w: [0.0, 0.0, -10.0]      # Position [North, East, Down] in meters\n  speed: 4.0                # Desired speed (m/s)\n  psi: 0.0                  # Desired heading (radians)\n  use_lla: false            # Use NED coordinates (not GPS lat/lon/alt)\nwp:\n  type: 1\n  w: [20.0, 0.0, -10.0]\n  speed: 4.0\n  psi: 0.0\n  use_lla: false\nwp:\n  type: 0                   # \"Hold\" waypoint\n  w: [20.0, -20.0, -20.0]\n  speed: 4.0\n  psi: 0.0\n  use_lla: false\n  hold_seconds: 5.0         # Hold for 5 seconds\n  hold_indefinitely: false\n</code></pre><p></p> <p>Waypoint Parameters:</p> <ul> <li><code>type</code>: Waypoint type (0 = hold, 1 = go to waypoint)</li> <li><code>w</code>: Position coordinates <code>[North, East, Down]</code> (in meters NED frame or LLA)</li> <li><code>speed</code>: Desired flight speed in m/s</li> <li><code>psi</code>: Desired heading in radians</li> <li><code>use_lla</code>: Set to <code>false</code> for NED coordinates, <code>true</code> for GPS coordinates</li> <li><code>hold_seconds</code>: Time to hold at waypoint (0.0 = no hold)</li> <li><code>hold_indefinitely</code>: If <code>true</code>, holds at waypoint until manual command</li> </ul> <p>Load waypoints from mission file using the service call:</p> <pre><code># Load waypoints from the default mission file\ncd ~/rosflight_ws/src/roscopter/roscopter/params\nros2 service call /path_planner/load_mission_from_file rosflight_msgs/srv/ParamFile \\\n  \"{filename: $(pwd)/multirotor_mission.yaml}\"\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#setting-waypoints-manually","title":"Setting Waypoints Manually","text":"<p>You can also add waypoints dynamically using the following services:</p> <pre><code># Add a single waypoint (North=5m, East=5m, Down=-4m, Yaw=0rad)\nros2 service call /path_planner/add_waypoint roscopter_msgs/srv/AddWaypoint \\\n  \"{wp: {w: [5.0, 5.0, -4.0], psi: 0.0}, publish_now: true}\"\n\n# Clear all current waypoints\nros2 service call /path_planner/clear_waypoints std_srvs/srv/Trigger\n</code></pre> <p>The structure of the <code>wp</code> field in the <code>roscopter_msgs/srv/AddWaypoint</code> service is the same as described above. The structure of the service can be seen using: </p><pre><code>ros2 interface show roscopter_msgs/srv/AddWaypoint\n</code></pre> which will output: <pre><code>\u279c  ~ ros2 interface show roscopter_msgs/srv/AddWaypoint\n# Add a Waypoint to the waypoint list\n\nroscopter_msgs/Waypoint wp\n    uint8 TYPE_HOLD = 0\n    uint8 TYPE_GOTO = 1\n    std_msgs/Header header\n        builtin_interfaces/Time stamp\n            int32 sec\n            uint32 nanosec\n        string frame_id\n    uint8 type\n    float32[3] w    #\n    float32 speed   #\n    float32 psi     #\n    float32 hold_seconds\n    bool hold_indefinitely\n    bool use_lla\nbool publish_now\n---\nbool success\nstring message\n</code></pre><p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#verify-mission-loading","title":"Verify Mission Loading","text":"<p>If you ran the ROScopter GCS <code>rviz_waypoint_publisher</code> node, you can check that the waypoints are loaded by looking at the RViz GUI. You should see something like:</p> <p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#publishing-additional-waypoints","title":"Publishing Additional Waypoints","text":"<p>Note that the <code>path_planner</code> will publish only the first few waypoints (determined by the <code>num_waypoints_to_publish_at_start</code> parameter). Publish the next one by calling: </p><pre><code>ros2 service call /path_planner/publish_next_waypoint std_srvs/srv/Trigger\n</code></pre> or by setting the parameter to the desired value: <pre><code>ros2 param set /path_planner num_waypoints_to_publish_at_start 100\n</code></pre><p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#enabling-autonomous-flight","title":"Enabling Autonomous Flight","text":"<p>After loading missions, enable autonomous flight through <code>rc</code>'s services. When starting up ROSflight, RC override will be enabled by default, meaning that the companion computer will not control the vehicle. To enable offboard control, you will need to disable RC override.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#arm-and-start-mission","title":"Arm and Start Mission","text":"<p>Note</p> <p>If using VimFly or a transmitter, these services will not be available. Use the transmitter or VimFly to arm and disable RC override.</p> <pre><code># Arm the vehicle (enable motors)\nros2 service call /toggle_arm std_srvs/srv/Trigger\n\n# Turn off RC override -- make sure it is toggled on before arming\nros2 service call /toggle_override std_srvs/srv/Trigger\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#monitor-flight-progress","title":"Monitor Flight Progress","text":"<p>In ROScopter, every module communicates with the other modules via ROS2 publishers and subscribers. You can track the status and state of the vehicle by echoing the relevant ROS2 topics. We often will use PlotJuggler to visualize the data to monitor what is going on internal to the system.</p> <p>For example: </p><pre><code># Monitor vehicle state during flight\nros2 topic echo /estimated_state\n\n# High level controller commands (sent to ROScopter controller)\nros2 topic echo /high_level_command\n\n# Low level controller commands (sent to ROSflight firmware)\nros2 topic echo /command\n</code></pre><p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#tuning-flight-performance","title":"Tuning Flight Performance","text":"<p>It is possible that the flight performance is unstable due to the <code>autopilot</code>'s gains not being set correctly. See the tuning guide for more information.</p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#helpful-tips","title":"Helpful Tips","text":""},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#resetting-the-simulation-state","title":"Resetting the Simulation State","text":"<p>The <code>standalone_sim</code> module has a very simplistic ground plane representation (i.e. no friction). This means that when the aircraft is armed, it will drift over time. If this happens to you, you can reset the simulation state of the vehicle.</p> <p>You can reset the state of the vehicle by using a service call provided by the <code>dynamics</code> node using </p><pre><code>ros2 service call /dynamics/set_sim_state rosflight_msgs/srv/SetSimState\n</code></pre><p></p> <p>Note that in this command we didn't specify what the values for the <code>SetSimState</code> message type are, so they default to zero. This should move the vehicle to the origin in the standalone sim. If you are using the Gazebo simulator, a position of [0,0,0] is underground, so the vehicle will respond erratically.</p> <p>You can set the simulation state to any arbitrary state by providing the information in the <code>SetSimState</code> service definition.</p> How do I know what information is contained in a message definition? <p>One way is to go find the message definition file in the package where it was built (i.e. rosflight_msgs package in the <code>rosflight_ros_pkgs</code> repository).</p> <p>Another option is to use the <code>ros2 interface show &lt;name-of-interface&gt;</code> command. For example, to find out what is included in the <code>SetSimState</code> service definition, do </p><pre><code>ros2 service call rosflight_msgs/srv/SetSimState\n</code></pre> and look through the output.<p></p>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#review","title":"Review","text":"<p>You have successfully completed the ROScopter autonomous flight tutorial. You should now be able to:</p> <ul> <li>Launch ROScopter Stack: Start the complete autonomy stack with estimator, controller, and path management</li> <li>Load Waypoint Missions: Create and load waypoint missions from YAML files or via ROS services</li> <li>Execute Autonomous Flight: Arm the vehicle and fly autonomous waypoint missions</li> </ul>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#next-steps","title":"Next Steps","text":"<p>Once you have ROScopter running autonomously, you can:</p> <ol> <li>Fixed-Wing Autonomous Flight: Explore ROSplane for fixed-wing autonomous flight</li> <li>Parameter/Gain Tuning: Use RQT plugins to tune PID controllers and optimize flight performance</li> <li>Custom Applications: Develop your own ROS2 nodes that interface with ROScopter</li> </ol>"},{"location":"user-guide/tutorials/setting-up-roscopter-in-sim/#additional-resources","title":"Additional Resources","text":"<ul> <li>ROSflight Parameter Reference: Detailed firmware parameter descriptions</li> <li>Hardware Setup Guide: Preparing real hardware for flight</li> <li>ROScopter Architecture Documentation: In-depth system design and implementation details</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/","title":"Setting up ROSflight Sim","text":""},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#setting-up-rosflight-sim","title":"Setting Up ROSflight Sim","text":"<p>The purpose of this tutorial is to walk users through launching the default ROSflight simulator.</p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#prerequisites","title":"Prerequisites","text":"<ul> <li>Install the ROSflight software (<code>rosflight_ros_pkgs</code>) by following the Installation for sim guide.</li> <li>Ensure you have the <code>-desktop</code> version of ROS2 installed, not the <code>-ros-base</code> version, as GUI tools are required for visualization.</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#rosflight-sim-overview","title":"ROSflight Sim Overview","text":"<p>A simulator includes many different modules, such as dynamic propagation, sensor creation, forces and moments computation, etc. One of these modules is the visualization module, that provides the graphical element to the simulator.</p> <p>While ROSflight is designed to support different visualizers, we focus on the most basic one in these tutorials, the <code>standalone_sim</code>, which uses the ROS2 RViz tool.</p> <p>The ROSflight simulator is organized as a collection of ROS2 nodes that each provide different functionality. As we work through launching the sim, we'll look at some of those modules and discuss what they do.</p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#simulation-architecture","title":"Simulation Architecture","text":"<p>The ROSflight standalone simulator consists of several key components:</p> <ul> <li>SIL Board: Instantiates the ROSflight firmware in software</li> <li>Dynamics: Simulates aircraft physics and dynamics</li> <li>Sensors: Simulates IMU, barometer, and other sensor data</li> <li>Forces and Moments: Computes aerodynamic forces based on control inputs</li> <li>RViz: Provides 3D visualization of the aircraft and flight path</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#launching-standalone_sim","title":"Launching <code>standalone_sim</code>","text":"<p>Warning</p> <p>Make sure you installed the <code>-desktop</code> version of ROS2, not the <code>-ros-base</code> version, or the GUI tools will not work.</p> <ol> <li> <p>Source your workspace:</p> <p>First, ensure your ROS2 environment and ROSflight workspace are properly sourced:</p> <pre><code># Replace &lt;ros-distro&gt; with your ROS 2 distro (e.g. \"humble\" or \"jazzy\")\nsource /opt/ros/&lt;ros-distro&gt;/setup.bash\nsource ~/rosflight_ws/install/setup.bash\n</code></pre> <p>Shell type</p> <p>Note that these commands will only work if you are using <code>bash</code> as your shell. If you are using <code>zsh</code>, make sure to change the <code>.bash</code> part of the above commands to <code>.zsh</code>.</p> <p>Using the provided Dockerfile? The Dockerfile provided and referenced in the Docker installation section uses <code>zsh</code> by default.</p> <p>How do I check which shell I am using? Use <code>echo $0</code> to check which shell you are using.</p> </li> <li> <p>Launch the simulator:</p> <p>ROSflight provides launch files for different aircraft types. Choose the appropriate command based on your needs:</p> </li> </ol>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#multirotor-simulation","title":"Multirotor Simulation","text":"<pre><code>cd ~/rosflight_ws\nros2 launch rosflight_sim multirotor_standalone.launch.py\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#fixed-wing-simulation","title":"Fixed-Wing Simulation","text":"<pre><code>cd ~/rosflight_ws\nros2 launch rosflight_sim fixedwing_standalone.launch.py\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#with-keyboard-control-vimfly","title":"With Keyboard Control (VimFly)","text":"<p>For manual control using keyboard input, add the <code>use_vimfly:=true</code> parameter:</p> <pre><code># Multirotor with keyboard control\ncd ~/rosflight_ws\nros2 launch rosflight_sim multirotor_standalone.launch.py use_vimfly:=true\n\n# Fixed-wing with keyboard control\ncd ~/rosflight_ws\nros2 launch rosflight_sim fixedwing_standalone.launch.py use_vimfly:=true\n</code></pre> <p>You'll notice that we <code>cd</code> into the <code>rosflight_ws</code> before launching the sim. This is important to deal with parameter management that will be covered in the next tutorial.</p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#understanding-the-simulation-environment","title":"Understanding the Simulation Environment","text":"<p>Let's look at what just happened when we launched.</p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#rviz-visualization","title":"RViz Visualization","text":"<p>Once launched, RViz will open displaying:</p> <ul> <li>3D Aircraft Model: Visual representation of your aircraft</li> <li>Coordinate Frames: Shows the aircraft's orientation and position</li> <li>Flight Path: Trace of the aircraft's trajectory (though you might not be able to see this until you start flying)</li> </ul> <p></p> <p>If you used the launch command <code>use_vimfly:=true</code>, you should also see VimFly open up:</p> <p></p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#running-nodes","title":"Running Nodes","text":"<p>You can verify the simulation is running by checking the active nodes:</p> <pre><code>ros2 node list\n</code></pre> <p>You should see the following output:</p> <p></p><pre><code>/rc\n/rosflight_sil_manager\n/sil_board\n/standalone_dynamics\n/standalone_sensors\n/standalone_viz_transcriber\n/static_transform_publisher_P4JOkDXVuy18dk2Z\n/static_transform_publisher_rJQeNeGn8gEepYGd\n/vimfly\n</code></pre> Note that the <code>static_transform_publisher</code> nodes will have different hashes than what is shown above.<p></p> <p>Each of these nodes performs a different role in the sim. Detailed information about these nodes and what they do can be found in the simulation architecture description.</p> <p>You can also see a representation of the data flow by running <code>rqt_graph</code> in a new terminal. If you don't see a similar view to what is below, click the refresh icon in the upper left.</p> RQT Graph is great, but it is not very configurable in terms of viewing options (sorry for the small image). <p>The main data flow through the simulator starts with the <code>/sil_board</code>. The <code>/sil_board</code> is the instantiation of the <code>rosflight_firmware</code> in sim--in hardware, this would be the flight controller.</p> <p>The <code>/sil_board</code> listens to the <code>/standalone_sensors</code> to \"read\" data from the \"sensors\", as close as possible to how the hardware board would read the sensor data.</p> <p>The <code>/sil_board</code> then computes motor commands and sends them over the <code>/sim/pwm_output</code> topic to the <code>fixedwing_forces_and_moments</code> node. This node is responsible for computing the aerodynamic forces and moments (not gravity or collisions) given the motor commands.</p> <p>The <code>/forces_and_moments</code> node then sends the computed forces and moments to the <code>/dynamics node</code>, which handles integration of the dynamics (i.e. solves \\dot{x} = f(x)) and publishes the true state. The <code>/dynamics</code> node handles gravity and other collision forces.</p> <p>This concludes a simulation \"tick\", and the simulation starts again with the <code>/sil_board</code>.</p> <p>For more information, see the detailed simulation architecture description.</p>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#topics","title":"Topics","text":"<p>View the available topics to see the data flow:</p> <pre><code># List the topics\nros2 topic list\n\n# Echo data sent through topics\nros2 topic echo &lt;topic_name&gt;\n</code></pre> <p>Key topics include:</p> <ul> <li><code>/rc_raw</code> - RC commands</li> <li><code>/imu/data</code> - IMU sensor data</li> <li><code>/attitude</code> - Aircraft attitude estimated by the firmware's estimator</li> <li><code>/command</code> - Control command inputs to the firmware controller (or mixer)</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#common-issues","title":"Common Issues","text":"RViz Not Opening <ul> <li>Ensure you installed <code>ros-&lt;ros-distro&gt;-desktop</code>, not <code>ros-&lt;ros-distro&gt;-ros-base</code>, where <code>&lt;ros-distro&gt;</code> is the ROS 2 distro you installed</li> <li>Check that you have a display environment (not running in headless mode)</li> </ul> Simulation Crashes <ul> <li>Check parameter files for syntax errors</li> <li>Verify all dependencies are installed: <code>rosdep install --from-path . -y --ignore-src</code></li> <li>Read the error messages on the launch script :)</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#review","title":"Review","text":"<p>In this tutorial, you learned how to:</p> <ul> <li>Launch the ROSflight standalone simulator for multirotor and fixed-wing aircraft</li> <li>Discover some of the simulation architecture and key components</li> <li>Troubleshoot common issues</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosflight-sim/#next-steps","title":"Next Steps","text":"<p>Once you have the simulator running, you can:</p> <ol> <li>Firmware configuration and manual flight: Configure the firmware with the necessary parameters and fly in sim with a supported controller</li> <li>Autonomous flight: Integrate with the ROScopter or ROSplane autonomy stacks</li> <li>Custom applications: Use your own ROS2 nodes with ROSflight</li> <li>Parameter/Gain tuning: Use the RQT plugins to tune PID controllers and other parameters</li> </ol>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/","title":"Running ROSplane in Sim","text":""},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#setting-up-rosplane-in-sim","title":"Setting up ROSplane in Sim","text":"<p>This tutorial guides you through setting up ROSplane, the fixed-wing autopilot system, in simulation. ROSplane provides autonomous flight capabilities for fixed-wing aircraft.</p> <p>This tutorial will walk you through:</p> <ul> <li>Launching the <code>rosplane</code> autonomy stack</li> <li>Flying waypoint missions</li> <li>Some basic analysis of what is going on</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#prerequisites","title":"Prerequisites","text":"<ul> <li>Manually flying in ROSflight Sim</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#rosplane-overview","title":"ROSplane Overview","text":"<p>ROSplane is a ROS2-based autopilot system designed for fixed-wing vehicles.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#major-system-components","title":"Major System Components","text":"<ul> <li>Estimator: EKF for state estimation from IMU, GPS, and barometer data</li> <li>Controller: Multiple control algorithms (successive loop control, total energy control)</li> <li>Path Follower: Tracks commanded paths and generates control setpoints</li> <li>Path Manager: Converts waypoints into smooth flyable paths using fillets or Dubins curves</li> <li>Path Planner: High-level mission planning and waypoint management</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#control-hierarchy","title":"Control Hierarchy","text":"<p>ROSplane implements a hierarchical control structure where high-level waypoint commands flow through path planning, path management, path following, and finally to low-level control loops.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#launching-standalone_sim","title":"Launching <code>standalone_sim</code>","text":"<p>The standalone simulator provides a lightweight simulation environment using RViz for visualization. This is the recommended starting point for ROSplane simulation.</p> <p>Launch the fixed-wing simulation:</p> <pre><code># Start the standalone simulator with ROSflight firmware simulation\ncd ~/rosflight_ws\nros2 launch rosflight_sim fixedwing_standalone.launch.py use_vimfly:=true\n</code></pre> <p>The RViz simulation environment should launch.</p> <p>See the manually flying guide for instructions on launching, configuring, and arming in sim.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#launching-rosplane-autonomy-stack","title":"Launching ROSplane Autonomy Stack","text":"<p>The ROSplane autonomy stack is a collection of ROS2 nodes that provide autonomous flight capabilities on top of the basic simulation.</p> <p>In a new terminal, run:</p> <pre><code>ros2 launch rosplane_sim sim.launch.py\n</code></pre> <p>This launch file does 2 things:</p> <ol> <li>Launches <code>rosplane</code> autonomy stack by calling the <code>rosplane.launch.py</code> file. This file launches most of the nodes we'll explore later.</li> <li>Starts the <code>sim_state_transcriber</code> node. This node publishes the truth state from the simulation as a <code>rosplane/msg/State</code> message so we can easily compare estimated and true state.</li> </ol>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#understanding-the-rosplane-stack","title":"Understanding the ROSplane Stack","text":"<p>Let's take a look at the nodes that we just ran:</p> <pre><code># Check ROSplane-specific nodes\nros2 node list\n</code></pre> <p>You should see the following output: </p><pre><code>\u279c  ~ ros2 node list\n/autopilot\n/estimator\n/path_follower\n/path_manager\n/path_planner\n/rosplane_truth\n</code></pre><p></p> Node Descriptions <ul> <li><code>/autopilot</code>: Main control node that implements multiple control algorithms (successive loop control, total energy control) and manages flight modes</li> <li><code>/estimator</code>: EKF that fuses IMU, GPS, and barometer data to provide state estimation (position, velocity, attitude, airspeed)</li> <li><code>/path_follower</code>: Tracks commanded paths and generates control setpoints for the controller</li> <li><code>/path_manager</code>: Converts waypoints into smooth flyable paths using fillets or Dubins curves</li> <li><code>/path_planner</code>: High-level mission planning node that handles waypoint loading and mission sequencing</li> <li><code>/rosplane_truth</code>: Simulation truth state publisher that provides ground truth data for comparison with estimated state</li> </ul> <p>Let's now take a look at the topics specific to <code>rosplane</code>:</p> <pre><code># Check ROSplane-specific topics\nros2 topic list\n</code></pre> <p>You should see the following output (note that these are topics from only the <code>rosplane</code> launch file): </p><pre><code>\u279c  ~ ros2 topic list\n/airspeed\n/baro\n/command\n/controller_command\n/controller_internals\n/current_path\n/estimated_state\n/gnss\n/imu/data\n/parameter_events\n/rosout\n/sim/rosplane/state\n/sim/truth_state\n/sim/truth_wind\n/status\n/waypoint_path\n</code></pre><p></p> Some Key Topic Descriptions <ul> <li>Messages that the <code>estimator</code> subscribes to:<ul> <li><code>/airspeed</code>: Differential pressure sensor for airspeed estimation</li> <li><code>/baro</code>: Barometric pressure sensor data for altitude estimation</li> <li><code>/gnss</code>: GPS position and velocity measurements</li> <li><code>/imu/data</code>: IMU sensor data (accelerometer, gyroscope measurements)</li> <li><code>/magnetometer</code>: Magnetometer readings for heading estimation</li> </ul> </li> <li><code>/command</code>: Commands sent to ROSflight firmware (see rosflight_msgs/msg/Command for details)</li> <li><code>/controller_internals</code>: Inner control loop commands. Helpful for debugging</li> <li><code>/current_path</code>: Active path segment being followed by the path follower</li> <li><code>/estimated_state</code>: Complete vehicle state from EKF (position, velocity, attitude, airspeed, wind estimation)</li> <li><code>/sim/rosplane/state</code>: ROSplane-formatted state message from simulation truth</li> <li><code>/waypoint_path</code>: Current mission waypoints and path information</li> </ul> <p>When we fly waypoint missions, we will load waypoints to the <code>path_planner</code> using a service call. The chain of information flows from the <code>path_planner</code> to the <code>path_manager</code>, <code>path_follower</code>, <code>autopilot</code>, and finally on to the firmware.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#launch-ground-control-station","title":"Launch Ground Control Station","text":"<p>The ground control station will plot waypoints that we pass to ROSplane. It can be helpful to launch this so we can see if ROSplane is actually doing what we want it to do.</p> <pre><code># In a new terminal (source workspace first)\nros2 launch rosplane_gcs rosplane_gcs.launch.py\n</code></pre> <p>This will launch another instance of RViz that will display different information than the main simulation pane.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#loading-missions","title":"Loading Missions","text":"<p>ROSplane supports loading waypoint missions through waypoints defined in YAML files or set through ROS services. These waypoints will be uploaded to the <code>path_planner</code> node using the <code>path_planner</code>'s ROS2 services.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#using-waypoint-files","title":"Using Waypoint Files","text":"<p>Waypoints can be loaded in batch manner from a file.</p> <p>Create or modify waypoint files: </p><pre><code># Edit the default waypoint file\nvim ~/rosflight_ws/src/rosplane/rosplane/missions/fixedwing_mission.yaml\n</code></pre><p></p> <p>Example waypoint file structure: </p><pre><code># WAYPOINTS\nwp:\n  w: [1000.0, -500.0, -50.0]  # Position [North, East, Down] in meters\n  chi_d: 1.1518               # Desired heading (radians)\n  lla: false                  # Use NED coordinates (not GPS lat/lon/alt)\n  use_chi: false              # Use smooth turns\n  va_d: 15.0                  # Desired airspeed (m/s)\nwp:\n  w: [1000.0, 400.0, -50.0]\n  chi_d: 1.1518\n  lla: false\n  use_chi: false\n  va_d: 15.0\n</code></pre><p></p> <p>Waypoint Parameters:</p> <ul> <li><code>w</code>: Position coordinates <code>[North, East, Down]</code> (in meters NED frame or LLA)</li> <li><code>chi_d</code>: Desired heading in radians</li> <li><code>lla</code>: Set to <code>false</code> for NED coordinates, <code>true</code> for GPS coordinates</li> <li><code>use_chi</code>: Set to <code>false</code> for fillet path planning, <code>true</code> for Dubin's path planning. See Small Unmanned Aircraft: Theory and Practice for more information.</li> <li><code>va_d</code>: Desired airspeed in m/s</li> </ul> <p>Load waypoints from mission file using the service call:</p> <pre><code># Load waypoints from the default mission file\ncd ~/rosflight_ws/src/rosplane/rosplane/params\nros2 service call /load_mission_from_file rosflight_msgs/srv/ParamFile \\\n  \"{filename: $(pwd)/fixedwing_mission.yaml}\"\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#setting-waypoints-manually","title":"Setting Waypoints Manually","text":"<p>You can also add waypoints dynamically using the following services:</p> <pre><code># Add a single waypoint (N=500m, E=300m, D=-40m, heading=0rad, airspeed=12m/s)\nros2 service call /add_waypoint rosplane_msgs/srv/AddWaypoint \\\n  \"{w: [500.0, 300.0, -40.0], chi_d: 0.0, use_chi: false, va_d: 12.0}\"\n\n# Progress to next waypoint in sequence\nros2 service call /publish_next_waypoint std_srvs/srv/Trigger\n\n# Print current waypoint list\nros2 service call /print_waypoints std_srvs/srv/Trigger\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#verify-mission-loading","title":"Verify Mission Loading","text":"<p>You can check that the waypoints are loaded by looking at the <code>rosplane_gcs</code> RViz GUI. You should see the waypoints plotted as markers in the visualization.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#publishing-additional-waypoints","title":"Publishing Additional Waypoints","text":"<p>Note that the <code>path_planner</code> will publish only the first few waypoints (determined by the <code>num_waypoints_to_publish_at_start</code> parameter). Publish the next one by calling: </p><pre><code>ros2 service call /publish_next_waypoint std_srvs/srv/Trigger\n</code></pre> or by setting the parameter to the desired value: <pre><code>ros2 param set /path_planner num_waypoints_to_publish_at_start 100\n</code></pre><p></p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#enabling-autonomous-flight","title":"Enabling Autonomous Flight","text":"<p>After loading missions, enable autonomous flight through <code>rc</code>'s services. When starting up ROSflight, RC override will be enabled by default, meaning that the companion computer will not control the vehicle. To enable offboard control, you will need to disable RC override.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#arm-and-start-mission","title":"Arm and Start Mission","text":"<p>Note</p> <p>If using VimFly or a transmitter, these services will not be available. Use the transmitter or VimFly to arm and disable RC override.</p> <pre><code># Arm the vehicle (enable motors)\nros2 service call /toggle_arm std_srvs/srv/Trigger\n\n# Turn off RC override -- make sure it is toggled on before arming\nros2 service call /toggle_override std_srvs/srv/Trigger\n</code></pre>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#monitor-flight-progress","title":"Monitor Flight Progress","text":"<p>In ROScopter, every module communicates with the other modules via ROS2 publishers and subscribers. You can track the status and state of the vehicle by echoing the relevant ROS2 topics. We often will use PlotJuggler to visualize the data to monitor what is going on internal to the system.</p> <p>For example: </p><pre><code># Monitor vehicle state during flight\nros2 topic echo /estimated_state\n\n# Watch controller commands internal to ROSplane\nros2 topic echo /controller_internals\n\n# Watch controller commands sent to ROSflight firmware\nros2 topic echo /command\n</code></pre><p></p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#tuning-flight-performance","title":"Tuning Flight Performance","text":"<p>It is possible that the flight performance is unstable due to the <code>controller</code>'s gains not being set correctly. See the tuning guide for more information.</p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#helpful-tips","title":"Helpful Tips","text":""},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#resetting-the-simulation-state","title":"Resetting the Simulation State","text":"<p>The <code>standalone_sim</code> module has a very simplistic ground plane representation (i.e. no friction). This means that when the aircraft is armed, it will drift over time. If this happens to you, you can reset the simulation state of the vehicle.</p> <p>You can reset the state of the vehicle by using a service call provided by the <code>dynamics</code> node using </p><pre><code>ros2 service call /dynamics/set_sim_state rosflight_msgs/srv/SetSimState\n</code></pre><p></p> <p>Note that in this command we didn't specify what the values for the <code>SetSimState</code> message type are, so they default to zero. This should move the vehicle to the origin in the standalone sim. If you are using the Gazebo simulator, a position of [0,0,0] is underground, so the vehicle will respond erratically.</p> <p>You can set the simulation state to any arbitrary state by providing the information in the <code>SetSimState</code> service definition.</p> How do I know what information is contained in a message definition? <p>One way is to go find the message definition file in the package where it was built (i.e. rosflight_msgs package in the <code>rosflight_ros_pkgs</code> repository).</p> <p>Another option is to use the <code>ros2 interface show &lt;name-of-interface&gt;</code> command. For example, to find out what is included in the <code>SetSimState</code> service definition, do </p><pre><code>ros2 service call rosflight_msgs/srv/SetSimState\n</code></pre> and look through the output.<p></p>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#review","title":"Review","text":"<p>You have successfully completed the ROSplane autonomous flight tutorial. You should now be able to:</p> <ul> <li>Launch ROSplane Stack: Start the complete autonomy stack with estimator, controller, and path management</li> <li>Load Waypoint Missions: Create and load waypoint missions from YAML files or via ROS services</li> <li>Execute Autonomous Flight: Arm the vehicle and fly autonomous waypoint missions</li> <li>Monitor Flight Performance: Track vehicle state and controller performance during flight</li> <li>Understand System Architecture: Recognize how nodes communicate and data flows through the system</li> </ul>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#next-steps","title":"Next Steps","text":"<p>Once you have ROSplane running autonomously, you can:</p> <ol> <li>Multirotor Autonomous Flight: Explore ROScopter for multirotor autonomous flight</li> <li>Parameter/Gain Tuning: Use RQT plugins to tune PID controllers and optimize flight performance</li> <li>Custom Applications: Develop your own ROS2 nodes that interface with ROSplane</li> </ol>"},{"location":"user-guide/tutorials/setting-up-rosplane-in-sim/#additional-resources","title":"Additional Resources","text":"<ul> <li>ROSflight Parameter Reference: Detailed firmware parameter descriptions</li> <li>Hardware Setup Guide: Preparing real hardware for flight</li> <li>ROSplane Architecture Documentation: In-depth system design and implementation details</li> </ul>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/","title":"Overview","text":""},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#transitioning-from-sim-to-hardware","title":"Transitioning from Sim to Hardware","text":"<p>This section specifically addresses tools that help users simulate fixed-wing aircraft. </p> <p>ROSplane is a fixed-wing specific branch of the ROSflight software that allows users to cater autopilot code and functionality to fixed wing UAVs in a variety of configurations. Modular architecture and clearly defined interfaces provide users with the ability to adapt the tool to their specific needs. One particularly useful tool is the ROSplane simulation, which allows users to input an aerodynamic model of their aircraft and then fly in simulation with the equivalent autopilot code that would be used during a physical flight. </p>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#rosplane-sim2real","title":"ROSplane Sim2Real","text":"<p>This section of the user manual addresses capabilities and recommendations for the ROSplane simulation for fixed-wing aircraft.  ROSplane simulation allows users to insert aerodynamic models of their aircraft and test in simulation. This is useful for controller tuning and validating new functionality in simulation before hardware tests.</p> <p>The following pages provide a step-by-step user guide with information on how to use two open source aerodynamic modeling software tools (XFlr5 and OpenVSP) to compute the aerodynamic control and stability derivatives required for the ROSplane aerodynamic model.</p> <p>Following this guide will result in aerodynamic coefficients that are sufficiently close to the real aircraft aero coefficients. For more information on the specific aerodynamic model used in ROSplane, see Chapter 4, Section 4.1 - 4.4 of Small Unmanned Aircraft: Theory and Practice by Randy Beard and Tim McLain.</p> <p>Here is a link to a recently submitted conference paper outlining ROSplane capabilities and the sim-to-real workflow. </p>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#introduction-and-disclaimer","title":"Introduction and Disclaimer","text":"<p>This manual provides guidance on the basic features of XFLR5 and OpenVSP. It is not exhaustive and does not guarantee the accuracy of outputs. Validation through simulation and physical testing is recommended before flight.</p> <p>Warning</p> <p>Xflr5 and OpenVSP are trademarks of their respective organizations. This webiste is not affiliated with or endorsed by them. This only provides helpful tips on how rosplane users can use these free open-source software tools to model and analyze their aircraft for integration with the ROSplane simulation.</p> <p>The XFLR5 and OpenVSP sections discuss the step-by-step process for aircraft modeling and analysis using each tool.  The Appendix section provides tips for working through common errors, links to helpful resources, and explanations of basic aerodynamics principles. </p> <p>You can also download this user manual as a single file and then open it in your browser to render it.</p>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#where-to-start","title":"Where to Start","text":"<p>The workflow for integrating a new aircraft model into the ROSflight simulation is:</p> <ol> <li>Model your aircraft</li> <li>Perform aerodynamic and stability analyses </li> <li>Integrate into ROSflight </li> <li>Test in simulation!</li> </ol>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#modeling-your-aircraft-and-running-aerodynamic-analyses","title":"Modeling Your Aircraft and Running Aerodynamic Analyses","text":"<p>Which tool do I use?</p> <p>You should feel free to start with the tool you are most comfortable with.  Xflr5 and OpenVSP produce similar models but each have unique strengths and application layout.  Each tool's user manual should be done in order, but there is no requirement to use Xflr5 before OpenVSP. </p> <p>Xflr5:</p> <ul> <li> <p>Allows users more options when analyzing and visualizing aerodynamics and stability and control performance</p> </li> <li> <p>Allows airfoil optimization </p> </li> <li> <p>Requires manual analysis of individual airfoils</p> </li> <li> <p>Can import/export AVL - compatible aircraft files</p> </li> </ul> <p>OpenVSP:</p> <ul> <li> <p>Allows users to model the entire aircraft (fuselage, wing, landing gear, propellers, etc)</p> </li> <li> <p>Often provides a more accurate drag estimate</p> </li> <li> <p>Analyses take longer to run</p> </li> </ul> <p>When choosing which tool to start with, use whichever tool you are more comfortable with or use the tool that has capabilities you value.  We recommend analyzing your aircraft in both tools and comparing results to obtain the most accurate aircraft model. </p>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#rosflight-integration","title":"ROSflight Integration","text":"<p>After modeling your aircraft and running the aerodynamic/stability/control analyses, follow this guide to add your model to the ROSflight simulation. </p> <p>This guide contains details on the specific files and parameters you need to edit to fly your aircraft in simulation.</p>"},{"location":"user-guide/tutorials/transitioning-from-sim-to-hardware/#additional-resources-and-further-study","title":"Additional Resources and Further Study","text":"<p>The Appendix contains an aerodynamics crash course, common errors, notation and nomenclature outlines, and additional useful resources/links for further study. </p> <p>Tip</p> <p>If you have questions during your modeling and analysis process, make sure to look here for helpful information and tips. </p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/","title":"Tuning performance","text":""},{"location":"user-guide/tutorials/tuning-performance-in-sim/#tuning-performance-in-sim","title":"Tuning Performance in Sim","text":"<p>This tutorial guides you through systematically tuning control gains for optimal flight performance in simulation. You'll learn to use PlotJuggler, RQT dynamic reconfigure, and the signal generator to tune both firmware and high-level control loops.</p> <p>Note</p> <p>We will be tuning the firmware and ROScopter as an example as we work through this tutorial. Tuning ROSplane is an identical process, just with different gains and different control loops.</p> <p>This tutorial will walk you through:</p> <ul> <li>Setting up tuning tools (PlotJuggler, RQT, Signal Generator)</li> <li>Understanding the control hierarchy and what to tune</li> <li>Tuning firmware controller gains (angle control loops)</li> <li>Tuning some ROScopter gains</li> <li>Analyzing performance with data visualization</li> </ul> <p>Note</p> <p>This guide is mainly meant to </p> <ul> <li>Introduce the tools that we use when flying with ROSflight, and</li> <li>Help you get a feel for an autonomy stack architecture</li> </ul> <p>See the improving firmware performance guide for more information on tuning the firmware controller and firmware estimator.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#prerequisites","title":"Prerequisites","text":"<ul> <li>Setting up ROScopter in Sim</li> <li>Basic understanding of PID control theory. We won't cover the PID tuning methodology.</li> <li>Some familiarity with ROScopter system architecture</li> </ul>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#overview","title":"Overview","text":""},{"location":"user-guide/tutorials/tuning-performance-in-sim/#controller-hierarchy","title":"Controller Hierarchy","text":"<p>ROScopter implements a hierarchical control structure with multiple nested control loops. These control loops ultimately feed into the firmware's control loops.</p> <p>This image shows a flow diagram for how information moves through the ROScopter controller to the firmware controller and then to the physical aircraft.</p> <p></p> <p>Note</p> <p>This diagram only shows the <code>controller</code> and <code>sil_board</code> nodes. It does not include the <code>trajectory_follower</code> node. We're focusing on the <code>controller</code> and <code>sil_board</code> controllers for now, but we will end up needing to tune all of the nodes to get the best performance possible.</p> <p>For more information on these nodes, see the previous guides.</p> <p>Each box or \"command type\" in the \"ROScopter Controller\" and \"Firmware\" sections is a level where a user can insert and publish commands. The commands then flow down through the chain from wherever the user inserted.</p> <p>Example: ROScopter controller information flow</p> <p>For example, if I want to send north, east, and down (NED) velocity and yaw rate commands to ROScopter, I would publish commands at the <code>NED-Vel YawRate</code> level, as described in the <code>roscopter_msgs/msg/ControllerCommands</code> message type.</p> <p>The controller would then convert those to NED acceleration/Yaw rate commands, which then are sent to the roll, pitch, yawrate, throttle controller, and then to the firmware angle controller. The commands are then finally sent through the mixer to the motors.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#what-were-tuning","title":"What We're Tuning","text":"<p>Each of the command types in the above diagram are implemented as PID control loops (with the exception of the NED-Accel command type). Thus, to tune the controller, we'll need to tune each PID gain.</p> <p>This turns out to be a lot of gains! We are going to start by tuning the lowest levels first and gradually working our way up. We won't do all of the loops, but we will do enough to show you how we typically do it.</p> <p>We will also introduce several tools that help us keep track of all the gains.</p> <p>We will tune the following loops:</p> <ol> <li>The firmware roll angle loops, to introduce the firmware parameters exposed through ROSflightIO</li> <li>ROScopter's roll/pitch/yaw/throttle loop so you have some hands-on experience with ROScopter's params.</li> </ol>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#setting-up-tuning-environment","title":"Setting Up Tuning Environment","text":""},{"location":"user-guide/tutorials/tuning-performance-in-sim/#launch-simulation-and-roscopter","title":"Launch Simulation and ROScopter","text":"<p>First, set up the complete simulation environment:</p> <pre><code># Terminal 1: Launch multirotor simulation\nros2 launch rosflight_sim multirotor_standalone.launch.py use_vimfly:=true\n\n# Terminal 2: Initialize firmware (if needed)\nros2 launch rosflight_sim multirotor_init_firmware.launch.py\n\n# Terminal 3: Run ROScopter controller\ncd ~/rosflight_ws/src/roscopter/roscopter/params\nros2 run roscopter controller --ros-args --params-file $(pwd)/multirotor.yaml\n\n# Terminal 4: Run the sim state transcriber node\nros2 run roscopter_sim sim_state_transcriber\n\n# Terminal 5: Run the estimator\nros2 run roscopter estimator\n</code></pre> <p>Note that we are not launching the whole ROScopter autonomy stack here. Instead, we are just launching the controller and the node that transcribes the true state (in the rosflight_msgs/msg/State format) to the roscopter_msgs/msg/State format. We also need the estimator node. We don't launch the whole autonomy stack since we will be using the signal generator to replace the upper levels of the autonomy stack.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#install-and-launch-plotjuggler","title":"Install and Launch PlotJuggler","text":"<p>PlotJuggler provides real-time data visualization for analyzing control performance. We'll use it to plot data live as we send control commands to the vehicle.</p>    Video of PlotJuggler in sim.  <p>Launching PlotJuggler: </p><pre><code># Install PlotJuggler if not already installed\nsudo apt install ros-&lt;ros-distro&gt;-plotjuggler-ros\n\n# Launch PlotJuggler\nros2 run plotjuggler plotjuggler\n</code></pre><p></p> <p>PlotJuggler Setup:</p> <ol> <li>Click \"Start\" \u2192 Select \"ROS2 Topic Subscriber\"</li> <li>Subscribe to key topics:</li> <li><code>/imu/data</code> - IMU measurements</li> <li><code>/estimated_state</code> - State estimation</li> <li><code>/controller_commands</code> - High-level commands</li> <li><code>/command</code> - Low-level motor commands</li> <li>Show them on the plot by clicking and dragging the data streams to the plot window.</li> </ol> <p>Plotjuggler is a powerful tool. We won't cover all the functionality here. We'll leave it to you to plot the topics you need as we go through this tutorial.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#launch-rqt-dynamic-reconfigure","title":"Launch RQT Dynamic Reconfigure","text":"<p>RQT is a plugin-based GUI tool distributed with ROS2 (the desktop version). The dynamic reconfigure plugin offered by RQT allows real-time parameter adjustment.</p> <p></p> <p>Each of the values shown in the image above are parameters (ROS2 parameters) of the <code>controller</code> node. ROS2 parameters make it easy to change those parameters on the fly. See the official documentation on parameters for more information.</p> <p>We have implemented all of the controller gains as ROS2 parameters. This makes it easy to use RQT Dynamic Reconfigure to adjust and tune the controller.</p> <p>Launch with: </p><pre><code># Launch RQT with dynamic reconfigure plugin\nrqt --standalone rqt_reconfigure\n</code></pre><p></p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#launch-signal-generator","title":"Launch Signal Generator","text":"<p>The signal generator provides systematic test inputs like square waves, step inputs, etc. to an output of choice.</p> <pre><code>ros2 run roscopter_tuning signal_generator\n</code></pre>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#firmware-controller-tuning","title":"Firmware Controller Tuning","text":"<p>In this section, we'll focus on tuning the firmware roll angle loops to introduce you to the firmware parameters exposed through ROSflightIO.</p> <p>Firmware controller architecture</p> <p>In the ROSflight firmware, the angle and rate loops are not chained, meaning that the angle loop does not feed into the rate loop. This means that we can tune them independently. We'll focus on the roll angle loop.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-1-set-initial-gains","title":"Step 1: Set Initial Gains","text":"<p>The firmware's control loop gains for the roll angle controller are something like: </p><pre><code># Roll angle controller gains\nPID_ROLL_ANG_P: 0.9\nPID_ROLL_ANG_I: 0.0\nPID_ROLL_ANG_D: 0.2\n</code></pre><p></p> <p>These gains (with values similar to these) are already set, so you don't technically need to set them.</p> <p>These get loaded at launch time to the firmware from the <code>~/rosflight_ws/src/rosflight_ros_pkgs/rosflight_sim/params/multirotor_firmware/multirotor_commbined.yaml</code> file. You can change them in the launch file and relaunch, but that is a pain. We'll use RQT and the ROS2 parameter system to dynamically reconfigure those parameters.</p> <p>To do this,</p> <ol> <li>Navigate to RQT dynamic reconfigure plugin.</li> <li>Select the <code>rosflight_io</code> node on the left hand side.</li> </ol> <p>You should see the gains show up on the right as shown below. These are the firmware gains that we have exposed to <code>rosflight_io</code>. This means that when we change the <code>rosflight_io</code> ROS2 parameters (which have the same name as the firmware parameters), the <code>rosflight_io</code> node will essentially call the <code>param_set</code> service as described in the parameter configuration guide.</p> <p></p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-2-generate-test-signals-for-roll","title":"Step 2: Generate Test Signals for Roll","text":"<p>Use the signal generator to create square wave responses specifically for roll. We'll do this first by setting some of the parameters via RQT dynamic reconfigure plugin.</p> <ol> <li>Select the <code>signal_generator</code> node in RQT.</li> <li>Change the <code>signal_type</code> parameter to \"square\". Note that you can see the available options by hovering your cursor over the parameter name.</li> <li>Set the <code>signal_magnitude</code> to be 0.5 (radians).</li> <li>Set the <code>frequency_hz</code> to be 0.1 (Hz).</li> <li>Set the <code>controller_mode</code> to be 6 (corresponds to Roll/Pitch/Yawrate/Throttle -- See the roscopter_msgs/msg/ControllerCommands message definition).</li> <li>Set the <code>default_cmd4</code> to be 0.7 (percentage throttle -- interpreted according to the <code>controller_mode</code> param).</li> <li>Make sure <code>controller_output</code> is 1 so that the signal generator changes output on cmd1.</li> </ol> <p>Start the signal generator with: </p><pre><code>ros2 service call /signal_generator/start_continuous_signal std_srvs/srv/Trigger\n</code></pre><p></p> <p>And pause it (when needed) with: </p><pre><code>ros2 service call /signal_generator/pause_signal std_srvs/srv/Trigger\n</code></pre><p></p> <p>The signal generator should now be publishing commands. Note that the signal generator actually publishes commands to ROScopter's <code>controller</code> node, which then forwards those commands to the firmware, as seen in the overview figure.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-3-set-up-topics-in-plotjuggler","title":"Step 3: Set up topics in PlotJuggler","text":"<p>Let's look at those commands in PlotJuggler.</p> <ol> <li>Open PlotJuggler, and look at the \"Streaming\" pane on the left side.</li> <li>Select \"ROS2 Topic Subscriber\" and click \"Start\".</li> <li>Select the relevant topics and hit \"Ok\" to start streaming.<ul> <li><code>high_level_command</code></li> <li><code>sim/truth_state</code></li> <li><code>sim/roscopter/state</code></li> </ul> </li> <li>Click the <code>high_level_command</code> and drag the <code>cmd1</code> to the right.</li> <li>Click the <code>sim</code>&gt;<code>roscopter</code>&gt;<code>state</code> and drag the <code>phi</code> field to the same plot.</li> </ol> <p>You should see something like: </p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-4-fly-the-multirotor","title":"Step 4: Fly the multirotor","text":"<p>As described in the multirotor tutorial, arm the aircraft and toggle RC override off. After doing this, the multirotor should take off by itself.</p> <p>Note</p> <p>The ROScopter controller (<code>controller</code> node) has a state machine built in that manages takeoff. If the performance of the controller does not allow the takeoff sequence to be successful, you will need to manually fly it through the take off sequence.</p> <p>This is done by flying it directly up to the value of the <code>takeoff_d_pos</code> param on the <code>controller</code> node and holding it there until the <code>controller</code> node outputs \"OFFBOARD CONTROLLER ACTIVE\" to the terminal.</p> <p>After the multirotor finishes the takeoff sequence, it should start listening to the signal generator's commands.</p> <p>You should see something like:</p> <p></p> <p>This response is not very tight, so let's tune it.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-5-tune-roll-angle-controller","title":"Step 5: Tune Roll Angle Controller","text":"<ol> <li>Open RQT and adjust the <code>PID_ROLL_ANG_P</code> and <code>PID_ROLL_ANG_D</code> commands as you like to improve the response.</li> <li>Watch PlotJuggler output to observe the effect of changing those gains.</li> </ol> <p>Here's an example of a somewhat-tuned response: </p> <p>Note that I also added the estimated state to the plot as well. The orange line is the firmware's estimated roll angle, and it tracks the command decently. However, it has a noticeable difference between truth. This means we should either tune the firmware response, or publish ROScopter's estimated state to the <code>external_attitude</code> topic.</p> <p>External Attitude</p> <p>We can improve the firmware's estimate by publishing ROScopter's <code>estimator</code>'s estimated state to the firmware. To do this, run </p><pre><code>ros2 run roscopter ext_att_transcriber\n</code></pre> in a new terminal.<p></p> <p>This only will help if the <code>estimator</code> node is producing good outputs!</p> <p>Note that this response is not perfect--I could probably tune it more to get better response. For reference, I changed the <code>PID_ROLL_ANG_P</code> equal to 4.0 and the <code>PID_ROLL_ANG_D</code> to 1.7 in RQT dynamic reconfigure.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#roscopter-yaw-controller-tuning","title":"ROScopter Yaw Controller Tuning","text":"<p>We will tune the roll/pitch/yaw/throttle controller from the overview diagram. As seen in the figure, the roll/pitch/yaw/throttle controller feeds into the roll/pitch/yawrate/throttle controller. Thus, the only gains we will need to tune are the ones associated with the yaw to yawrate controller.</p> <p>The gains associated with the yaw to yawrate PID controller are <code>yaw_to_rate_kp</code>, <code>yaw_to_rate_ki</code>, and <code>yaw_to_rate_kd</code>.</p> <p>ROScopter Controller Passthrough Loops</p> <p>This is detailed in the roscopter_msgs/msg/ControllerCommands message definition.     Even though the roll/pitch/yawrate/throttle loop is shown in ROScopter, it is one of the loops that is a \"passthrough\" loop, meaning that it forwards the commands to the firmware controller.</p> <p>This process will be very similar to the firmware controller tuning process. Differences in the process are noted below.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-1-set-initial-gains_1","title":"Step 1: Set Initial Gains","text":"<p>Same as step 1 above, but this time, select the <code>controller</code> node in the RQT dynamic reconfigure plugin.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-2-generate-test-signals-for-yaw","title":"Step 2: Generate Test Signals for Yaw","text":"<ol> <li>Select the <code>signal_generator</code> node in RQT.</li> <li>Change the <code>signal_type</code> parameter to \"square\". Note that you can see the available options by hovering your cursor over the parameter name.</li> <li>Set the <code>signal_magnitude</code> to be 1.0 (radians).</li> <li>Set the <code>frequency_hz</code> to be 0.1 (Hz).</li> <li>Set the <code>controller_mode</code> to be 5 (corresponds to Roll/Pitch/Yaw/Throttle -- See the roscopter_msgs/msg/ControllerCommands message definition).</li> <li>Set the <code>default_cmd4</code> to be 0.7 (percentage throttle -- interpreted according to the <code>controller_mode</code> param).</li> <li>Make sure <code>controller_output</code> is 3 so that the signal generator changes output on cmd1.</li> </ol> <p>Start the signal generator as normal.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-3-set-up-topics-in-plotjuggler_1","title":"Step 3: Set up topics in PlotJuggler","text":"<p>Same as above, but drag the <code>high_level_command/cmd3</code> (corresponding to yaw command) and the <code>sim/roscopter/state/psi</code> to the same plot.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-4-fly-the-multirotor_1","title":"Step 4: Fly the multirotor","text":"<p>Same as step 4 above.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#step-5-tune-yaw-angle-control","title":"Step 5: Tune yaw angle control","text":"<p>Same as step 5 above. The gains to tune are:</p> <ul> <li><code>yaw_to_rate_kp</code></li> <li><code>yaw_to_rate_ki</code></li> <li><code>yaw_to_rate_kd</code></li> </ul> <p>You now should have a tuned yaw to yawrate controller!</p> <p>Extending to other control loops</p> <p>The process for tuning the other ROScopter control loops is the same. First, select the loop and look at the initial gains. Set up the signal generator, take off, observe the response, and tune using the RQT dynamic reconfigure plugin.</p> <p>Note</p> <p>There are no control gains for the NED-Accel/YawRate control loop.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#using-signal-generator","title":"Using Signal Generator","text":"<p>The signal generator provides other useful features that we haven't yet looked at.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#available-signal-types","title":"Available Signal Types","text":"<pre><code># Step response - toggle on and off, not based on frequency\nros2 service call /signal_generator/toggle_step_signal std_srvs/srv/Trigger\n\n# Pause continuous signal\nros2 service call /signal_generator/pause_signal std_srvs/srv/Trigger\n\n# Reset continuous signal\nros2 service call /signal_generator/reset_signal std_srvs/srv/Trigger\n\n# Single period of a continuous signal\nros2 service call /signal_generator/start_single_period_signal std_srvs/srv/Trigger\n</code></pre>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#saving-tuned-parameters","title":"Saving Tuned Parameters","text":""},{"location":"user-guide/tutorials/tuning-performance-in-sim/#firmware-parameters","title":"Firmware Parameters","text":"<p>After tuning firmware parameters, you should write the parameters to memory (so you don't have to repeat).</p> <pre><code># Save parameters to firmware memory\nros2 service call /param_write std_srvs/srv/Trigger\n</code></pre>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#roscopter-parameters","title":"ROScopter Parameters","text":"<p>After tuning ROScopter parameters, save the changes to a YAML file. There is a <code>ros2 param dump &lt;node_name&gt; &gt;&gt; &lt;file_name&gt;.txt</code> command, to dump the parameters of a node to a file, but it does not format them nicely. The alternative is to manually enter them in the YAML file.</p> <pre><code># Edit parameter file with final tuned values\nvim ~/rosflight_ws/src/roscopter/roscopter/params/multirotor.yaml\n</code></pre>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#rosplane-tuning","title":"ROSplane Tuning","text":"<p>Tuning ROSplane follows a similar process with different control loops and gains. The same tools (PlotJuggler, RQT, Signal Generator) and methodology apply to ROSplane controller tuning.</p>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#review","title":"Review","text":"<p>You have successfully learned to tune the firmware and ROScopter control performance. You should now be able to:</p> <ul> <li>Set up tuning environment: Launch PlotJuggler, RQT, and Signal Generator</li> <li>Tune systematically: Follow inner-to-outer loop tuning methodology</li> <li>Use analysis tools: Interpret PlotJuggler data and adjust parameters accordingly</li> </ul>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#next-steps","title":"Next Steps","text":"<ol> <li>See the developer guide for more information on implementing your own code in ROSflight.</li> </ol>"},{"location":"user-guide/tutorials/tuning-performance-in-sim/#additional-resources","title":"Additional Resources","text":"<ul> <li>Parameter Reference: Complete parameter documentation</li> <li>Hardware Tuning Guide: Considerations for real hardware</li> </ul>"},{"location":"user-guide/tutorials/tutorial-overview/","title":"Tutorial overview","text":""},{"location":"user-guide/tutorials/tutorial-overview/#tutorials-for-rosflight","title":"Tutorials for ROSflight","text":"<p>New to ROSflight?</p> <p>If you are new to ROSflight, start here! We recommend going through the tutorials from Setting up ROSflight Sim through Tuning performance. After you have finished those, you should be ready to start flying your own code in sim.</p> <p>The tutorials in this section are designed to help you get started using ROSflight, ROScopter, and ROSplane in a simulation environment. They provide step-by-step guidance on launching the simulation, controlling vehicles manually, and running autonomous missions using one of the autonomy stacks (ROScopter or ROSplane). This will enable you to start testing your own code in sim.</p> <p>By following these tutorials, you will learn how to:</p> <ul> <li>Launch and interact with the ROSflight simulation</li> <li>Manually control simulated vehicles using a joystick or keyboard</li> <li>Run fixed-wing (ROSplane) and multirotor (ROScopter) simulations</li> <li>Understand basic communication between simulation and autonomy stack modules</li> </ul>"},{"location":"user-guide/tutorials/tutorial-overview/#prerequisites","title":"Prerequisites","text":"<p>Before starting these tutorials, make sure you have completed the Installation for Sim guide.</p>"},{"location":"user-guide/tutorials/user-manual-ROSflight-integration/","title":"ROSflight Integration","text":""},{"location":"user-guide/tutorials/user-manual-ROSflight-integration/#integrating-aircraft-models-into-rosflight","title":"Integrating Aircraft Models into ROSflight","text":"<p>Before integrating your aircraft model into the ROSflight simulation, complete all of the required stability analyses. Go to these Xflr5 and OpenVSP sections for information on how to run a stability analysis. </p> <p>After running the necessary aerodynamic and stability analyses, the next step is to add the stability and control derivatives into the required parameter file. </p> <p>The file you need to change is a \"dynamics.yaml\" file located here:  <code>rosflight_ros_pkgs/rosflight_sim/params/anaconda_dynamics.yaml</code></p> <p>A sample parameter file is provided below. </p> Sample parameter file <pre><code># Parameters for ROSflight software-in-the-loop simulation, based on RMRC Anaconda UAV.\n# Authors: Ian Reid and Phil Tokumaru\n\n# Mass and inertia parameters are defined in fixedwing.urdf.xacro.\n# Mass: 4.5\n# Jx: 0.24855\n# Jy: 0.3784\n# Jz: 0.618\n# Jxz: 0.06\n\n/**:  # Apply to any node that we load it to\nros__parameters:\n    rho: 1.2682\n    mass: 4.5\n\n/fixedwing_forces_and_moments:\nros__parameters:\n    wing_s: .52\n    wing_b: 2.08\n    wing_c: 0.2350\n    wing_M: 50.0\n    wing_epsilon: 0.9 # revisit -- may not need this for the calculation\n    wing_alpha0: 0.05236\n\n    D_prop : 0.381 # prop diameter in m (15 in)\n    CT_0 : 0.06288743\n    CT_1 : -0.02704452\n    CT_2 : -0.31320732\n    CQ_0 :  0.00614891\n    CQ_1 : -0.0106795\n    CQ_2 : -0.011779\n    KV : 560.0        # Motor speed constant from datasheet in RPM/V\n    KQ : 0.01705                       #((1 /(KV_rpm_per_volt)) *60) / (2 *M_PI) Back-emf constant, KV in V-s/rad, Motor torque constant, KQ in N-m/A\n    V_max : 24.0                  # voltage for 6s battery at 4 volts per cell\n    R_motor : 0.042              # ohms\n    I_0 : 1.5                     # no-load (zero torque) current (A)\n\nservo_tau: .01\nservo_refresh_rate: 0.003\nmax_aileron_deflection_angle: 40. # Maximum deflection of the control surfaces in degrees.\nmax_rudder_deflection_angle: 40. # Maximum deflection of the control surfaces in degrees.\nmax_elevator_deflection_angle: 40. # Maximum deflection of the control surfaces in degrees.\n\n# Anaconda done for C_L\n\nC_L_O: .506\nC_L_alpha: 5.61\nC_L_beta: 0.0\nC_L_p: 0.0\nC_L_q: 7.95\nC_L_r: 0.0\nC_L_delta_a: 0.0\nC_L_delta_e: 0.13\nC_L_delta_r: 0.0\n\n# Anaconda done for C_D\n\nC_D_O: 0.043\nC_D_alpha: 0.03\nC_D_beta: 0.0\nC_D_p: 0.043\nC_D_q: 0.0\nC_D_r: 0.0\nC_D_delta_a: 0.0\nC_D_delta_e: 0.0135\nC_D_delta_r: 0.0\n\nC_ell_O: 0.0\nC_ell_alpha: 0.00\nC_ell_beta: -0.13\nC_ell_p: -0.51\nC_ell_q: 0.0\nC_ell_r: 0.25\nC_ell_delta_a: 0.17\nC_ell_delta_e: 0.0\nC_ell_delta_r: 0.0024\n\nC_m_O: 0.135\nC_m_alpha: -2.74\nC_m_beta: 0.0\nC_m_p: 0.0\nC_m_q: -38.21\nC_m_r: 0.0\nC_m_delta_a: 0.0\nC_m_delta_e: -.99\nC_m_delta_r: 0.0\n\nC_n_O: 0.0\nC_n_alpha: 0.0\nC_n_beta: 0.1301\nC_n_p: -0.0364\nC_n_q: 0.0\nC_n_r: -0.1541\nC_n_delta_a: -0.011\nC_n_delta_e: 0.0\nC_n_delta_r: -0.069\n\n# Anaconda done for C_Y\n\nC_Y_O: 0.0\nC_Y_alpha: 0.00\nC_Y_beta: -0.98\nC_Y_p: 0.0\nC_Y_q: 0.0\nC_Y_r: 0.0\nC_Y_delta_a: 0.075\nC_Y_delta_e: 0.0\nC_Y_delta_r: .19\n\n/standalone_dynamics:\nros__parameters:\n    Jxx: 0.24855\n    Jxy: 0.0\n    Jxz: 0.06\n    Jyy: 0.3784\n    Jyz: 0.0\n    Jzz: 0.618\n</code></pre> <p>The coefficients that need to be changed are the <code>C_L, C_D, C_m, C_Y, C_n, C_ell</code> derivatives. Replace the values for all of these stability and control derivatives with the values obtained from the stability and control analyses you ran with either Xflr5 or OpenVSP. </p> <p>Note</p> <p>Some of the derivatives are zero because they are \"coupled\" which means that they describe cross-axis effects. Usually these have a small effect on an aircraft and don't add much accuracy. See the Appendix section notation glossary to see which coefficients are coupled. Use your own best judgement when deciding whether or not to include these. </p> <p>Once your parameter file is completed, save and re-name the file. You can then call this file when you launch the simulation. </p> <p>Steps to add a new aircraft to the simulation environment:</p> <ol> <li>Complete your aircraft model and complete all required aerodynamic, stability, and control analyses</li> <li>Create new .yaml parameter file and update coefficient values (example: <code>cessna_dynamics.yaml</code>)</li> <li>Save .yaml file in <code>rosflight_ros_pkgs/rosflight_sim/params/</code></li> <li> <p>Call your aircraft model (example: cessna) when running the simulation with:</p> <pre><code>ros2 launch rosflight_sim fixedwing_standalone.launch.py dynamics_param_file:=/path/to/param/file.yaml\n</code></pre> </li> </ol>"},{"location":"user-guide/tutorials/user-manual-appendix/","title":"Appendix","text":"<p>This section contains an aerodynamics crash course, common errors, notation and nomenclature outlines, and additional useful resources/links for further study. </p>"},{"location":"user-guide/tutorials/user-manual-appendix/#quick-links","title":"Quick-Links","text":"<ul> <li>Aerodynamics Crash Course</li> <li>How to Find the Best Stability and Control Derivatives</li> <li>Notation Glossary</li> <li>References, Helpful Links, and Documentation</li> </ul>"},{"location":"user-guide/tutorials/user-manual-appendix/#aerodynamics-crash-course","title":"Aerodynamics Crash Course","text":"<ul> <li>Cm/Alpha Rules</li> <li>Finding the Neutral Point with a Cm Chart</li> <li>Static Margin</li> <li>Finding Steady Flight Speed</li> <li>Finding Trimmed State</li> <li>Glide Ratio</li> <li>Root Locus Stability Charts</li> </ul>"},{"location":"user-guide/tutorials/user-manual-appendix/#cmalpha-stability","title":"Cm/Alpha Stability","text":"<p>The Cm (center of mass) vs. Alpha curve must have a negative slope to be stable. It also should cross the positive x-axis to be stable.  </p> <p>If the slope is not positive or if the line does not cross the positive x-axis, then the aircraft will not be able to naturally hold level flight.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#neutral-point","title":"Neutral Point","text":"<p>The neutral point (NP) is the aerodynamic center of the entire aircraft \u2014 the point along the longitudinal axis where the pitching moment doesn't change with angle of attack.  </p> <p>If the center of gravity (CG) is ahead of the NP, the aircraft is statically stable.  </p> <p>If the CG is behind the NP, the aircraft is unstable.  </p> <p></p> <p>In Xflr5, you can find the calculated neutral point in the plane viewer tab after performing a basic aerodynamic analysis. You can also find the NP in the coefficient viewer window below the list of analyses after a stability analysis.  </p> <p>In OpenVSP, the neutral point can be found at the bottom right of the .stab file after a stability analysis is completed.  </p> <p>  The neutral point can also be found in both Xflr5 and OpenVSP by finding the CG location at which the Cm vs. Alpha curve has a flat slope.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#static-margin","title":"Static Margin","text":"<p>Static margin is a measure of how stable an aircraft is. A higher SM means the aircraft will more quickly stabilize itself from disturbances, which usually also results in a lower maneuverability.  </p> <p>The static margin for most commercial and hobbyist aircraft is between 5-15%. 5-10% is more maneuverable, and 10-20% is more stable.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#flight-speed","title":"Flight Speed","text":"<p>The y-intercept of a velocity vs. alpha chart will show you the steady flight speed at any alpha.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#aircraft-trimming","title":"Aircraft Trimming","text":"<p>A Cm vs. alpha chart x-intercept shows the trimmed angle of an aircraft.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#glide-ratio","title":"Glide Ratio","text":"<p>A glide ratio compares how far an aircraft can fly compared to how far it will fall.  </p> <p>The CL/CD vs. Cm chart y-intercept shows the glide ratio.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#root-locus-stability","title":"Root Locus Stability","text":"<p>The root locus chart in the Xflr5 viewer shows the stability response of an aircraft.  </p> <p>The roots show stable / oscillatory characteristics.  </p> <p>If the roots are farther left, the aircraft is more stable. Farther from the x-axis = more oscillation.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#how-to-find-the-best-stability-and-control-derivatives","title":"How to Find the Best Stability and Control Derivatives","text":"<p>You should actuate only one group of control surfaces per stability analysis. For this reason, you will most likely need to run several stability analyses.  </p> <p>Example: have one stability analysis with ailerons activated to get the aileron control derivatives, and another analysis to get the elevator control derivatives.  </p> <p>  The .flt file contains all of the stability derivatives, but does not contain the control derivatives. The drag coefficients in here seem to be the most accurate.  </p> <p></p> <p>In Xflr5, the stability and control derivatives can be found in the output viewer after a stability analysis is completed.  </p> <p>Select an analysis from the list at the top left and the derivatives will appear below.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#notation-glossary","title":"Notation Glossary","text":"<p>This section contains a glossary of common names and abbreviated notation for the most common stability and control derivatives used when analyzing aircraft. </p> <p>It also lists and compares the stability and control derivative naming conventions for each tool discussed in this manual (ROSplane, Xflr5, and OpenVSP). </p> <p>Note</p> <p>ROSplane allows users to include non-standard stability and control derivatives that are not commonly used in aircraft analysis. These, along with helpful tips, are located under the \"non-standard\" section at the bottom of the picture. </p> <p>\"C_D_p\" in ROSflight is the parasitic drag coefficient!</p> <p>In the ROSplane parameters, C_D_p is \"parasitic drag\", not drag from roll rate. Make sure to take this into account when building your model and inputting values into your .yaml file. Instructions for calculating parasitic drag can be found here.</p> <p></p> <p>The following tables define the key equations and variables that are used to calculate the stability and control derivatives referenced above. The equations are from Airplane Flight Dynamics and Automatic Flight Controls by J. Roskam.</p> <p></p> Variable Definitions Symbol Description Units \\alpha Angle of attack rad \\beta Angle of sideslip rad p, q, r Roll, pitch, and yaw rates rad/s b Wing span m \\bar{c} Mean aerodynamic chord m U_1 Freestream (reference) airspeed m/s \\delta_e, \\delta_a, \\delta_r Elevator, aileron, and rudder deflections rad \\dfrac{q\\bar{c}}{2U_1} Nondimensional pitch rate \u2014 \\dfrac{pb}{2U_1} Nondimensional roll rate \u2014 \\dfrac{rb}{2U_1} Nondimensional yaw rate \u2014 C_L, C_D, C_Y Lift, drag, and side-force coefficients \u2014 C_\\ell, C_m, C_n Rolling, pitching, and yawing moment coefficients \u2014 <p></p> Longitudinal Coefficients <p></p> Symbol Formula Description Units C_{L_0} \u2014 Lift coefficient at zero angle of attack \u2014 C_{D_0} \u2014 Zero-lift drag coefficient \u2014 C_{m_0} \u2014 Pitching moment coefficient at zero angle of attack \u2014 C_{L_\\alpha} \\dfrac{\\partial C_L}{\\partial \\alpha} Variation of lift with angle of attack 1/rad C_{D_\\alpha} \\dfrac{\\partial C_D}{\\partial \\alpha} Variation of drag with angle of attack 1/rad C_{m_\\alpha} \\dfrac{\\partial C_m}{\\partial \\alpha} Variation of pitching moment with angle of attack 1/rad C_{L_q} \\dfrac{\\partial C_L}{\\partial (q\\bar{c}/2U_1)} Variation of lift with nondimensional pitch rate 1/rad C_{D_q} \\dfrac{\\partial C_D}{\\partial (q\\bar{c}/2U_1)} Variation of drag with nondimensional pitch rate 1/rad C_{m_q} \\dfrac{\\partial C_m}{\\partial (q\\bar{c}/2U_1)} Variation of pitching moment with nondimensional pitch rate 1/rad C_{L_{\\delta_e}} \\dfrac{\\partial C_L}{\\partial \\delta_e} Variation of lift with elevator deflection 1/rad C_{D_{\\delta_e}} \\dfrac{\\partial C_D}{\\partial \\delta_e} Variation of drag with elevator deflection 1/rad C_{m_{\\delta_e}} \\dfrac{\\partial C_m}{\\partial \\delta_e} Variation of pitching moment with elevator deflection 1/rad <p></p> Lateral/Directional Coefficients <p></p> Symbol Formula Description Units C_{Y_0} \u2014 Side force coefficient for zero sideslip and zero control deflection \u2014 C_{\\ell_0} \u2014 Rolling moment coefficient for zero sideslip and zero control deflection \u2014 C_{n_0} \u2014 Yawing moment coefficient for zero sideslip and zero control deflection \u2014 C_{Y_\\beta} \\dfrac{\\partial C_Y}{\\partial \\beta} Variation of side force with sideslip angle 1/rad C_{\\ell_\\beta} \\dfrac{\\partial C_\\ell}{\\partial \\beta} Variation of rolling moment with sideslip angle 1/rad C_{n_\\beta} \\dfrac{\\partial C_n}{\\partial \\beta} Variation of yawing moment with sideslip angle 1/rad C_{Y_p} \\dfrac{\\partial C_Y}{\\partial (pb/2U_1)} Variation of side force with nondimensional roll rate 1/rad C_{\\ell_p} \\dfrac{\\partial C_\\ell}{\\partial (pb/2U_1)} Variation of rolling moment with nondimensional roll rate 1/rad C_{n_p} \\dfrac{\\partial C_n}{\\partial (pb/2U_1)} Variation of yawing moment with nondimensional roll rate 1/rad C_{Y_r} \\dfrac{\\partial C_Y}{\\partial (rb/2U_1)} Variation of side force with nondimensional yaw rate 1/rad C_{\\ell_r} \\dfrac{\\partial C_\\ell}{\\partial (rb/2U_1)} Variation of rolling moment with nondimensional yaw rate 1/rad C_{n_r} \\dfrac{\\partial C_n}{\\partial (rb/2U_1)} Variation of yawing moment with nondimensional yaw rate 1/rad C_{Y_{\\delta_a}} \\dfrac{\\partial C_Y}{\\partial \\delta_a} Variation of side force with aileron deflection 1/rad C_{\\ell_{\\delta_a}} \\dfrac{\\partial C_\\ell}{\\partial \\delta_a} Variation of rolling moment with aileron deflection 1/rad C_{n_{\\delta_a}} \\dfrac{\\partial C_n}{\\partial \\delta_a} Variation of yawing moment with aileron deflection 1/rad C_{Y_{\\delta_r}} \\dfrac{\\partial C_Y}{\\partial \\delta_r} Variation of side force with rudder deflection 1/rad C_{\\ell_{\\delta_r}} \\dfrac{\\partial C_\\ell}{\\partial \\delta_r} Variation of rolling moment with rudder deflection 1/rad C_{n_{\\delta_r}} \\dfrac{\\partial C_n}{\\partial \\delta_r} Variation of yawing moment with rudder deflection 1/rad <p></p> Cross-Coupled Derivatives <p></p> Symbol Formula Description Units C_{L_\\beta} \\dfrac{\\partial C_L}{\\partial \\beta} Variation of lift with sideslip angle 1/rad C_{L_p} \\dfrac{\\partial C_L}{\\partial (pb/2U_1)} Variation of lift with nondimensional roll rate 1/rad C_{L_r} \\dfrac{\\partial C_L}{\\partial (rb/2U_1)} Variation of lift with nondimensional yaw rate 1/rad C_{L_{\\delta_a}} \\dfrac{\\partial C_L}{\\partial \\delta_a} Variation of lift with aileron deflection 1/rad C_{L_{\\delta_r}} \\dfrac{\\partial C_L}{\\partial \\delta_r} Variation of lift with rudder deflection 1/rad C_{D_\\beta} \\dfrac{\\partial C_D}{\\partial \\beta} Variation of drag with sideslip angle 1/rad C_{D_p} \\dfrac{\\partial C_D}{\\partial (pb/2U_1)} Variation of drag with nondimensional roll rate 1/rad C_{D_r} \\dfrac{\\partial C_D}{\\partial (rb/2U_1)} Variation of drag with nondimensional yaw rate 1/rad C_{D_{\\delta_a}} \\dfrac{\\partial C_D}{\\partial \\delta_a} Variation of drag with aileron deflection 1/rad C_{D_{\\delta_r}} \\dfrac{\\partial C_D}{\\partial \\delta_r} Variation of drag with rudder deflection 1/rad <p></p> <p>Note</p> <p>All derivatives evaluated at reference condition (stability-axis system). Rate terms use nondimensional rates \\frac{pb}{2U_1}, \\frac{q\\bar{c}}{2U_1}, \\frac{rb}{2U_1}. Units: angle/control = 1/rad.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-appendix/#references-helpful-links-and-documentation","title":"References, Helpful Links, and Documentation","text":"<ul> <li>Online NACA Databases</li> <li>NACA Database 2</li> <li>Aircraft Dynamic Models Database</li> <li>NASA Aircraft Analysis Paper</li> <li>How to Find Inertia Tensors for a Small Aircraft</li> <li>Stability and Control Crash Course</li> <li>Flight Vehicle and Aerodynamic Design Textbook</li> <li>Xflr5 Documentation</li> <li>Xflr5 Documentation (PDF)</li> <li>OpenVSP Documentation</li> <li>OpenVSP Google groups</li> <li>OpenVSP Example Videos</li> <li>Xflr5 Tutorial Videos</li> <li>Xflr5 Stability Analysis Documentation and Tutorials</li> <li>Stability Analysis Documentation and Tutorials (flow5)</li> <li>Stability Analysis Documentation and Tutorials (PDF)</li> <li>Research papers using Xflr5 and/or OpenVSP (Barrella)</li> <li>Research papers using Xflr5 and/or OpenVSP (Vincenti)</li> <li>Research papers using Xflr5 and/or OpenVSP (VT)</li> <li>Research papers using Xflr5 and/or OpenVSP (UAV)</li> <li>Research papers using Xflr5 and/or OpenVSP (Cessna 172N)</li> <li>ICAS 2022 Paper Comparing Xflr5 and OpenVSP</li> </ul>"},{"location":"user-guide/tutorials/user-manual-openvsp/","title":"OpenVSP","text":"<p>OpenVSP is a free, open-source aerodynamic modeling and analysis software tool based upon NASA aerodynamics tools. This tool is especially useful for modeling and analyzing full aircraft (including fuselage, propellers, landing gear, etc). These capabilites provide better drag estimates than many other tools such as Xflr5. OpenVSP also allows you to import background images to help with modeling your aircraft dimensions accurately and outputs a comprehensive stability coefficients file that are very helpful when analyzing aircraft. Besides these specific distinguishing factors, much of the functionality is similar to what is found in other software tools. There are many advanced modeling and analysis capabilities as well, such as structural analysis and wave drag estimates from supersonic flows. These will not be covered in this manual, but links to a series of useful resources at the end of this page may be helpful. </p> <p>Using OpenVSP, you can expect to relatively quickly produce a parametrized model of your entire aircraft that can be analyzed in a variety of flight configurations. </p> <p>The following quick-links will walk you through basic navigation of the software, step-by-step aircraft modeling and analysis instructions, a list of common errors, and a list of useful resources for users wishing to go more in depth. </p> <p>Quick Navigation:</p> <ul> <li>Navigation<ul> <li>File Tab</li> <li>Edit Tab</li> <li>Window Tab</li> <li>View Tab</li> <li>Model Tab</li> <li>Analysis Tab</li> </ul> </li> <li>Making a Model<ul> <li>Wings</li> <li>Fuselage</li> <li>Using Reference Background Images</li> </ul> </li> <li>Aircraft Analysis<ul> <li>Basic Analysis</li> <li>VSPAERO Stability Analysis</li> <li>Parasitic Drag</li> <li>Mass Properties</li> </ul> </li> <li>Common Errors<ul> <li>Meshing Problems</li> </ul> </li> <li>References List and Helpful Links</li> </ul>"},{"location":"user-guide/tutorials/user-manual-openvsp/#navigation","title":"Navigation","text":"<p>When OpenVSP first opens on your computer, you will see an empty screen with a menu up top. The following slides will go through important menu options.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#file-tab","title":"File Tab","text":"<p>The \"File\" tab contains navigation options to save, export, and open projects. In the \"Open VSP file\" box, navigate to the file you want to open and click \"Accept.\"</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#edit-tab","title":"Edit Tab","text":"<p>The \"Edit\" tab provides useful tools for setting parameter values during model creation and analysis. The most useful option in the \"Edit\" tab is the \"Undo Parameter Change\". Use this to return to previous parameter values during aircraft design and analysis.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#window-tab","title":"Window Tab","text":"<p>The \"Window\" tab allows you to customize the viewing windows. The \"Background\" tool is especially useful when creating aircraft models. Import a picture or drawing of an aircraft to help with dimensioning or relative positioning. The \"Background\" button allows you to import images into the background to aid in aircraft dimensioning and accurate modeling.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#view-tab","title":"View Tab","text":"<p>The \"View\" tab allows you to easily change the orientation of your model in the viewer.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#model-tab","title":"Model Tab","text":"<p>The \"Model\" tab contains useful tools for creating a model. Click on the \"Geometry\" button to open the geometry browser. Select the \"Geometry\" button to open the Geometry browser. This is where every component of your model will be created and stored. The Geometry Browser contains a variety of useful modeling tools. These will be discussed in more detail in the modeling section.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#analysis-tab","title":"Analysis Tab","text":"<p>In the \"Analysis\" tab you can find several helpful analysis tools for performing mass properties, drag, aerodynamic, and stability analyses. Use \"Mass Prop\" to find CG and moment of inertia calculations. Use VSPAERO for all aerodynamic and stability analyses. Use Parasite Drag for the most accurate drag estimates of your model.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#making-a-model","title":"Making a Model","text":""},{"location":"user-guide/tutorials/user-manual-openvsp/#wings","title":"Wings","text":"<p>In the \"Model\" tab, select the \"Geometry\" tool to open the model geometry browser.  </p> <p>  Select the geometry creation tool by clicking the drop down menu at the top of the window. After selecting your geometry item, click \"add\".  </p> <p>  After adding a geometry item, the geometry editor tool will open and allow you to customize the geometry.  </p> <p>  The general tab allows you to name your items, customize material and color properties, and assign them to specific geometry subsets.  </p> <p>Use the Xform tab to define the position, orientation, and other general characteristics of the wing.  </p> <p>  Define the Mass and physical properties of the item in the \"Mass\" tab.  </p> <p>  In the \"Sub\" tab, define subsections of the wing, such as control surfaces.  </p> <p>  After creating a control surface, a \"sub surface parameters\" section will appear. Use these tools to define the control surface position, size, functionality etc.  </p> <p>  In the \"Plan\" tab, define planform dimensions and other orientation details.  </p> <p>  For each section of the wing, define the size dimensions.  </p> <p>  Import airfoils and define airfoils for each wing section in the airfoil tab.  </p> <p>  The Blending and Modify tabs have tools to blend airfoils together and edit the edge characteristics. These are more technical options that are outside of the scope of this manual.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#fuselage","title":"Fuselage","text":"<p>Select the geometry creation tool by clicking the drop-down menu at the top of the window. After selecting the \"fuselage\" geometry item, click \"add\".  </p> <p>  The \"Xform\", \"Mass\", and \"Sub\" tabs are very similar to those for wings. Use these tabs to define the position, orientation, mass, and substructures of the fuselage.  </p> <p></p> <p>Go through these tabs to define the position, orientation, mass, and substructures of the fuselage.  </p> <p>In the \"Design\" tab, define the main characteristics of your fuselage.  </p> <p>  Define the length of your fuselage and other characteristics of the shape.  </p> <p>In the \"Xsec\" tab, you can customize the position, orientation, and shape of each section of the fuselage.  </p> <p>  In the \"Skinning\" tab, you can adjust the shape and curves of the outer surfaces on the fuselage.  </p> <p>  The \"Modify\" tab allows you to further edit the sections of the fuselage by adding \"chevron\" shapes (used to define more complex shape contours).  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#using-reference-background-images","title":"Using Reference Background Images","text":"<p>When modeling an aircraft, OpenVSP allows you to add a reference background image to help with modeling your aircraft correctly.  </p> <p>Window &gt; Background  </p> <p>  In the \"Background\" pop-up window, make sure the image box is checked. Then, click on the three dots next to the \"File\" box to select the image you want to import.  </p> <p>  Select the image you want to import and click the \"Accept\" button.  </p> <p>  After your background image is imported, align your model with it to create accurate dimensions for your model.  </p> <p>  Multiple images can be imported to aid in building your model from all angles. For instance, import top, side, and front view images to make sure your model is accurate from all perspectives.</p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#aircraft-analysis","title":"Aircraft Analysis","text":""},{"location":"user-guide/tutorials/user-manual-openvsp/#basic-analysis","title":"Basic Analysis","text":"<p>To run a basic aerodynamic analysis:  </p> <p>Analysis (menu) &gt; Aero &gt; VSPAERO  </p> <p>A basic aerodynamic analysis computes the aircraft's aerodynamic state at a variety of positions and angles of attack. This is very useful for understanding the basic characteristics (lift, drag, static margin) of the aircraft. It does not involve any control surfaces and thus does not compute stability and control derivatives.  </p> <p>  Click on the \"Advanced\" tab at the top and define the analysis settings.  </p> <p>  In the \"Overview\" tab, define the rest of the analysis settings, then click \"Launch Solver\" at the bottom.  </p> <p>  When the analysis is finished, a results manager tab will open. On the \"Load Dist.\" tab, you can see charts portraying a variety of aerodynamic coefficients across the span of the wing.  </p> <p>  The \"Convergence\" tab shows the precision of the coefficient calculations.  </p> <p>  The \"Sweep\" tab allows you to compare relationships between aerodynamic coefficients.  </p> <p>  After an analysis is completed, OpenVSP will produce several files with information with the analysis outputs. These files will appear in the same folder that you saved your original project in. The most useful file produced from the Basic Analysis is the \"Polar\" file that contains each coefficient calculated at each point of the analysis sweep.  </p> <p>  After opening the polar file, you will see a list of all the analysis iterations (each point along the defined sweep) and the corresponding aerodynamic coefficient outputs.  </p> <p></p> <p>In my analysis, I defined the sweep from 0-5 deg angle of attack. A useful analysis could be looking at the change in lift coefficient with alpha.</p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#vspaero-stability-analysis","title":"VSPAERO Stability Analysis","text":"<p>A stability analysis allows you to calculate the stability and control derivatives of your aircraft.  </p> <p>Analysis &gt; Aero &gt; VSPAERO  </p> <p></p> <p>In the \"Overview\" tab, set up the main settings of the analysis.  </p> <p>You should actuate only one group of control surfaces per stability analysis. For this reason, you will most likely need to run several stability analyses.  </p> <p>Example: have one stability analysis with ailerons activated to get the aileron control derivatives, and another analysis to get the elevator control derivatives.  </p> <p>  In the Advanced tab, make sure the run mode is set to \"Steady\" and the advanced flow conditions are appropriate for your flight situation. (default units are in SI)  </p> <p>  In the \"Control Grouping\" tab, select specific control surfaces to assign to control groups for the analysis.  </p> <p>  After defining all of the analysis settings, return to the \"Overview\" tab and click the \"Launch Solver\" button at the bottom of the window.  </p> <p>  When the analysis is finished, a results manager tab will open. On the \"Load Dist.\" tab, you can see charts portraying a variety of aerodynamic coefficients across the span of the wing.  </p> <p>  The \"Convergence\" tab shows the precision of the coefficient calculations.  </p> <p>  The \"Sweep\" tab allows you to compare relationships between aerodynamic coefficients.  </p> <p>  After an analysis is completed, OpenVSP will produce several files containing the analysis outputs. These files will appear in the same folder that you saved your original project in. The most useful files produced from the stability analysis are the (.stab) file and the (.flt) file.  </p> <p>  The .stab file contains all of the main aircraft dimensions and the dimensional and non-dimensional stability derivatives of the aircraft.  </p> <p>  The .flt file contains the stability derivatives arranged in a more explicitly defined list. The values are the same as the .stab file; however, the CD_o value is different. This seems to be the more accurate drag value, and may include other sources of drag not accounted for in the .stab file.  </p> <p></p> <p>*** IMPORTANT NOTE ***  In the ROSplane parameters, C_D_p is \"parasitic drag\", NOT drag from roll rate. Make sure to take this into account when building your model and inputting values into your .yaml file. </p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#parasitic-drag","title":"Parasitic Drag","text":"<p>Parasitic drag can be analyzed using the drag analysis tool in the Analysis tab. This tool allows you to estimate the drag produced by the aircraft's components.  </p> <p>Analysis &gt; Aero &gt; Parasite Drag  </p> <p></p> <p>Make sure the analysis settings are accurate, then calculate the drag.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#mass-properties","title":"Mass Properties","text":"<p>The mass properties tool provides information about the mass distribution and center of gravity of your model.  </p> <p>Analysis &gt; Mass Prop.  </p> <p>  Click the \"Compute\" button and the mass and inertia values should appear in the boxes below.  </p> <p>  After performing a mass properties analysis, the slidesd model of the geometry will appear on the model viewer.  </p> <p>To go back to viewing the original model, select \"MeshGeom\" in the geometry list and then click either \"NoShow\" or \"Delete\".  </p> <p>Then drag select all of the geometry parts of your aircraft and click \"Show\".  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#common-errors","title":"Common Errors","text":""},{"location":"user-guide/tutorials/user-manual-openvsp/#meshing-problems","title":"Meshing Problems","text":"<p>If you encounter meshing problems, use the mesh diagnostics tool to identify and resolve issues with the mesh.  </p> <p>OpenVSP uses a panel and vortex lattice method to calculate the aerodynamic forces, moments, and coefficients. If there are any problems with the meshing of your model, these calculations may result in extreme values.  </p> <p>Any mesh problems can be identified by asymptotic behavior on the plots.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-openvsp/#references-list-and-helpful-links","title":"References List and Helpful Links","text":"<ul> <li>OpenVSP Documentation</li> <li>Google groups</li> <li>Example Videos</li> <li>Example Research Papers (Barrella)</li> <li>Example Research Papers (Vincenti)</li> <li>Example Research Papers (VT)</li> </ul>"},{"location":"user-guide/tutorials/user-manual-xflr5/","title":"Xflr5","text":"<p>Xflr5 is a free, open-source aerodynamic modeling and analysis software tool based upon the aerodynamics work done by Mark Drela, an MIT professor specializing in aerodynamic analysis and aircraft flight dynamics. This tool directly integrates with additional aerodynamic analysis software tools such as Xfoil and AVL and can export / import compatible files between them. </p> <p>This tool is especially useful for modeling and analyzing the lifting surfaces of an aircraft (wing and tail). Xflr5 also has an entire airfoil analysis and optimization suite, which provides powerful analysis tools for users looking to improve their fundamental flight characteristics. This tool also has more intuitive stability and control visualizations. Besides these specific distinguishing factors, much of the functionality is similar to what is found in other software tools. </p> <p>Using Xflr5, you can expect to relatively quickly produce a model of the lifting surfaces of your aircraft and analyze them in a variety of flight configurations. </p> <p>The following quick-links will walk you through basic navigation of the software, step-by-step aircraft modeling and analysis instructions, an overview of all of the visualization tools available, a list of common errors, and a list of useful resources for users wishing to go more in depth. </p> <p>Quick Navigation:</p> <ul> <li>Navigation<ul> <li>Direct Foil Design</li> <li>Xfoil Inverse Design</li> <li>Xfoil Direct Analysis</li> <li>Wing and Plane Design</li> </ul> </li> <li>Creating and Analyzing Airfoils<ul> <li>Direct Foil Design</li> <li>Adding NACA Foils</li> <li>Adding .dat Files</li> <li>Adding Flaps</li> <li>Inverse Foil Design</li> <li>XFoil Direct Analysis</li> </ul> </li> <li>Creating a Plane<ul> <li>Information Checklist</li> <li>Making the Plane</li> <li>Mass and Inertia Inputs</li> </ul> </li> <li>Running an Analysis<ul> <li>Basic Analysis</li> <li>Stability Analysis</li> </ul> </li> <li>Reading Graphs<ul> <li>Overview</li> <li>OpPoint Viewer</li> <li>Polar Viewer</li> <li>Root Locus Viewer</li> <li>Time Response Viewer</li> <li>Pressure Viewer</li> <li>Changing Graphs</li> <li>Customizing Visuals</li> </ul> </li> <li>Common Errors<ul> <li>Outside Flight Envelope</li> <li>Can't be Interpolated</li> <li>Negative Lift</li> </ul> </li> <li>References List and Helpful Links</li> </ul>"},{"location":"user-guide/tutorials/user-manual-xflr5/#navigation","title":"Navigation","text":"<p>To download XFLR5, go to the XFLR5 website.</p> <p>Once downloaded, open the XFLR5.exe file to start the program.</p> <p> Once XFLR5 is open, you will see the main menu screen.</p> <p>The menu bar is located at the top of the screen.</p> <p>Under the File tab you can open and save projects. In the Module tab you can access the different modules of XFLR5.</p> <p> These modules contain the different tools and features of XFLR5.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#direct-foil-design","title":"Direct Foil Design","text":"<p>Direct Foil Design is where you will create, import, edit, and save each airfoil for your aircraft. </p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#xfoil-inverse-design","title":"Xfoil Inverse Design","text":"<p>Xfoil Inverse Design is where you reverse engineer an optimal foil shape by editing airfoil performance curves.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#xfoil-direct-analysis","title":"Xfoil Direct Analysis","text":"<p>Xfoil Direct Analysis is where you can analyze airfoils in each expected flight condition (determined by a range of Reynolds numbers).  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#wing-and-plane-design","title":"Wing and Plane Design","text":"<p>Wing and Plane Design is where you can use your previously analyzed airfoils to model and analyze the performance/stability of a complete aircraft.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#creating-and-analyzing-airfoils","title":"Creating and Analyzing Airfoils","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#direct-foil-design_1","title":"Direct Foil Design","text":"<p>The first step in modeling an aircraft is defining the airfoils used in the aircraft.  </p> <p>Module &gt; Direct Foil Design  </p> <p> Prerequisite: You must already know the NACA code or have a .dat file on hand for every airfoil on each section of the wing, elevator, and rudder.  </p> <p>Direct Foil Design is where you will create, import, edit, and save each airfoil for your aircraft.  </p> <p>  SAVE CONSTANTLY!</p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#adding-naca-foils","title":"Adding NACA Foils","text":"<p>NACA foils are standardized airfoils commonly defined by a 4-digit code (ex. 2412).  </p> <p>To import a NACA foil: &gt; Foil &gt; Naca Foils  </p> <p>  Enter the NACA code and the number of desired panels for the airfoil you want to add.   </p> <p>Click OK.  </p> <p>  Enter the name of your airfoil into the popup box and click OK.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#adding-dat-files","title":"Adding .dat Files","text":"<p>You can also add a custom airfoil by importing a .dat file of the airfoil shape.  </p> <p>To add a .dat airfoil: &gt; File &gt; Open &gt; Select .dat file from your computer &gt; Open  </p> <p>  The newly imported airfoil will appear here.</p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#adding-flaps","title":"Adding Flaps","text":"<p>Once your airfoil is added to your project, you can edit the airfoil and add control surfaces.  </p> <p>To add a flap to the airfoil: right click on your airfoil, then click \"Set Flap\"  </p> <p>  Click the box for a leading edge (LE) and/or tailing edge (TE) flap.  </p> <p>Input the flap characteristics (angle, position along chord, position of hinge)  </p> <p>Click OK  </p> <p>  Enter the name of your new airfoil and click OK. Click \"Overwrite\" if you don't want to add a new airfoil.  </p> <p>  You can edit any airfoil by right clicking it and using the drop-down menu.  </p> <p>Repeat these steps for every airfoil in your aircraft with control surfaces.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#inverse-foil-design","title":"Inverse Foil Design","text":"<p>Inverse Foil Design allows you to create a custom airfoil based off desired performance characteristics.  </p> <p>Module &gt; Xfoil Inverse Design  </p> <p>  See the graphic below for an overview of the tools in Xfoil Inverse Design  </p> <p>  To start, import the foil you want to edit.  </p> <p>Click on the \"extract foil\" button.  </p> <p>Click on the foil you want to modify then click \"OK\".  </p> <p>  Next, choose what flight condition context you want to modify your airfoil in and activate the spline function.  </p> <p>  Move the spline to create the curve you want your airfoil to reflect.  </p> <p>  After your custom spline is complete, click \"execute\" to create your spline.  </p> <p>  Once the airfoil is created, it can be exported by selecting the \"Foil\" tab at the top and then the \"Store Foil\" option.  </p> <p>  Name your airfoil, then click the \"OK\" button to save your new airfoil.  </p> <p>This airfoil can now be added to your project and analyzed in Xfoil Direct Analysis.</p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#xfoil-direct-analysis_1","title":"XFoil Direct Analysis","text":"<p>Each airfoil must be individually analyzed at every expected flight condition before it can be used in a full aircraft analysis.  </p> <p>Module &gt; XFoil Direct Analysis  </p> <p>This tool basically analyzes how the airfoils will behave at a variety of airspeeds and angles of attack.  </p> <p>Prerequisites: Know the expected Reynolds numbers of each flight condition (airspeed etc.) for the aircraft.  </p> <p>  After opening XFoil Direct Analysis, you will see the following viewer.  </p> <p>  Click \"Analysis\", then click \"Batch Analysis\".  </p> <p>  Note: Batch analysis performs many analyses simultaneously across a variety of flight conditions to save time. If you want to analyze the airfoil at a single Reynolds number, choose \"Define an Analysis\" instead.  </p> <p>  Select the airfoils you want to analyze in the top list, specify the range of Reynolds numbers over which you want to analyze the airfoil, select any other desired polar specifications (alpha sweep etc), and click \"Analyze\". Click \"Close\" when finished.  </p> <p>  The graphs on the viewer will update after the analysis is completed. In the top menu, the chart icon on the right will show you polar views (drag, lift polars etc.)  </p> <p>  The OpPoint viewer icon is on the left. This viewer will show you performance distributions across the airfoil at specific flight situations (e.g. pressure distributions at a specific angle of attack, flow separation, etc.)  </p> <p>  To change any of the graphs, right click on the graph, then select \"Current Graph\" and \"Define Graph Settings\". This will allow you to customize the axes and any other graph information.  </p> <p>  To change the lines on the graphs (color, weight, etc) right click on the airfoil or operating point on the list on the left then select your desired line characteristics.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#creating-a-plane","title":"Creating a Plane","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#information-checklist","title":"Information Checklist","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#making-the-plane","title":"Making the Plane","text":"<p>Open the \"Wing and Plane Design\" tab in the top left menu.   To begin modeling your aircraft, click on \"Plane\" on the top left menu. Then select \"Define a New Plane\".  </p> <p>  Once the \"Plane Editor\" opens, you will be able to define the wing, elevator, rudder, and weight distribution of the aircraft.  </p> <p>  To create a wing, first click the \"Symmetric\" button (depending on your wing design). Next, begin inputting your wing data into the table below. Input the airfoil and airfoil position for each section of the wing into the table. Make sure your measurements are in meters. (Reminder: your airfoils must already be created in Foil Design and analyzed in Xfoil Direct Analysis).  </p> <p>  Note: You should have a measurement for every major change in the wing. If there is a change in airfoil (such as the start of end of a flap), you will have two overlapping measurements at that transition point.  </p> <p>  Once the wing is defined, make sure that your wing matches your design, and that each airfoil transition overlaps correctly. (Note: the control surfaces do not need to be angled unless you are specifically analyzing at an actuated position. A zero angle will still suffice for a stability analysis as long as the control surface hinge exists).  </p> <p>  Next, check the paneling on the wing. On the lower right menu, toggle the \"Surfaces\" button off and the \"Panels\" button on. Set the Y-panels over long sections to fill the space and set the distribution to \"Cosine\" so the edges of the sections have more panels than the middle. Set overlapped sections to 1.  </p> <p>  Click \"Save\" when you are done.  </p> <p>Once your wing is defined and saved, define the position of the leading edge and the initial geometric tilt angle.   </p> <p>Follow the same steps for the elevator and rudder.  </p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#mass-and-inertia-inputs","title":"Mass and Inertia Inputs","text":"<p>After all your lifting surfaces are correctly defined, click on the \"Plane Inertia\" button to define the weight distribution of your aircraft.  </p> <p>  Input the mass and position of each important mass of the aircraft.  </p> <p></p> <p>Validate that your weight distribution is accurate by comparing your CG and inertia tensor values with experimental values.  </p> <p>  You can also validate your mass distribution by toggling on the \"masses\" button on the Plane Editor page and visually inspecting the location of the CG.</p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#running-an-analysis","title":"Running an Analysis","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#basic-analysis","title":"Basic Analysis","text":"<p>A basic analysis will help you obtain information about lift, drag, moments from the airfoils, and other basic aerodynamic characteristics of your aircraft.  </p> <p>Analysis &gt; Define an Analysis  </p> <p>  Once the Analysis Definition box opens, in the Polar Type tab choose your desired polar type. (Fixed lift is recommended because it automatically trims the aircraft)  </p> <p>  In the Analysis tab, choose your desired analysis method (VLM2 is recommended) and whether or not to include viscous flows.  </p> <p>  In the Inertia tab, check the \"Use plane inertia\" box and change nothing (assuming you already accurately defined your plane inertia). Otherwise, uncheck the box and define your Mass and CG location manually.  </p> <p>  In the Ref. dimensions tab, select the dimensions you want to use for your aerodynamic coefficient calculations.  </p> <p></p> <p>In the Aero data tab, ensure the density and viscosity measurements are accurate to your expected flight environment.  </p> <p>Leave \"Ground Effect\" unchecked, unless you are simulating takeoff and landing.  </p> <p>  In the Extra drag tab, add any extra drag areas and drag coefficients in the corresponding table. Xflr5 only accurately simulates airflow over the lifting surfaces of the aircraft, so the drag from the fuselage, landing gear, or any other parts of the aircraft need to be accounted for separately.  </p> <p>A simple way to estimate extra drag is to calculate the cross-sectional area of the other parts of the aircraft and use a drag coefficient from a similar shape (sphere, cone, etc).  </p> <p>Click \"Save\" when you are done.  </p> <p>  A popup tab will appear. Type your desired identifier or name of your analysis.  </p> <p>Click \"OK\" when you are done.  </p> <p></p> <p>Your analysis is now defined, and ou can now run it.  </p> <p>Choose your analysis from the left, define the parameters on the right, and click \"analyze\".  </p> <p>  Wait until the analysis is completed, the click the close button.  </p> <p>  On the home screen, you will see the analysis has updated. On the left you can select specific points of the analysis. In the middle you will see charts visualizing the analysis data. You can move between visualization by using the plot menu at the top.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#stability-analysis","title":"Stability Analysis","text":"<p>A stability analysis will allow you to evaluate the stability and control derivatives as well the time response of the aircraft to disturbances.  </p> <p>Stability Analysis Prerequisites: </p> <ul> <li>Airfoil polars analyzed (Xfoil Direct Analysis)</li> <li>Basic aerodynamic analysis performed</li> <li>Cm \u2013 alpha curve has a positive x-intercept</li> <li>Cm \u2013 CL curve must have a positive CL value at 0 Cm</li> <li>Aircraft inertia tensors and center of gravity are correct</li> <li>Control surface dimensions, position, and paneling must be accurate and appropriate</li> </ul> <p>You should actuate only one group of control surfaces in a stability analysis. For this reason, you will most likely need to run several stability analyses.  </p> <p>Example: have one stability analysis with ailerons activated to get the aileron control derivatives, and another analysis to get the elevator control derivatives.  </p> <p>To setup your stability analysis, select the aircraft you want to analyze.  </p> <p>Analysis &gt; Define a Stability Analysis  </p> <p>  Once the Stability Polar Definition box opens, define any relevant analysis constraints in the Analysis tab.  </p> <p>  In the Ref. dimensions tab, select the dimensions you want to use for the stability and control coefficient calculations.  </p> <p>  In the Mass and inertia tab, check the \"Use plane inertia\" box at the top and change nothing (assuming you already accurately defined your plane inertia); Otherwise, uncheck the box and define your Mass and CG location manually.  </p> <p>  In the \"Control parameters\" tab, select the control surfaces to analyze.  </p> <p>To calculate control derivatives for each set of control surfaces (ailerons, rudder, elevator) it is recommended to perform a stability analysis for each set individually.  </p> <p>It is not recommended to activate multiple control surfaces at once. Ailerons should be actuated in opposite directions and elevators are in the same direction.  </p> <p>  In the Aero data tab, ensure the density and viscosity measurements are accurate to your expected flight environment.  </p> <p>  In the Extra drag tab, add any extra drag areas and drag coefficients in the corresponding table. Xflr5 only accurately simulates airflow over the lifting surfaces of the aircraft, so the drag from the fuselage, landing gear, or any other parts of the aircraft need to be accounted for separately.  </p> <p>A simple way to estimate extra drag is to calculate the cross-sectional area of the other parts of the aircraft and use a drag coefficient from a similar shape (sphere, cone, etc).  </p> <p>Click \"Save\" when you are done.  </p> <p>  Select the analysis you want to run and double check your analysis is defined correctly.   Set the analysis settings, and click \"Analyze\".  </p> <p>  While the analysis is being performed you will see a \"3D Panel Analysis\" box displaying the test code. If there are no errors, the box will automatically close. In the case of errors, the box will remain open and you will need to close it manually.  </p> <p>  Feel free to look through the test code after the analysis is performed.  </p> <p>After the analysis is complete, save your work immediately.  </p> <p>To explore the analysis results, click on the analysis from the list on the left.  </p> <p>  To see specific outputs or results, click on an operating point from the analysis.  </p> <p>Aerodynamic, stability, and control derivatives are in the box at the bottom left.  </p> <p>  A more in-depth record of the analysis outputs can be found in the log file.  </p> <p>Analysis &gt; View Log File  </p> <p>  The log file contains the complete outputs at each point of the analysis such as each stability and control derivative, state matrices, and stability response modes.  </p> <p>  The analysis output tab on the bottom left shows all of the outputs for the selected point of the analysis.  </p> <p></p> <p>*** IMPORTANT NOTE ***  In the ROSplane parameters, C_D_p is \"parasitic drag\", NOT drag from roll rate. Make sure to take this into account when building your model and inputting values into your .yaml file. </p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#reading-graphs","title":"Reading Graphs","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#overview","title":"Overview","text":"<p>On the home screen, you will see the analysis has updated. On the left you can select specific points of the analysis. In the middle you will see charts visualizing the analysis data. You can move between visualization by using the plot menu at the top.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#oppoint-viewer","title":"OpPoint Viewer","text":"<p> The OpPoint viewer shows several charts that display spanwise aerodynamic data at specific points of the analysis (e.g. at specific angles of attack)  </p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#polar-viewer","title":"Polar Viewer","text":"<p>The polar viewer shows aerodynamic trends across the whole analysis and specifically how they relate to each other (e.g. how lift coefficient relates to angle of attack)  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#root-locus-viewer","title":"Root Locus Viewer","text":"<p>The root locus viewer shows the roots of the aircraft response to disturbances.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#time-response-viewer","title":"Time Response Viewer","text":"<p>The time response viewer shows the aircraft response to disturbances as a function of time.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#pressure-viewer","title":"Pressure Viewer","text":"<p>The pressure viewer shows the pressure distributions across the lifting surfaces of the wing at specific operating points of the analysis.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#changing-graphs","title":"Changing Graphs","text":"<p>To change any of the graphs, right click on the graph, then select \"Current Graph\" and \"Define Graph Settings\". This will allow you to customize the axes and any other graph information.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#customizing-visuals","title":"Customizing Visuals","text":"<p>To change the lines on the graphs (color, weight, etc) right click on the airfoil or operating point on the list on the left then select your desired line characteristics.  </p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#common-errors","title":"Common Errors","text":""},{"location":"user-guide/tutorials/user-manual-xflr5/#outside-flight-envelope","title":"Outside Flight Envelope","text":"<p>Cause: Your batch analysis includes angle of attack (\u03b1), Reynolds number (Re), or Mach number values beyond the range where data has been defined or computed for your airfoil(s).  </p> <p>To Fix:  </p> <ul> <li> <p>Go to the \"Batch Analysis\" settings.  </p> </li> <li> <p>Restrict the angle of attack and Reynolds number range to within what you've previously analyzed in the airfoil polar analysis (e.g., -5\u00b0 to +15\u00b0, 50,000 \u2264 Re \u2264 1,000,000).  </p> </li> <li> <p>Make sure your aircraft's velocity, altitude, and configuration don't push the operating point outside of what was analyzed.  </p> </li> <li> <p>Expand your airfoil batch analysis or restrict the plane analysis until they are both consistent.</p> </li> </ul> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#cant-be-interpolated","title":"Can't be Interpolated","text":"<p>Cause: XFLR5 failed to interpolate a value because a requested parameter (e.g., lift coefficient or moment) is between or outside available data points.  </p> <p>To Fix:  </p> <ul> <li> <p>Check that your airfoil polar data is dense enough. You might need more data points at smaller intervals in AoA or Re.  </p> </li> <li> <p>Re-run your airfoil analysis with finer steps, e.g., AoA from -6\u00b0 to 16\u00b0 in 0.5\u00b0 increments.  </p> </li> <li> <p>Ensure matching Reynolds numbers between your airplane analysis and airfoil polar data. </p> </li> </ul>"},{"location":"user-guide/tutorials/user-manual-xflr5/#negative-lift","title":"Negative Lift","text":"<p>Cause: at the angle of attack analyzed, the airfoil does not have positive lift (it falls)  </p> <p>To Fix:  </p> <ul> <li> <p>Check the wing incidence angle and orientation in your model are correct.  </p> </li> <li> <p>Check that your range of tested values in your analysis are appropriate.  </p> </li> </ul> <p>If the above test reveal no problems, then this probably is not a problem and simply identifies an angle of attack that your aircraft cannot sustain.</p> <p></p>"},{"location":"user-guide/tutorials/user-manual-xflr5/#references-list-and-helpful-links","title":"References List and Helpful Links","text":"<ul> <li>Xflr5 Documentation</li> <li>Xflr5 Documentation (PDF)</li> <li>Stability Analysis Documentation and Tutorials</li> <li>Stability Analysis Documentation and Tutorials (flow5)</li> <li>Stability Analysis Documentation and Tutorials (PDF)</li> <li>Publications Using Xflr5</li> <li>Tutorial Videos</li> </ul>"}]}