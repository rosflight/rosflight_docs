{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"home/","title":"Welcome to ROSflight","text":"<p>ROSflight is an autopilot system designed from the ground up with researchers in mind, and for easy integration with ROS. Its purpose is to accomplish two main tasks:</p> <ol> <li>Stream high-rate sensor data from the embedded flight controller to ROS</li> <li>Provide a simple API for sending control setpoints to the embedded flight controller</li> </ol> <p>A ROSflight setup consists of two main components:</p> <ol> <li>The embedded flight controller: Typically an OpenPilot Revo or one of its variants, running the ROSflight firmware</li> <li>The companion computer: Any computer that runs ROS, is located on the vehicle, and has a physical serial connection to the embedded flight controller</li> </ol>"},{"location":"home/#why-rosflight","title":"Why ROSflight?","text":"<p>There are a lot of excellent autopilots out there with a lot of great firmware options. Why did we feel like the world needed ROSflight? Because in our experience none of the other available options satisfied our research needs. Specifically, we needed an autopilot that could stream sensor data at high rates, easily accept control setpoints from a companion computer, and accomplish all of this with a lean, easy-to-understand code base.</p> <p>The other options that we tried were limited in bandwidth for streaming sensor data, and the APIs for sending control setpoints were confusing and difficult to implement. Perhaps most importantly, the code was sometimes so complex (feature-rich, but complicated) that it was difficult to figure out what the autopilot was actually doing. In talking to other researchers and industry members, we found that many people shared similar frustrations. So we decided to create and share the autopilot we wanted, hoping it will be useful to other people as well.</p>"},{"location":"home/#our-vision","title":"Our Vision","text":"<p>Perhaps more important than what we are trying to accomplish with ROSflight is what we are not trying to accomplish. This is not intended to be, out-of-the-box, a fully-featured autopilot for high-level tasks such as autonomous GPS waypoint following. There are many good autopilots out there that already do this. Instead, ROSflight is intended to provide the minimal functionality required to keep a multirotor or fixed-wing vehicle in the air, and to serve as a building block for writing new code to perform these higher-level tasks. (The ROSplane and ROScopter projects are excellent examples of what can be accomplished by building on top of the ROSflight architecture.)</p> <p>Therefore, one of the primary objectives of the ROSflight autopilot is to avoid feature creep and remain lean. We hope that others will extend our code and build on top of it, and would love to hear about your successes. But for the most part, we will not be incorporating these new features back into the main project. Instead, we hope that ROSflight will remain a lean, core code base that will continue to serve as a launch pad for exciting new projects and applications.</p>"},{"location":"home/contribution-guidelines/","title":"Contributing to the Firmware","text":"<p>Note</p> <p>These documents are designed to help developers get up and running on developing new features by explaining firmware internals. Development is currently supported only on Ubuntu Linux 18.04.</p> <p>Per our vision stated in the introduction, ROSflight is intended to be a streamlined, bare-bones autopilot. We welcome any bug fixes, cleanup, or other contributions which do not add complexity or detract from the readability and simplified nature of the firmware. We hope that the firmware is useful, but in an attempt to avoid \"feature creep,\" we will be very discriminatory in merging pull requests whose purpose is to simply add features. Forking the repository in order to add features is totally acceptable and encouraged, just stay in contact with us, and recognize us as the original authors of the autopilot (per the agreement in the BSD-3 license).</p> <p>In addition, we strive to maintain a very high standard of quality in terms of code style, variable naming, and the like. We will likely be nit-picky and perhaps a little harsh about this in pull requests. Please do not be offended. By maintaining a high standard, we hope that the code will continue to be useful, understandable, and cohesive in nature.</p> <p>Pull requests are also required to pass the automated unit tests. You can test your changes against these unit tests before pushing by executing the <code>run_tests.sh</code> script in the <code>scripts</code> directory of the firmware repo.</p> <p>Although we strive for complete in-code documentation, in practice this often gets left behind for the sake of rapid development. If you, as a potential developer, find some portion of documentation unsatisfactory, we welcome questions on the GitHub issues page or forum, and pull requests which improve documentation. Several new developers have started with first improving the documentation to get a handle on how things work.</p>"},{"location":"home/contribution-guidelines/#communication","title":"Communication","text":"<p>There are two channels to communicate with the developer team. For bug reports, feature requests, and anything to do with code, please open an issue on the appropriate firmware or ROS stack GitHub issue page. For questions and other discussions, please use the forum.</p>"},{"location":"home/style-guide/","title":"Style Guide","text":"<p>Any contributions to the firmware should adhere to the following style guidelines.</p>"},{"location":"home/style-guide/#white-space-and-line-endings","title":"White Space and Line Endings","text":"<p>Please try not to commit anything that only changes white space or line endings. To check if that's going to happen, run <code>git diff --check</code> before you stage your files. Git will warn you about obnoxious changes. Please fix them.</p>"},{"location":"home/style-guide/#code-style","title":"Code Style","text":"<p>The following ROSflight code style is based on the ROS C++ style guide. ROSflight uses the C++11 standard.</p>"},{"location":"home/style-guide/#indentation","title":"Indentation","text":"<p>Indentation should be 2 spaces (no tabs). Case statements in switch blocks should not be indented, e.g.</p> <pre><code>switch (variable)\n{\ncase 1:\n// do something\nbreak;\ndefault:\nbreak;\n}\n</code></pre>"},{"location":"home/style-guide/#braces","title":"Braces","text":"<p>Braces should be placed on the next line, e.g.</p> <pre><code>if (i &gt; 2)\n{\n// do stuff\n}\nelse\n{\n// do something else\n}\n</code></pre> <p>For a conditional with only one statement, the braces can be omitted but the statement should be indented:</p> <pre><code>if (i &gt; 2)\nx = 3;\n</code></pre>"},{"location":"home/style-guide/#spaces","title":"Spaces","text":"<p>There should be a space between <code>if</code>, <code>for</code>, or <code>while</code> and the condition, e.g. <code>while (true)</code>, not <code>while(true)</code>.</p>"},{"location":"home/style-guide/#naming-conventions","title":"Naming Conventions","text":"<ul> <li>Class names should be capitalized with no spaces (i.e. <code>StateManager</code>).</li> <li>Member variables should contain a post-pended underscore (i.e. <code>data_</code>).</li> <li>Member functions should be all lower case with underscores (i.e. <code>set_error()</code>).</li> <li>Integer types should be defined using the <code>cstdint</code> convention (i.e. <code>uint8_t</code>, <code>int64_t</code>, <code>float</code>, ...).</li> <li>Boolean values should be assigned <code>true</code> or <code>false</code>, not <code>0</code> or <code>1</code>.</li> </ul>"},{"location":"home/style-guide/#function-arguments","title":"Function Arguments","text":"<p>Primitive data types (<code>int</code>, <code>float</code>, etc.) should always be passed by value. Other types (e.g. classes) should be passed by reference and should maintain proper const-correctness. Arguments that are modified by the function should be passed by pointer instead of reference, to make the fact that the argument will be changed clearer in the calling code. For example:</p> <pre><code>void do_something(float dt, const MyClass&amp; data, int* output);\n</code></pre> <p>This function would be called as</p> <pre><code>float dt = 0.01f;\nMyClass my_class;\nint value;\n\ndo_something(dt, my_class, &amp;value);\n</code></pre> <p>This makes it clear the <code>value</code> is modified by the function call.</p>"},{"location":"home/style-guide/#classes","title":"Classes","text":"<p>All modules should be defined as a self-contained class. All member variables should be declared as \"private,\" named with a post-pended underscore, and accessed through inline accessor functions. All accessible data should be encapsulated in a struct. For example, here is a snippet from the <code>Sensors</code> module in the firmware:</p> <pre><code>class Sensors\n{\npublic:\nstruct Data\n{\nvector_t accel = {0, 0, 0};\nvector_t gyro = {0, 0, 0};\nfloat imu_temperature = 0;\nuint64_t imu_time = 0;\n\nfloat diff_pressure_velocity = 0;\nfloat diff_pressure = 0;\nfloat diff_pressure_temp = 0;\nbool diff_pressure_valid = false;\n\nfloat baro_altitude = 0;\nfloat baro_pressure = 0;\nfloat baro_temperature = 0;\nbool baro_valid = false;\n\nfloat sonar_range = 0;\nbool sonar_range_valid = false;\n\nvector_t mag = {0, 0, 0};\n\nbool baro_present = false;\nbool mag_present = false;\nbool sonar_present = false;\nbool diff_pressure_present = false;\n};\n\nSensors(ROSflight&amp; rosflight);\n\ninline const Data&amp; data() const { return data_; }\n\nprivate:\nData data_;\n}\n</code></pre> <p>Note that <code>data_</code> is a private member variable, but the <code>Data</code> struct is declared publicly and <code>data_</code> is accessed through an <code>inline const</code> accessor to prevent another module from changing <code>data_</code>.</p>"},{"location":"home/style-guide/#enums","title":"Enums","text":"<p>Enums should be declared using the following style: <pre><code>enum ArmedState\n{\nARMED_STATE_INIT,\nARMED_STATE_DISARMED,\nARMED_STATE_ARMED\n};\n</code></pre></p> <p>The name of the enum should be in CamelCase, and the names of its members should be ALL_CAPS. Where practical, have the members of the enum begin with the name of the enum.</p>"},{"location":"home/style-guide/#structs","title":"Structs","text":"<p>Structs should be declared using the following style: <pre><code>struct SomeValue\n{\nint v1;\nint v2;\n};\n</code></pre> Struct type names should be in CamelCase.</p>"},{"location":"home/style-guide/#globals","title":"Globals","text":"<p>The use of global variables should be limited to when absolutely necessary (such as linking to interrupt routines or hardware peripherals). This should only occur in board support layers and not in the core ROSflight libary code.</p>"},{"location":"home/style-guide/#include-order","title":"Include Order","text":"<p>Include files at the top of your file in the following order:</p> <ol> <li>Standard library (e.g. <code>&lt;cstdint&gt;</code>)</li> <li>Files from external libraries included in the project (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, <code>&lt;mavlink/v1.0/common/mavlink.h&gt;</code>)</li> <li>Other header files from this project (e.g. <code>\"rosflight.h\"</code>)</li> <li>The header file for this specific source file</li> </ol> <p>Group the includes according to the above list with an empty line between each group. (For external libraries, you may subdivide group 2 into a group for each library.) The first two groups should use angle brackets (<code>&lt;&gt;</code>), and the last two groups should use quotation marks (<code>\"\"</code>). Files from external libraries should be namespaced by the library name (e.g. <code>&lt;breezystm32/breezystm32.h&gt;</code>, not <code>&lt;breezystm32.h&gt;</code>).</p> <p>Alphabetize the files within each group. Do not change the include order to fix build errors; if you have to do that it means you are not including a file somewhere that you should. Please fix it by including all the right files.</p> <p>Include C standard library headers using the C++ style (<code>#include &lt;cmath&gt;</code>) instead of the C style (<code>#include &lt;math.h&gt;</code>).</p> <p>For example, in <code>sensors.c</code> I might have: <pre><code>#include &lt;cstdbool&gt;\n#include &lt;cstdint&gt;\n\n#include &lt;breezystm32/breezystm32.h&gt;\n#include &lt;breezystm32/drv_mpu6050.h&gt;\n\n#include \"param.h\"\n\n#include \"sensors.h\"\n</code></pre></p>"},{"location":"home/style-guide/#namespacing","title":"Namespacing","text":"<p>All modules in the firmware should be encapsulated in the <code>rosflight_firmware</code> namespace. This prevents name-clashing in SIL compilation.</p>"},{"location":"roscopter/overview/","title":"ROScopter Overview","text":""},{"location":"rosflight/overview/","title":"Overview","text":"<p>This page provides an overview of the basic operation of the ROSflight firmware and the concepts behind the behaviors.</p>"},{"location":"rosflight/overview/#companion-computer","title":"Companion Computer","text":"<p>ROSflight is primarily intended to be used with a companion computer running ROS. The ROS interface is provided by the rosflight_io node. All configuration of the flight controller is done through the ROS service API provided by <code>rosflight_io</code> (see the parameter configuration documentation page). Sensor data such as IMU measurements are streamed from the flight controller to the companion computer and published as ROS topics. Control setpoints can also be sent to the flight controller by publishing to the appropriate ROS topic (see the autonomous flight documentation page).</p> <p>Note</p> <p>To avoid confusion, we try to consistently use the following terminology:</p> <ul> <li>Flight controller: The embedded board (such as a Revo or Naze32) that runs the ROSflight firmware and performs I/O with sensors and ESCs</li> <li>Companion computer: A Linux computer, running ROS, that is mounted on the vehicle and has a physical, serial connection with the flight controller</li> <li>Offboard control (setpoints): The control setpoints passed from the companion computer to the flight controller. The control is \"offboard\" from the perspective of the flight controller, even though the computer providing those commands is mounted onboard the vehicle. Perhaps this is not the greatest terminology, but hopefully this helps clear up potential confusion.</li> </ul> <p>The following figure illustrates the interactions between the major components of the system:</p> <p></p>"},{"location":"rosflight/overview/#rc-safety-pilot","title":"RC Safety Pilot","text":"<p>ROSflight is designed for use with offboard control from experimental and research code. As such, it provides several mechanisms for an RC safety pilot to intervene if something goes wrong with the control setpoints coming from the companion computer:</p> <ul> <li>RC override switch: The safety pilot can flip a switch on the transmitter to take back RC control. Attitude and throttle override can be mapped independently, meaning you can choose one or the other, put them on separate switches, or put them both on the same switch. Details on these switches are provided on the RC configuration page.</li> <li>Stick deviations: If a stick is deviated from its center position, then that channel is overridden by RC control. This allows the safety pilot to take control without flipping a switch. This may be useful to provide a momentary correction on a single axis. The fraction of stick travel needed to activate the RC override is controlled by the <code>RC_OVRD_DEV</code> parameter. The <code>OVRD_LAG_TIME</code> parameter controls the amount of time that the override remains active after the sticks return to center.</li> <li>Minimum throttle: By default, the flight controller takes the minimum of the two throttle commands from RC and offboard control setpoints. This allows the safety pilot to drop the throttle quickly if needed. This behavior can be turned on or off with the <code>MIN_THROTTLE</code> parameter.</li> </ul>"},{"location":"rosflight/overview/#arming-errors-failsafe","title":"Arming, Errors &amp; Failsafe","text":"<p>The flight controller can only be armed and disarmed via RC control. Two mechanisms are provided: sticks (left stick down and right to arm, down and left to disarm) and switch. Only one of these options can be active at a time. Details on configuration are given on the RC configuration page.</p> <p>The firmware runs a number of error checks before allowing the flight controller to arm. Completing the configuration checklist on the Getting Started page should avoid these errors. In addition to a few internal health checks, the following conditions are checked:</p> <ul> <li>Mixer: Valid mixer must have been selected (see the Hardware Setup documentation page)</li> <li>IMU calibration: The IMU must have been calibrated since firmware was flashed (it is recommended that you recalibrate often)</li> <li>RC: There must be an active RC connection</li> </ul> <p>In addition to the error checking before arming, the flight controller enters a failsafe mode if the RC connection is lost during flight while armed. While in failsafe mode the flight controller commands level flight with the throttle value defined by the <code>FAILSAFE_THR</code> parameter.</p> <p>The following is a simplified version of the finite state machine that defines logic used for the arming, error checks, and failsafe operations:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults if one were to occur, although this is unlikely with unmodified firmware. If a hard fault occurs while the flight controller is armed, the firmware has the ability to immediately rearm after rebooting to enable continued RC control of the vehicle for recovery.</p>"},{"location":"rosflight/overview/#leds","title":"LEDs","text":"<p>The meaning of the various LEDs is summarized in the following table. The colors of the LEDs may change depending on your specific board:</p> LED On Off Slow Blink Fast Blink Power (Blue) Board powered - - - Info (Green) RC control Offboard control - - Warning (Red) Armed Disarmed Error (disarmed) Failsafe (armed)"},{"location":"rosflight/developer-guide/building-and-flashing/","title":"Building and Flashing the Firmware","text":"<p>Deprecation Notice</p> <p>As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them.</p> <p>This guide assumes you are running Ubuntu 18.04, which is the currently supported development environment.</p>"},{"location":"rosflight/developer-guide/building-and-flashing/#installing-the-arm-embedded-toolchain","title":"Installing the ARM Embedded Toolchain","text":"<p>Currently (as of March 2020) we are targeting version 7.3.1 of the ARM embedded toolchain. This toolchain can be installed from the GNU Arm Embedded Toolchain PPA:</p> <pre><code>sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa\nsudo apt install gcc-arm-embedded\n</code></pre> <p>You can test the installation and check which version is installed by running <code>arm-none-eabi-gcc --version</code>.</p>"},{"location":"rosflight/developer-guide/building-and-flashing/#building-the-firmware-from-source","title":"Building the Firmware from Source","text":"<p>Now that we have the compiler installed, simply clone the ROSflight firmware repository, pull down the submodules, and build:</p> <pre><code>git clone https://github.com/rosflight/firmware\ncd firmware\ngit submodule update --init --recursive\nmake\n</code></pre> <p>To build only the F4 firmware, use <code>make BOARD=REVO</code>. To build only the F1 firmware, use <code>make BOARD=NAZE</code>.</p>"},{"location":"rosflight/developer-guide/building-and-flashing/#flashing-newly-built-firmware","title":"Flashing Newly-Built Firmware","text":"<p>First, make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.</p>"},{"location":"rosflight/developer-guide/building-and-flashing/#f4","title":"F4","text":"<p>Flash the firmware to the board by running <code>make BOARD=REVO flash</code>. If necessary, specify the serial port with <code>make BOARD=REVO SERIAL_DEVICE=/dev/ttyACM0 flash</code>.</p>"},{"location":"rosflight/developer-guide/building-and-flashing/#f1","title":"F1","text":"<p>Flash the firmware to the board by running <code>make BOARD=NAZE flash</code> If necessary, specify the serial port with <code>make BOARD=REVO SERIAL_DEVICE=/dev/ttyUSB0 flash</code>.</p>"},{"location":"rosflight/developer-guide/code-architecture/","title":"Code Architecture","text":"<p>The firmware is divided into two main components: the ROSflight library, and a collection of board implementations. This division is intended to allow the same core flight code to run on any processor or platform, either an embedded flight controller (such as the Naze32 or Revo) or a desktop environment for a software-in-the-loop (SIL) simulation. The interface between these two components is called the hardware abstraction layer (HAL). This architecture is illustrated in the following diagram:</p> <p></p>"},{"location":"rosflight/developer-guide/code-architecture/#rosflight-core-library","title":"ROSflight Core Library","text":"<p>The ROSflight library consists of all the code in the <code>include</code> and <code>src</code> directories of the firmware repository. This includes the code for what is termed the \"flight stack,\" which consists of the core components (such as the estimator, controller, state manager, etc.) required for flight. It also includes the interface definition for the hardware abstraction layer, which is defined by the abstract <code>Board</code> class in <code>include/board.h</code>. The communications link (MAVLink) is also abstracted, with the interface defined by the <code>CommLink</code> class in <code>include/comm_link.h</code>. External libraries are contained in the <code>lib</code> folder.</p>"},{"location":"rosflight/developer-guide/code-architecture/#board-abstraction","title":"Board Abstraction","text":"<p>The hardware abstraction implementations are contained in the <code>board</code> directory, organized in subdirectories according to the hardware driver layer. The <code>boards/airbourne</code> directory uses drivers for boards using the STM32F4 processor, while the <code>boards/breezy</code> directory uses drivers for STM32F1 processors. Each board implementation is required to provide an implementation of the hardware abstraction layer interface, which is passed by reference to the flight stack. The Revo implementation in the <code>boards/airbourne</code> shows how this is done for an embedded flight controller. Examples of board implementations for SIL simulation are found in the <code>rosflight_firmware</code> and <code>rosflight_sim</code> ROS packages available here.</p> <p>The flight stack is encapsulated in the <code>ROSflight</code> class defined at <code>include/rosflight.h</code>. This class contains two public functions: <code>init()</code> and <code>run()</code>. Its constructor requires two arguments: an implementation of the <code>Board</code> interface, and an implementation of the <code>CommLink</code> interface.</p> <p>Each board implementation is required to:</p> <ul> <li>Provide its own <code>main()</code> function that instantiates an implementation of the <code>Board</code> interface,</li> <li>Instantiate a <code>ROSflight</code> object with that board interface as an argument,</li> <li>Call the <code>init()</code> method of that <code>ROSflight</code> object once,</li> <li>Then call the <code>run()</code> method in a loop.</li> </ul> <p>For example, here is the main function for the Naze32 board implementation (<code>boards/breezy/main.cpp</code>):</p> <pre><code>#include \"breezy_board.h\"\n#include \"rosflight.h\"\n#include \"mavlink.h\"\n\nint main()\n{\nrosflight_firmware::BreezyBoard board;\nboard.init_board();\nrosflight_firmware::Mavlink mavlink(board);\nrosflight_firmware::ROSflight firmware(board, mavlink);\n\nfirmware.init();\n\nwhile (true)\n{\nfirmware.run();\n}\nreturn 0;\n}\n</code></pre>"},{"location":"rosflight/developer-guide/code-architecture/#comm-link-abstraction","title":"Comm Link Abstraction","text":"<p>The purpose of the comm link abstraction layer is to allow communication protocols other than MAVLink to be used if desired. The comm link abstraction implementations are contained in the <code>comms</code> directory, organized in subdirectories by protocol. The implementations translate between the messages that the firmware expects to send and receive, and the messages defined by the communication protocol. Currently, only MAVLink is implemented.</p>"},{"location":"rosflight/developer-guide/code-architecture/#flight-stack","title":"Flight Stack","text":"<p>The flight stack is encapsulated by the <code>ROSflight</code> class defined in <code>include/rosflight.h</code>. It consists of a collection of modules. Each of these modules is implemented as a C++ class, and encapsulates a cohesive piece of the autopilot functionality. The following diagram illustrates these modules and the data flow between them. Rectangular blocks represent modules in the flight stack, and ellipses represent hardware functionality implemented in the board support layer:</p> <p></p> <p>We'll describe each of these modules in the following sections:</p>"},{"location":"rosflight/developer-guide/code-architecture/#state-manager","title":"State Manager","text":"<p>This module is in charge of keeping track of the internal state (armed status, error codes, failsafe, etc.) of the vehicle. While only the comm manager data flow is illustrated on the diagram, all other modules query the state manager to determine the status and act appropriately based on that status.</p> <p>The operation of the state manager is defined by the following finite state machine:</p> <p></p> <p>The state manager also includes functionality for recovering from hard faults. In the case of a hard fault, the firmware writes a small amount of data to backup memory then reboots. This backup memory location is checked and then cleared after every reboot. The backup memory includes the armed state of the flight controller. On reboot, the firmware will initialize then, if this armed-state flag is set, immediately transition back into the armed state. This functionality allows for continued RC control in the case of a hard fault. Hard faults are not expected with the stable firmware code base, but this feature adds an additional layer of safety if experimental changes are being made to the firmware itself.</p>"},{"location":"rosflight/developer-guide/code-architecture/#parameter-server","title":"Parameter Server","text":"<p>This module handles all parameters for the flight stack. It supports the getting and setting of integer and floating-point parameters, and the saving of these parameters to non-volatile memory. Setting and getting of parameters from the companion computer is done through the serial communication interface. While no other data flow lines are shown on the diagram, all of the other modules interact with the parameter server.</p>"},{"location":"rosflight/developer-guide/code-architecture/#comm-manager","title":"Comm Manager","text":"<p>This module handles all serial communication between the flight controller and companion computer. This includes streaming data and receiving offboard control setpoints and other commands from the computer. This module primarily collects data from the sensors, estimator, state manager, and parameters modules, and sends offboard control setpoints to the command manager and parameter requests to the parameter server.</p> <p>The actual communication protocol used is abstracted by the interface in include/comm_link.h. A new protocol can be used by implementing a wrapper around the protocol that inherits from this interface. Currently, only MAVLink has been implmented. The implementation is found in comms/mavlink/mavlink.h and comms/mavlink/mavlink.cpp.</p>"},{"location":"rosflight/developer-guide/code-architecture/#sensors","title":"Sensors","text":"<p>This module is in charge of managing the various sensors (IMU, magnetometer, barometer, differential pressure sensor, sonar altimeter, etc.). Its responsibilities include updating sensor data at appropriate rates, and computing and applying calibration parameters.</p>"},{"location":"rosflight/developer-guide/code-architecture/#estimator","title":"Estimator","text":"<p>This module is responsible for estimating the attitude and attitude rates of the vehicle from the sensor data.</p>"},{"location":"rosflight/developer-guide/code-architecture/#rc","title":"RC","text":"<p>The RC module is responsible for interpreting the RC signals coming from the transmitter via the receiver. This includes mapping channels to their appropriate functions and reversing directions if necessary.</p>"},{"location":"rosflight/developer-guide/code-architecture/#command-manager","title":"Command Manager","text":"<p>The command manager combines inputs from the RC and comm manager modules to produce a control setpoint. Its main purpose is to handle the interaction between offboard commands and the RC safety pilot, as well as to enforce the failsafe command if the state manager reports failsafe mode.</p>"},{"location":"rosflight/developer-guide/code-architecture/#controller","title":"Controller","text":"<p>The controller uses the inputs from the command manager and estimator to compute a control output. This control output is computed in a generic form (x, y, and z torques, and force F), and is later converted into actual motor commands by the mixer.</p>"},{"location":"rosflight/developer-guide/code-architecture/#mixer","title":"Mixer","text":"<p>The mixer takes the generic outputs computed by the controller and maps them to actual motor commands depending on the configuration of the vehicle.</p>"},{"location":"rosflight/developer-guide/debugging/","title":"Using an In-Circuit Debugger","text":"<p>Debugging an STM32-based board is accomplished with an ST-LINK/V2 in-circuit debugger and programmer. We have had the best luck with the official version from STMicroelectronics. These devices are reasonably priced, and are available directly from STMicroelectronics or from vendors such as Digi-Key, Mouser, and Newark.</p> <p>Note</p> <p>There are also cheaper clones of the ST-LINK/V2 available. We have had fairly good luck with these, but have also run into some issues. These are a decent alternative, but we recommend the official version if you can afford it.</p> <p>The following guide will show you how to get the in-circuit debugger running with either the Visual Studio Code or QtCreator IDE. Start with the steps in the General Setup section, then move on to either the VS Code or QtCreator sections depending on your choice of IDE.</p> <p>This guide assumes you are running Ubuntu 18.04, which is the currently supported development environment.</p>"},{"location":"rosflight/developer-guide/debugging/#general-setup","title":"General Setup","text":"<p>Follow the guide in Building and Flashing to install the compiler toolchain.</p> <p>Also make sure you have configured your computer as described in the Serial Port Configuration section of the user guide.</p>"},{"location":"rosflight/developer-guide/debugging/#connect-debugger-to-flight-controller","title":"Connect debugger to flight controller","text":"<p>The ST-LINK/V2 connects to the microcontroller using the Serial Wire Debug (SWD) interface. You will need to connect the <code>GND</code>, <code>NRST</code>, <code>SWDIO</code>, and <code>SWCLK</code> lines of the ST-LINK/V2 to your flight controller. On many F4 boards, these lines are pinned out through a 4-position JST SH connector, although that connector is not always populated. Refer to the documentation for your specific board for details.</p> <p>The official ST-LINK/V2 also needs a target voltage reference on pin 1 or 2, which for the F4 boards is 3.3V. However, there is no externally accessible 3.3V pinout on the F4 boards. An easy solution to this is to connect pin 19 (VDD 3.3V) of the ST-LINK/V2 to pin 1 or 2 of the ST-LINK/V2 (Target VCC) to provide the voltage reference. You will also need to power the board from another source, either through the USB port or over the servo rail. Note that this connection is not required for the cheap clone versions of the ST-LINK/V2.</p>"},{"location":"rosflight/developer-guide/debugging/#vs-code","title":"VS Code","text":"<p>You can install Visual Studio Code by downloading the latest version from their website. Follow the steps below to configure debugging with the in-circuit debugger.</p> <p>You should open the root firmware directory for editing and debugging, e.g. <code>code /path/to/firmware</code>.</p>"},{"location":"rosflight/developer-guide/debugging/#install-openocd","title":"Install OpenOCD","text":"<p>OpenOCD (On-Chip Debugger) is the software that will control the debugger. Install from the <code>apt</code> repositories:</p> <pre><code>sudo apt install openocd\n</code></pre>"},{"location":"rosflight/developer-guide/debugging/#install-cortex-debug-extension","title":"Install Cortex-Debug extension","text":"<p>The embedded debugging functionality is provided by the <code>Cortex-Debug</code> extension. Install using the VS Code GUI, or from VS Code press <code>Ctrl+P</code> then type <code>ext install marus25.cortex-debug</code>.</p> <p>Steps for configuring this extension are described next.</p>"},{"location":"rosflight/developer-guide/debugging/#download-svd-file","title":"Download SVD file","text":"<p>A System View Description (SVD) file describes the configuration (CPU, peripherals, registers, etc.) of the microcontroller. The Cortex-Debug extension can make use of an SVD file to provide more detailed debugging information, such as the ability to inspect register values.</p> <p>SVD files can be downloaded from STMicroelectronics. The files for the F4 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F405.svd</code>. The files for the F1 are contained in the ZIP file that can be downloaded here, and the relevant file is <code>STM32F103.svd</code>. Put those files in a convenient location.</p>"},{"location":"rosflight/developer-guide/debugging/#configure-build-step","title":"Configure build step","text":"<p>You can configure VS Code to run <code>make</code> for you when you press <code>Ctrl+Shift+B</code>. To do this, put the following in <code>.vscode/tasks.json</code> inside your firmware working directory:</p> <pre><code>{\n// See https://go.microsoft.com/fwlink/?LinkId=733558\n// for the documentation about the tasks.json format\n\"version\": \"2.0.0\",\n\"tasks\": [\n{\n\"type\": \"shell\",\n\"label\": \"make\",\n\"command\": \"make\",\n\"args\": [\"DEBUG=GDB\"],\n\"group\": {\n\"kind\": \"build\",\n\"isDefault\": true\n}\n}\n]\n}\n</code></pre> <p>Note that by default, this will only build the F4 (Revo) firmware. To build the F1 firmware, you will need to edit this to add the argument <code>BOARD=NAZE</code>.</p>"},{"location":"rosflight/developer-guide/debugging/#configure-debugging","title":"Configure debugging","text":"<p>To configure in-circuit debugging of F4 and F1 targets, put something like the following in <code>.vscode/launch.json</code> inside your firmware working repository:</p> <pre><code>{\n// Use IntelliSense to learn about possible attributes.\n// Hover to view descriptions of existing attributes.\n// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n\"version\": \"0.2.0\",\n\"configurations\": [\n{\n\"name\": \"STM32F405\",\n\"type\": \"cortex-debug\",\n\"request\": \"launch\",\n\"servertype\": \"openocd\",\n\"cwd\": \"${workspaceRoot}\",\n\"executable\": \"${workspaceRoot}/boards/airbourne/build/rosflight_REVO_Debug.elf\",\n\"device\": \"STM32F405\",\n\"svdFile\": \"/path/to/STM32F405.svd\",\n\"configFiles\": [\n\"interface/stlink-v2.cfg\",\n\"target/stm32f4x.cfg\"\n],\n\"runToMain\": true\n},\n{\n\"name\": \"STM32F103\",\n\"type\": \"cortex-debug\",\n\"request\": \"launch\",\n\"servertype\": \"openocd\",\n\"cwd\": \"${workspaceRoot}\",\n\"executable\": \"${workspaceRoot}/boards/breezy/build/rosflight_NAZE_Debug.elf\",\n\"device\": \"STM32F103\",\n\"svdFile\": \"/path/to/STM32F103.svd\",\n\"configFiles\": [\n\"interface/stlink-v2.cfg\",\n\"target/stm32f1x.cfg\"\n],\n\"runToMain\": true\n}\n]\n}\n</code></pre> <p>Be sure to edit the values of <code>\"svdFile\"</code> to point to the respective SVD files you downloaded earlier.</p> <p>To start debugging, enter the debug pane in VS Code, select the desired configuration, then click the green arrow to start debugging. The shortcut key <code>F5</code> will also launch the last-selected debug configuration.</p> <p>More details on the configuration and use of the <code>Cortex-Debug</code> extension can be found here and here.</p>"},{"location":"rosflight/developer-guide/debugging/#qtcreator","title":"QtCreator","text":"<p>Install QtCreator with apt:</p> <pre><code>sudo apt install qtcreator\n</code></pre> <p>then follow the steps below to set up ARM debugging.</p>"},{"location":"rosflight/developer-guide/debugging/#install-openocd_1","title":"Install OpenOCD","text":"<p>OpenOCD (On-Chip Debugger) is the software that will control the debugger. We are going to install the version that is configured to work as a plugin for the Eclipse IDE. To get this version, go to the releases page of the OpenOCD github page and download the latest <code>.tgz</code> file. You can use the following commands, substituting the version you downloaded for <code>&lt;version&gt;</code>:</p> <pre><code>cd ~/Downloads\ntar -xvf gnuarmeclipse-openocd-&lt;version&gt;-dev.tgz\nsudo mv openocd /opt/\n</code></pre> <p>Then, for convenience, I normally create a script to run openocd for me. Here is my <code>start_openocd_f1</code> script:</p> <pre><code>#!/bin/bash\ncd /opt/openocd/0.10.0-201701241841/bin # Use the correct version\n./openocd -f interface/stlink-v2.cfg -f target/stm32f1x.cfg\n</code></pre> <p>Here is my <code>start_openocd_f4</code> script:</p> <pre><code>#!/bin/bash\ncd /opt/openocd/0.10.0-5-20171110-1117/bin\n./openocd -f interface/stlink-v2.cfg -f target/stm32f4x.cfg\n</code></pre> <p>Note</p> <p>On more recent versions of openocd, <code>interface/stlink-v2.cfg</code> is deprecated. Use <code>interface/stlink.cfg</code> instead.</p> <p>I move these to the <code>/usr/local/bin</code> directory so I can call it from anywhere:</p> <pre><code>chmod +x start_openocd_f1\nchmod +x start_openocd_f4\nmv start_openocd_f1 /usr/local/bin\nmv start_openocd_f4 /usr/local/bin\n</code></pre>"},{"location":"rosflight/developer-guide/debugging/#install-32-bit-dependencies","title":"Install 32-bit Dependencies","text":"<p>QtCreator needs 32-bit python bindings to run GDB. Install these with</p> <pre><code>sudo dpkg --add-architecture i386\nsudo apt update\nsudo apt install libpython2.7:i386\n</code></pre>"},{"location":"rosflight/developer-guide/debugging/#configure-qtcreator-for-arm-development","title":"Configure QtCreator for ARM Development","text":"<p>Open QtCreator and perform the following steps:</p>"},{"location":"rosflight/developer-guide/debugging/#turn-on-the-bare-metal-plugin","title":"Turn on the \"Bare Metal Plugin\"","text":"<p>Help -&gt; About Plugins -&gt; Enable \"Bare Metal\"</p> <p>Restart QtCreator</p> <p>Now, we are going to configure a new \"Kit\" for ARM development. (This allows you to quickly switch back and forth between ARM and normal development.)</p>"},{"location":"rosflight/developer-guide/debugging/#tell-qtcreator-where-to-find-the-compiler-gcc","title":"Tell QtCreator where to find the compiler (GCC)","text":"<ul> <li>Tools -&gt; Options -&gt; Build &amp; Run -&gt; Compilers -&gt; Add -&gt; GCC -&gt; C++.</li> <li>Name the new compiler, e.g. \"G++ ARM\"</li> <li>Point the compiler path to where you just installed your fresh GCC</li> <li>The path for G++ <code>/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-g++</code></li> </ul> <p>Do the same for GCC (if you are going to be doing any C-only code)</p> <ul> <li>Tools -&gt; Options -&gt; Build &amp; Run -&gt; Compilers -&gt; Add -&gt; GCC -&gt; C.</li> <li>Name the compiler, e.g. \"GCC ARM\"</li> <li>Point the compiler path to where you just installed your fresh GCC</li> <li>The path for GCC is <code>/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gcc</code></li> </ul> <p></p>"},{"location":"rosflight/developer-guide/debugging/#add-the-debugger-gdb","title":"Add the Debugger (GDB)","text":"<ul> <li>Tools -&gt; Options -&gt; Build &amp; Run -&gt; Debuggers -&gt; Add -&gt; GDB.</li> <li>Name it something</li> <li>Point it to the new debugger you just installed</li> <li>The Path for <code>/opt/gcc-arm-none-eabi-5_4-2016q3/bin/arm-none-eabi-gdb-py</code></li> </ul>"},{"location":"rosflight/developer-guide/debugging/#configure-the-stlink-v2-with-openocd","title":"Configure the STLink-V2 with OpenOCD","text":"<p>Go to the Bare Metal Plugin</p> <ul> <li>Tools -&gt; Options -&gt; Devices -&gt; Bare Metal -&gt; Add -&gt; OpenOCD</li> <li>Leave all options at default values and click Apply </li> <li>Tools -&gt; Options -&gt; Devices -&gt; Devices -&gt; Add -&gt; Bare Metal Device -&gt; Start Wizard</li> <li>Name: ST-Link V2</li> <li>GDB Server Provider: OpenOCD</li> </ul> <p></p>"},{"location":"rosflight/developer-guide/debugging/#build-the-new-development-kit","title":"Build the new Development Kit","text":"<ul> <li>Tools -&gt; Options -&gt; Build &amp; Run -&gt; Kits -&gt; Add</li> <li>Name: ARM</li> <li>Device Type: Bare Metal Device</li> <li>Device: ST-Link V2</li> <li>Compiler: GCC ARM/G++ ARM</li> <li>Debugger: ARM GDB</li> <li>Qt Version: None</li> </ul>"},{"location":"rosflight/developer-guide/debugging/#test-the-debugger","title":"Test the Debugger","text":"<p>Here are the instructions for an F1 target. The instructions are very similar for an F4, just choose the correct <code>.elf</code> file.</p>"},{"location":"rosflight/developer-guide/debugging/#turn-on-the-debugger","title":"Turn on the Debugger","text":"<p>Connect the debugger to your flight controller. Here is the pinout for the Flip32 and Flip32+: </p> <p>Plug in the debugger and start openocd (you will need sudo privileges):</p> <p><code>sudo start_openocd_f1</code></p>"},{"location":"rosflight/developer-guide/debugging/#build-the-correct-example-code","title":"Build the Correct Example Code","text":"<ul> <li>Import Existing Project</li> <li>Open the root of the firmware</li> <li>Do not add .creator files to the Git repository</li> </ul>"},{"location":"rosflight/developer-guide/debugging/#configure-the-build-environment","title":"Configure the Build Environment","text":"<ul> <li>Go to the \"Projects\" tab on the left hand side</li> <li>Switch to the ARM Kit we just created</li> <li>Build Settings:<ul> <li>Change \"Build Directory\" to the firmware root</li> <li>Build Steps: <code>make BOARD=NAZE DEBUG=GDB</code> </li> </ul> </li> <li>Run Settings:<ul> <li>Change \"Run Configuration\" to hardware debugger</li> <li>Choose the <code>.elf</code> file in the <code>boards/breezy/build</code> directory (you'll need to build first) <code>firmware/boards/breezy/build/rosflight.elf</code> </li> </ul> </li> </ul> <p>You're done!  Just select the \"Debug\" tab and debug your project!</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/","title":"Estimator Algorithm","text":""},{"location":"rosflight/developer-guide/estimator-algorithm/#introduction","title":"Introduction","text":"<p>The estimator is used to calculate an estimate of the attitude and angular velocity of the multirotor.  It is assumed that the flight controller is mounted rigidly to the body of the aircraft (perhaps with dampening material to remove vibrations from the motors), such that measurements of the on-board IMU are consistent with the motion of the aircraft.</p> <p>Due to the limited computational power on the embedded processor, and to calculate attitude estimates at speeds up to 8000Hz, a simple complementary filter is used, rather than an extended Kalman filter.  In practice, this method works extremely well, and it used widely throughout commercially available autopilots.  There are a variety of complementary filters, but the general theory is the same.  A complementary filter is a method that combines low and high frequency data (complementary in frequency bandwidth).  It can be used to fuse the measurements from a gyroscope, accelerometer and sometimes magnetometer to produce an estimate of the attitude of the MAV.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#complementary-filtering","title":"Complementary Filtering","text":"<p>The idea behind complementary filtering is to try to get the \"best of both worlds\" of gyros and accelerometers.  Gyros are very accurate in short spaces of time, but they are subject to low-frequency drift.  Accelerometers don't drift in the long scheme of things, but they experience high-frequency noise as the MAV moves about.  So, to solve these problems, the complementary filter primarily propagates states using gyroscope measurements, but then corrects drift with the accelerometer, which is a partial source of attitude measurements.  In a general sense, it is like taking a high-pass filtered version of gyroscope measurements, and a low-pass filtered version of accelerometers, and fusing the two together in a manner that results in an estimate that is stable over time, but also able to handle quick transient motions.</p> <p>For an excellent review of the theory of complementary filtering, consult Mahony's Nonlinear Complementary Filtering on SO(3) paper1.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#attitude-representation","title":"Attitude Representation","text":"<p>There are a number of ways to represent the attitude of a MAV.  Often, attitude is represented in terms of the Euler angles yaw, pitch and roll, but it can also be represented in other ways, such as rotation matrices, and quaternions.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#euler-angles","title":"Euler Angles","text":"<p>Euler angles represent rotations about three different axes, usually, the z, y, and x axes in that order.  This method is often the most easy for users to understand and interpret, but it is by far the least computationally efficient.  To propagate euler angles, the following kinematics are employed:</p>  \\begin{equation}     \\begin{bmatrix}         \\dot{\\phi} \\\\         \\dot{\\theta} \\\\         \\dot{\\psi} \\\\     \\end{bmatrix}     =     \\begin{bmatrix}         1 &amp; \\sin(\\phi) \\tan(\\theta) &amp; \\cos(\\phi)\\tan(\\theta) \\\\         0 &amp; \\cos(\\phi)              &amp; -\\sin(\\phi) \\\\         0 &amp; \\frac{\\sin(\\phi)}{\\cos(\\theta)} &amp; \\frac{\\cos(\\phi)}{\\cos(\\theta)}  \\\\     \\end{bmatrix}     \\begin{bmatrix}         p \\\\         q \\\\         r \\\\     \\end{bmatrix} \\end{equation}  <p>Note the large number of trigonometric functions associated with this propagation.  In a complementary filter, this will be evaluated at every measurement, and the non-linear coupling between \\omega  and the attitude becomes very expensive, particularly on embedded processors.</p> <p>Another shortcoming of euler angles is known as \"gimbal lock\".  Gimbal lock occurs at the \"singularity\" of the euler angle representation, or pitched directly up or down.  The problem occurs because there is more than one way to represent this particular rotation.  There are some steps one can take to handle these issues, but it is a fundamental problem associated with using euler angles, and motivates the other attitude representations.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#rotation-matrix","title":"Rotation Matrix","text":"<p>Rotation matrices, are often used in attitude estimation, because they do not suffer from gimbal lock, are quickly converted to and from euler angles, and because of their simple kinematics.</p>  \\begin{equation}     \\dot{R} = \\lfloor\\omega\\rfloor R \\end{equation}  <p>where \\lfloor\\omega\\rfloor is the skew-symmetric matrix of \\omega, and is related to calculating the cross product.</p>  \\begin{equation}     \\lfloor\\omega\\rfloor =     \\begin{bmatrix}         0 &amp; -r &amp; q \\\\         r &amp; 0 &amp; -p \\\\         -q &amp; p &amp; 0     \\end{bmatrix} \\end{equation}  <p>This propagation step is linear with respect to the angular rates, which simplifies calculation significantly.</p> <p>A rotation matrix from the inertial frame to body frame can be constructed from euler angles via the following formula:</p>  \\newcommand{\\ct}{c\\theta} \\newcommand{\\cp}{c\\phi} \\newcommand{\\cs}{c\\psi} \\newcommand{\\st}{s\\theta} \\newcommand{\\sphi}{s\\phi} \\newcommand{\\spsi}{s\\psi} \\begin{equation}         R = \\begin{bmatrix}             \\ct\\cs &amp; \\ct\\spsi &amp; -\\st \\\\         \\sphi\\st\\cs-\\cp\\spsi &amp; \\sphi\\st\\spsi+\\cp\\cs &amp; \\sphi\\ct \\\\         \\cp\\st\\cs+\\sphi\\spsi &amp; \\cp\\st\\spsi-\\sphi\\cs &amp; \\sphi\\st \\\\         \\end{bmatrix} \\end{equation}  <p>and converting back to euler angles is done via the following;</p>  \\begin{equation}   \\begin{bmatrix}     \\phi \\\\     \\theta \\\\     \\psi \\\\   \\end{bmatrix} =     \\begin{bmatrix}      \\textrm{atan2}\\left(R_{32}, R_{33}\\right) \\\\    \\textrm{atan2}\\left(-R_{31}, \\sqrt{R_{21}^2 + R_{33}^2}\\right) \\\\    \\textrm{atan2}\\left(R_{21}, R_{11}\\right) \\\\   \\end{bmatrix} \\end{equation}"},{"location":"rosflight/developer-guide/estimator-algorithm/#quaternions","title":"Quaternions","text":"<p>Quaternions are a number system which extends complex numbers.  They have four elements, commonly known as w, x, y, and z.  The last three elements can be though of as describing an axis, \\beta about which a rotation occurred, while the first element, w can be though of as describing the amount of rotation \\alpha about that axis. (see eq~\\ref{eq:euler_to_axis_angle}). While this may seem straight-forward, quaternions are normalized so that they can form a group.  (That is, a quaternion multiplied by a quaternion is a quaternion), so they end up being really difficult for a human being to interpret just by looking at the values.  However, they provide some amazing computational efficiencies, most of which comes from the following special mathematics associated with quaternions.</p> <p>First, just the definition of a quaternion:</p>  \\begin{equation}     q = \\begin{bmatrix}                 q_w \\\\                 q_x \\\\                 q_y \\\\                 q_z              \\end{bmatrix}            = \\begin{bmatrix}                 \\cos(\\alpha/2) \\\\                 \\sin(\\alpha/2)\\cos(\\beta_x) \\\\                 \\sin(\\alpha/2)\\cos(\\beta_y) \\\\                 \\sin(\\alpha/2)\\cos(\\beta_y)              \\end{bmatrix}              = \\begin{bmatrix}                s \\\\                v_x \\\\                v_y \\\\                v_z              \\end{bmatrix}     \\label{eq:euler_to_axis_angle} \\end{equation}  <p>and second, some formulas to convert to and from euler angles.</p>  \\begin{equation}     q =       \\begin{bmatrix}         \\cos(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\         \\sin(\\theta/2)\\cos(\\theta/2)\\cos(\\psi/2) - \\cos(\\phi/2)\\sin(\\theta/2)\\sin(\\psi/2) \\\\         \\cos(\\theta/2)\\sin(\\theta/2)\\cos(\\psi/2) + \\sin(\\phi/2)\\cos(\\theta/2)\\sin(\\psi/2) \\\\         \\cos(\\theta/2)\\cos(\\theta/2)\\sin(\\psi/2) - \\sin(\\phi/2)\\sin(\\theta/2)\\cos(\\psi/2) \\\\       \\end{bmatrix} \\end{equation}   \\begin{equation}     \\begin{bmatrix}         \\phi \\\\         \\theta \\\\         \\psi \\\\     \\end{bmatrix}     =     \\begin{bmatrix}         \\textrm{atan2}\\left( 2\\left(q_wq_x + q_yq_z\\right),1-2\\left(q_x^2+q_y^2\\right) \\right) \\\\         \\textrm{sin}^{-1}\\left( 2 \\left( q_wq_y - q_zq_x \\right)  \\right) \\\\         \\textrm{atan2}\\left( 2 \\left( q_wq_z + q_xq_y \\right), 1 - 2 \\left( q_y^2 q_z^2 \\right)  \\right)     \\end{bmatrix}     \\label{eq:euler_from_quat}     \\tag{5} \\end{equation}  <p>The quaternion group is \"closed\" under the following operation, termed quaternion multiplication.</p>  q_1 \\otimes q_2 = \\begin{bmatrix} s_1s_2 - v_1^\\top v_2 \\\\ s_1v_2 + s_2v_1 + v_1 \\times v_2 \\end{bmatrix}  <p>To take the \"inverse\" of a quaternion is simply to multiply s or v by -1</p> \\begin{equation}     q^{-1} = \\begin{bmatrix}                 -q_w \\\\                 q_x \\\\                 q_y \\\\                 q_z              \\end{bmatrix}                 = \\begin{bmatrix}                 q_w \\\\                 -q_x \\\\                 -q_y \\\\                 -q_z              \\end{bmatrix} \\end{equation} <p>and to find the difference between two quaternions, just quaternion multiply the inverse of one quaternion with the other.</p> \\begin{equation}     \\tilde{q} = \\hat{q}^{-1} \\otimes q \\end{equation} <p>However, the most important aspect of quaternions is the way we propagate dynamics.</p> \\begin{equation}     \\dot{q} = \\frac{1}{2} q \\otimes q_\\omega \\end{equation} <p>where q_\\omega is the pure quaternion created from angular rates.</p> \\begin{equation}     q_\\omega = \\textrm{p}(\\omega) =               \\begin{bmatrix}                 0 \\\\                 p \\\\                 q \\\\                 r              \\end{bmatrix} \\end{equation} <p>What this means is that, like rotation matrices, quaternion dynamics are linear with respect to angular rates, as opposed to euler angles, which are non-linear, and they take less computation than rotation matrices because they have fewer terms.  Casey et al. [Casey2013] performed a study comparing all three of the above representations, and found that complementary filters using an euler angle representation took 12 times longer to compute on average than a quaternion-based filter.  Quaternions were also about 20% more efficient when compared with rotation matrices.  For these reasons, ROSflight uses quaternions in its filter.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#derivation","title":"Derivation","text":"<p>ROSflight implements the quaternion-based passive \"Mahony\" filter as described in this paper 1.  In particular, we implement equation 47 from that paper, which also estimates gyroscope biases.  A Lyuapanov stability analysis is performed in that paper, in which it is shown that all states and biases, except heading, are globally asymptotically stable given an accelerometer measurement and gyroscope.  The above reference also describes how a magnetometer can be integrated in a similar method to the accelerometer.  That portion of the filter is omitted here due to the unreliable nature of magnetometers on-board modern small UAS.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#passive-complementary-filter","title":"Passive Complementary Filter","text":"<p>The original filter propagates per the following dynamics:</p>  \\newcommand{\\werr}{\\omega_\\text{err}} \\newcommand{\\wfinal}{\\omega_\\text{final}} \\begin{equation}     \\begin{aligned}     \\dot{\\hat{q}} &amp;= \\frac{1}{2} \\hat{q} \\otimes \\textrm{p}\\left(\\wfinal\\right) \\\\     \\dot{\\hat{b}} &amp;= -2k_I\\werr     \\end{aligned}     \\label{eq:traditional_prop}     \\tag{1} \\end{equation}  <p>where \\textrm{p}\\left(\\cdot\\right) creates a pure quaternion from a 3-vector. The term \\wfinal is a composite angular rate which consists of the measured angular rates, \\bar{\\omega}, the estimated gyroscope biases, \\hat{b}, and a correction term calculated from another measurement of attitude (usually the accelerometer), \\werr. The constant gains k_p and k_Is are used in determining the dynamics of the filter. $$ \\begin{equation}\\label{eq:q_omega}\\tag{2}     \\wfinal = \\bar{\\omega} - \\hat{b} + k_P\\werr \\end{equation} $$</p>  \\newcommand{\\avec}{a} \\newcommand{\\gvec}{g} \\newcommand{\\qmeas}{q_{acc}} \\newcommand{\\gamvec}{\\gamma} \\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert} \\newcommand{\\wbar}{\\bar\\omega} \\newcommand{\\w}{\\omega} \\newcommand{\\qhat}{\\hat{q}}  <p>The correction term \\werr can be understood as the error in the attitude as predicted by another source (e.g., the accelerometer).  To calculate \\werr the quaternion describing the rotation between the accelerometer estimate and the z-axis of the inertial frame (i.e., where gravity should be), \\qmeas, is first calculated</p>  \\begin{equation}     \\avec =         \\begin{bmatrix}             a_x \\\\             a_y \\\\             a_z \\\\             \\end{bmatrix},     \\qquad     \\gvec =       \\begin{bmatrix}             0 \\\\             0 \\\\             1 \\\\         \\end{bmatrix},     \\qquad     \\gamvec = \\frac{\\avec+\\gvec}{\\norm{\\avec+\\gvec}},     \\qquad     \\qmeas =       \\begin{bmatrix}         \\avec^\\top \\gamvec \\\\         \\avec \\times \\gamvec       \\end{bmatrix} \\end{equation}   \\newcommand{\\qtilde}{\\tilde{q}} \\newcommand{\\vtilde}{\\tilde{v}}  <p>Next, the quaternion error between the estimate \\qhat and the accelerometer measure \\qmeas is calculated. \\begin{equation}     \\qtilde = \\qmeas^{-1} \\otimes \\qhat =         \\begin{bmatrix}             \\tilde{s}\\             \\vtilde         \\end{bmatrix} \\end{equation}</p> <p>Finally, \\qmeas is converted back into a 3-vector per the method described in eq. 47a of Mahony2007 1. \\begin{equation}     \\werr = 2\\tilde{s}\\vtilde \\end{equation}</p> <p>Both the attitude quaternion and bias dynamics can be integrated using standard Euler integration, requiring that the resulting quaternion is re-normalized.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#modifications-to-original-passive-filter","title":"Modifications to Original Passive Filter","text":"<p>There have been a few modifications to the passive filter described in Mahony2007 1, consisting primarily of contributions from Casey2013.  Firstly, rather than simply taking gyroscope measurements directly as an estimate of \\omega, a quadratic polynomial is used to approximate the true angular rate from gyroscope measurements to reduce error.  In Casey2013, this process was shown to reduce RMS error by more than 1,000 times.  There are additional steps associated with performing this calculation, but the benefit in accuracy more than compensates for the extra calculation time.  The equation to perform this calculation is shown in Eq.\\eqref{eq:quad_approx}.</p> \\begin{equation}     \\bar{\\omega} = \\frac{1}{12}\\left(-\\omega\\left(t_{n-2}\\right) + 8\\omega\\left(t_{n-1}\\right) + 5\\omega\\left(t_n\\right) \\right)     \\label{eq:quad_approx}     \\tag{4} \\end{equation} <p>where \\omega(t_{n-x}) is the gyroscope measurement of the angular rate x measurements previous.</p> <p>The second modification is in the way that the attitude is propagated after finding \\dot{\\hat{q}}.  Instead of performing the standard euler integration</p>  \\begin{equation}     \\hat{q}_n = \\hat{q}_{n-1}+\\dot{\\hat{q}}_n dt \\end{equation}  <p>we use an approximation of the matrix exponential.  The matrix exponential arises out of the solution to the differential equation \\dot{x} = Ax, namely $$ \\begin{equation}     x(t) = e^{At} x(0) \\end{equation} $$</p> <p>and the discrete-time equivalent $$ \\begin{equation}     x(t_{n+1}) = e^{hA}(t_n) \\end{equation} $$</p> <p>This discrete-time matrix exponential can be approximated by first expanding the matrix exponential into the infinite series</p> \\begin{equation}     e^{A} = \\sum_{k=0}^\\infty \\dfrac{1}{k!}A^k \\end{equation} <p>and then grouping odd and even terms from the infinite series into two sinusoids, and results in the following equation for the propagation of the quaternion dynamics</p>  \\begin{equation}     \\qhat(t_n) = \\left[ \\cos \\left( \\frac{\\norm{\\w}h}{2}\\right)I_4  + \\frac{1}{\\norm{\\w}} \\sin \\left( \\frac{\\norm{\\w}h}{2} \\right) \\lfloor\\w\\rfloor_4   \\right] \\qhat(t_{n-1})     \\label{eq:mat_exponential}     \\tag{3} \\end{equation}  <p>where \\lfloor\\w\\rfloor_4 is the 4x4 skew-symmetric matrix formed from \\w</p> \\begin{equation}     \\lfloor\\w\\rfloor_4 =     \\begin{bmatrix}         0   &amp; - p &amp; - q  &amp; - r  \\\\         p   &amp;   0   &amp;  r &amp; - q \\\\         q   &amp; - r  &amp;  0   &amp;  p \\\\         r   &amp;  q  &amp; - p &amp; 0  \\\\     \\end{bmatrix} \\end{equation}"},{"location":"rosflight/developer-guide/estimator-algorithm/#external-attitude-measurements","title":"External Attitude Measurements","text":"<p>Using the ROSflight estimator with gyro measurements only will quickly drift due to gyro biases. The accelerometer makes the biases in p and q observable and provides another measurement of pitch and roll. To make yaw observable, an external attitude measurement can be provided to the estimator which is used in much the same way as the accelerometer. Instead of as outlined above for accelerometer updates, the correction term \\werr can be calculated as $$ \\begin{equation}     \\werr = k_\\text{ext}\\sum_{i=1}^3 R(\\hat{q})^\\top e_i\\times \\bar{R}^\\top e_i \\end{equation} $$ where k_\\text{ext}= F_s^\\text{IMU} / F_s^\\text{ext} is the ratio of the IMU sample rate to the external attitude sample rate.</p> <p>In our implementation, whenever an external attitude measurement is supplied, if there was a \\werr calculated from the accelerometer, it is overwritten by the above calculation for an external attitude update. Also note that the gain k_P associated with an external attitude can be much higher if we trust the source of the external attitude measurement.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#tuning","title":"Tuning","text":"<p>The filter can be tuned with the two gains k_P and k_I.  Upon initialization, k_P and k_i are set very high, so as to quickly cause the filter to converge upon approprate values.  After a few seconds, they are both reduced by a factor of 10, to a value chosen through manual tuning.  A high k_P will cause sensitivity to transient accelerometer errors, while a small k_P will cause sensitivity to gyroscope drift.  A high k_I will cause biases to wander unnecessarily, while a low k_I will result in slow convergence upon accurate gyroscope bias estimates.  These parameters generally do not need to be modified from the default values.</p>"},{"location":"rosflight/developer-guide/estimator-algorithm/#implementation","title":"Implementation","text":"<p>The entire filter is implemented in float-based quaternion calculations.  Even though the STM32F10x microprocessor does not contain a floating-point unit, the entire filter has been timed to take about 370\\mus.  The extra steps of quadratic integration and matrix exponential propagation can be ommited for a 20\\mus and 90\\mus reduction in speed, respectively.  Even with these functions, however, this is sufficiently short to run at well over 1000Hz, which is the update rate of the MPU6050 on the naze32.</p> <p>Control is performed according to euler angle estimates, and to reduce the computational load of converting from quaternion to euler angles (See Equation\\eqref{eq:euler_from_quat}), a lookup table approximation of atan2 and asin are used.  The Invensense MPU6050 has a 16-bit ADC and an accelerometer and gyro onboard.  The accelerometer, when scaled to \\pm4g, has a resolution of 0.002394 m/s^2.  The lookup table method used to approximate atan2 and asin in the actual implementation is accurate to \\pm 0.001 rad.  Given the accuracy of the accelerometer, use of this lookup table implementation is justfied.  The C-code implementation of the estimator can be found in the file <code>src/estimator.c.</code></p> <ol> <li> <p>Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0\u21a9\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"rosflight/developer-guide/unit-tests/","title":"Building and Running Unit Tests","text":"<p>Contributions will need to pass our continuous integration unit tests before merging. To test your contributions against these tests, you'll first need to install Eigen and gtest:</p> <pre><code>sudo apt install libgtest-dev libeigen3-dev cmake\n</code></pre>"},{"location":"rosflight/developer-guide/unit-tests/#compile-gtest","title":"Compile gtest","text":"<p>You just downloaded a bunch of source files, which you now have to go build</p> <pre><code>sudo apt install cmake\ncd /usr/src/gtest\nsudo cmake CMakeLists.txt\nsudo make\n</code></pre> <p>Copy the archive files you just built to the <code>/usr/lib</code> directory so CMake can find them later:</p> <pre><code>sudo cp *.a /usr/lib\n</code></pre>"},{"location":"rosflight/developer-guide/unit-tests/#run-the-test-script","title":"Run the Test Script","text":"<p>The simplest way to run the unit tests is to use the testing script. This script first checks that the firmware compiles, then runs the unit tests. This is the same script used on the continuous integration server, so this is a great way to check that your code will pass the tests before opening a pull request. Run the test script with</p> <pre><code>cd &lt;firmware_directory&gt;\n./scripts/run_tests.sh\n</code></pre>"},{"location":"rosflight/developer-guide/unit-tests/#manually-build-and-run-the-unit-tests","title":"Manually Build and Run the Unit Tests","text":"<p>If you want to manually build and run the unit tests, first build them with the following commands:</p> <pre><code>cd &lt;firmware_directory&gt;/test\nmkdir build\ncd build\ncmake ..\nmake\n</code></pre> <p>Then run them with:</p> <pre><code>./unit_tests\n</code></pre>"},{"location":"rosflight/user-guide/autonomous-flight/","title":"Autonomous Flight","text":"<p>One of the core functionalities of the ROSflight autopilot is to allow the companion computer to send control setpoints to the embedded flight controller. These setpoints would typically be computed by a controller running as a ROS node, normally on the companion computer.</p>"},{"location":"rosflight/user-guide/autonomous-flight/#provide-control-from-a-companion-computer","title":"Provide Control from a Companion Computer","text":"<p>Control setpoints are sent to the flight controller by publishing to the <code>/command</code> topic that is advertised by the <code>rosflight_io</code> node. This topic accepts messages of type <code>rosflight_msgs/Command</code>, which have the following structure:</p> <pre><code>std_msgs/Header header\nuint8 mode\nuint8 ignore\nfloat32 x\nfloat32 y\nfloat32 z\nfloat32 F\n</code></pre> <p>The <code>header</code> field is a standard ROS message header. The <code>x</code>, <code>y</code>, <code>z</code>, and <code>F</code> fields are the control setpoint values, which are interpreted according to the <code>mode</code> and <code>ignore</code> fields.</p> <p>The following table describes the different values the <code>mode</code> field can take, as well as how the setpoint values are interpreted for each of these modes:</p> Value Enum x y z F 0 <code>MODE_PASS_THROUGH</code> aileron deflection (-1 to 1) elevator deflection (-1 to 1) rudder deflection (-1 to 1) throttle (0 to 1) 1 <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> roll rate (rad/s) pitch rate (rad/s) yaw rate (rad/s) throttle (0 to 1) 2 <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> roll angle (rad) pitch angle (rad) yaw rate (rad/s) throttle (0 to 1) <p>The <code>MODE_PASS_THROUGH</code> mode is used for fixed-wing vehicles to directly specify the control surface deflections and throttle, while the <code>MODE_ROLLRATE_PITCHRATE_YAWRATE_THROTTLE</code> and <code>MODE_ROLL_PITCH_YAWRATE_THROTTLE</code> modes are used for multirotor vehicles to specify the attitude rates or angles, respectively.</p> <p>The <code>ignore</code> field is used if you want to specify control setpoints for some, but not all, of the axes. For example, I may want to specify throttle setpoints to perform altitude hold, while still letting the RC pilot specify the attitude setpoints. The <code>ignore</code> field is a bitmask that can be populated by combining the following values:</p> Value Enum Result 0 <code>IGNORE_NONE</code> Ignore none of the fields (default) 1 <code>IGNORE_X</code> Ignore the <code>x</code> field 2 <code>IGNORE_Y</code> Ignore the <code>y</code> field 4 <code>IGNORE_Z</code> Ignore the <code>z</code> field 8 <code>IGNORE_F</code> Ignore the <code>F</code> field <p>For the previous example, I would set the <code>ignore</code> field to a value of <pre><code>ignore = IGNORE_X | IGNORE_Y | IGNORE_Z\n</code></pre></p> <p>The best practice is to use enum names rather than the actual numeric values for the <code>mode</code> and <code>ignore</code> fields. For example, to specify a multirotor attitude angle command in C++ I might have: <pre><code>#include &lt;ros/ros.h&gt;\n#include &lt;rosflight_msgs/Command.h&gt;\n\nrosflight_msgs::Command msg;\nmsg.header.stamp = ros::Time::now();\nmsg.mode = rosflight_msgs::Command::MODE_ROLL_PITCH_YAWRATE_THROTTLE;\nmsg.ignore = rosflight_msgs::Command::IGNORE_NONE;\nmsg.x = 0.0;\nmsg.y = 0.0;\nmsg.z = 0.0;\nmsg.F = 0.6;\n</code></pre></p> <p>In Python I might have: <pre><code>import rospy\nfrom rosflight_msgs.msg import Command\n\nmsg = Command()\nmsg.header.stamp = rospy.Time.now()\nmsg.mode = Command.MODE_ROLL_PITCH_YAWRATE_THROTTLE\nmsg.ignore = Command.IGNORE_NONE\nmsg.x = 0.0\nmsg.y = 0.0\nmsg.z = 0.0\nmsg.F = 0.6\n</code></pre> I would then publish this message to the <code>/command</code> topic to forward it to the embedded flight controller.</p> <p>Note</p> <p>If the flight controller does not receive a new command for a defined period of time, it will ignore the old commands and revert to RC control. The length of this timeout period is set by the <code>OFFBOARD_TIMEOUT</code> parameter.</p>"},{"location":"rosflight/user-guide/autonomous-flight/#fly-waypoints-with-rosplane-or-roscopter","title":"Fly Waypoints with ROSplane or ROScopter","text":"<p>Waypoint following is not supported natively by the ROSflight stack. However, the ROSplane and ROScopter projects are good, example implementations of how to achieve this using ROSflight. They also provide good examples of how you might go about integrating your own guidance or control algorithms with the ROSflight stack.</p>"},{"location":"rosflight/user-guide/flight-controller-setup/","title":"Flight Controller Setup","text":"<p>Note</p> <p>This page contains instructions for flashing pre-built firmware binaries. For instructions on building and flashing from source, see Building and Flashing in the Developer Guide.</p>"},{"location":"rosflight/user-guide/flight-controller-setup/#compatible-hardware","title":"Compatible Hardware","text":"<p>Deprecation Notice</p> <p>As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them.</p> <p>As of January 2018, ROSflight is only supported on flight controllers with STM32F103 and STM32F405 processors, specifically, the Revo, Naze32, and Flip32. Both the 6-DOF and 10-DOF versions of each board are fully supported. We have had the most success with Revo boards purchased from HobbyKing. We have had weird issues with knock-off boards from Chinese vendors. An acro version (IMU-Only) can be found at readytoflyquads.</p>"},{"location":"rosflight/user-guide/flight-controller-setup/#serial-port-configuration","title":"Serial Port Configuration","text":"<p>Tip</p> <p>You can see which groups you are a member of by running <code>groups $USER</code> on the command line.</p> <p>The following bullet point is necessary:</p> <ul> <li>Be sure your user is in the <code>dialout</code> and <code>plugdev</code> groups so you have access to the serial ports. You will need to log out and back in for these changes to take effect. <pre><code>sudo usermod -aG dialout,plugdev $USER\n</code></pre></li> </ul> <p>If you experience issues, you may need one or both of the next two bullet points:</p> <ul> <li> <p>Temporarily stop the modem-manager (Sometimes, Linux thinks the device is a modem -- this command will be effective until next boot, or until you run the command again with <code>start</code> in place of <code>stop</code>) <pre><code>sudo systemctl stop ModemManager.service\n</code></pre></p> </li> <li> <p>Add the custom udev rule so Linux handles the flight controller properly (copy the following as <code>/etc/udev/rules.d/45-stm32dfu.rules</code>) <pre><code># DFU (Internal bootloader for STM32 MCUs)\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"df11\", MODE=\"0664\", GROUP=\"plugdev\"\n</code></pre></p> </li> </ul> <p>Tip</p> <p>You can permanently disable the ModemManager if you do not need it, then you won't have to disable it every time you reboot: <pre><code>sudo systemctl disable ModemManager.service\n</code></pre> Replace <code>disable</code> with <code>enable</code> to revert (i.e. if you find some other program you use needs access to it). Or you can uninstall it entirely from your system: <pre><code>sudo apt purge modemmanager\n</code></pre></p>"},{"location":"rosflight/user-guide/flight-controller-setup/#flashing-firmware-using-the-cleanflight-configurator","title":"Flashing Firmware using the Cleanflight Configurator","text":"<ul> <li>Download the latest version of ROSflight for your board here.</li> <li> <p>Install the Cleanflight configurator - It is an extension to Google Chrome - link</p> </li> <li> <p>Load the firmware, and flash using cleanflight configurator</p> <ul> <li>Open the configurator</li> <li>Open firmware flasher</li> <li>Connect your flight controller</li> <li>Make sure that you have selected the right port (or DFU in the case of F4-based boards)</li> <li>Select \"Load Firmware (Local)\"</li> <li>Select your *.hex file you downloaded earlier.</li> <li>Short the boot pins on your flight controller, unplug it, and and plug back in.</li> </ul> </li> </ul> <p></p> <ul> <li>If you scroll to the bottom of the screen, you will see the green bar indicate progress as the hex is flashed to the flight controller. You should then see something like the following:</li> </ul> <p></p> <ul> <li>You're done! Great job.</li> </ul>"},{"location":"rosflight/user-guide/flight-controller-setup/#flashing-firmware-from-the-command-line","title":"Flashing Firmware from the Command Line","text":""},{"location":"rosflight/user-guide/flight-controller-setup/#f4-boards","title":"F4 Boards","text":"<p>You can use dfu-util to flash the firmware. This is helpful if you need (or prefer) a command-line interface.</p> <ul> <li>Install the dfu-util utility</li> </ul> <pre><code>sudo apt install dfu-util\n</code></pre> <ul> <li>Download the latest rosflight-F4.bin file, found here</li> <li>Put the board in bootloader mode (short the boot pins while restarting the board by cycling power)</li> </ul> <p>Tip</p> <p>dfu-util auto-detects F4-based boards. Try <code>dfu-util -l</code> to make sure your board is in bootloader mode</p> <ul> <li>Flash the firmware to the device <pre><code>    dfu-util -a 0 -s 0x08000000 -D rosflight-F4.bin\n</code></pre></li> </ul>"},{"location":"rosflight/user-guide/flight-controller-setup/#f1-boards","title":"F1 Boards","text":"<p>You can use stm32flash to flash the firmware to F1-based boards.</p> <ul> <li>Install the stm32flash utility <pre><code>sudo apt install stm32flash\n</code></pre></li> <li>Download the latest rosflight.hex file, found here, to the current directory</li> <li> <p>Put the board in bootloader mode (short boot pins while restarting the Naze by cycling power)</p> </li> <li> <p>Flash the firmware to the proper device (replace <code>/dev/ttyUSB0</code>) <pre><code>    stm32flash -w rosflight.hex -v -g 0x0 -b 921600 /dev/ttyUSB0\n</code></pre></p> </li> </ul>"},{"location":"rosflight/user-guide/getting-started/","title":"Getting Started","text":"<p>Reading through the pages in this user guide in order should provide you with the information you need to get a vehicle flying with ROSflight. The following is a summary of the steps you'll need to follow to get your vehicle set up, with links to the corresponding documentation pages:</p> <ol> <li>Set up your hardware (fixed-wing or multirotor platform, flight controller, and companion computer)</li> <li>Flash your flight controller with the latest ROSflight firmware</li> <li>Set up your RC transmitter</li> <li>Set up ROS on your companion computer</li> <li>Configure the flight controller for your setup: the configuration checklists below should help guide you through this process</li> <li>Run through your preflight checks</li> <li>Tune the attitude controller gains (multirotors only)</li> <li>Set up autonomous flight via offboard control (optional)</li> </ol>"},{"location":"rosflight/user-guide/getting-started/#configuration-checklist","title":"Configuration Checklist","text":"<p>The following checklists should help you get a new vehicle set up for the first time. This checklist assumes that your hardware is already set up correctly.</p>"},{"location":"rosflight/user-guide/getting-started/#general-setup","title":"General Setup","text":"<ol> <li>Set the <code>FIXED_WING</code> parameter (<code>1</code> if a fixed-wing, <code>0</code> if a multirotor)</li> <li>Set the <code>RC_TYPE</code> parameter (<code>0</code> if PPM, <code>1</code> if SBUS)</li> <li>Set the <code>MIXER</code> parameter to the appropriate value described in the Hardware Setup page</li> <li>Set the <code>MOTOR_PWM_UPDATE</code> parameter (typically <code>490</code> for SimonK ESCs, <code>50</code> for standard servos)</li> <li>Make sure your RC transmitter is set up correctly</li> <li>Set up your RC switches<ul> <li>If you want to arm/disarm using a switch, set the <code>ARM_CHANNEL</code> parameter to the appropriate channel (0-indexed)</li> <li>If you want to use a switch to enable RC override, set the <code>RC_ATT_OVRD_CHN</code> and <code>RC_THR_OVRD_CHN</code> parameters to the appropriate channel(s) (0-indexed). If you want complete control (attitude and throttle) when you flip the switch, set both these parameters to the same channel.</li> </ul> </li> <li>Calibrate your IMU: start <code>rosflight_io</code>, then run <code>rosservice call /calibrate_imu</code></li> <li>Complete the multirotor-specific or fixed-wing-specific checklist below</li> <li>Save the parameters (<code>rosservice call /param_write</code>)</li> <li>You'll probably want to save a backup of your parameters (call <code>rosservice call /param_save_to_file /path/to/file.yml</code>)</li> <li>Make sure you run through the Preflight Checklist before flying</li> </ol>"},{"location":"rosflight/user-guide/getting-started/#multirotor-specific-setup","title":"Multirotor-specific Setup","text":"<p>Danger</p> <p>IMPORTANT: Remove all props from the vehicle when calibrating ESCs!!!</p> <ol> <li> <p>Calibrate ESCs</p> <ol> <li>Make sure <code>MOTOR_MIN_PWM</code> and <code>MOTOR_MAX_PWM</code> are correct (usually <code>1000</code> and <code>2000</code>)</li> <li>Set <code>MIXER</code> param to <code>0</code> (ESC calibration mixer)</li> <li>Set <code>ARM_SPIN_MOTORS</code> to <code>0</code></li> <li> <p>Perform ESC calibration. For standard ESCs:</p> <ol> <li>With power disconnected from the motors, arm the flight controller</li> <li>Set throttle to maximum</li> <li>Connect power to the motors</li> <li>Drop the throttle to minimum</li> </ol> </li> <li> <p>Set the <code>MIXER</code> parameter back to the appropriate value for your vehicle (see the Hardware Setup page)</p> </li> <li>Set <code>ARM_SPIN_MOTORS</code> back to <code>1</code></li> </ol> </li> <li> <p>The <code>ARM_SPIN_MOTORS</code> parameter should be set to <code>1</code> so the motors spin slowly when armed. The idle throttle setting can be adjusted with the <code>MOTOR_IDLE_THR</code> parameter.</p> </li> <li>You'll most likely want to set the <code>CAL_GYRO_ARM</code> param to <code>1</code> to enable calibrating gyros before arming</li> <li>Set the <code>RC_ATT_MODE</code> parameter to set RC control mode (<code>0</code> for rate mode, <code>1</code> for angle mode [default])</li> <li>Set torque offsets as described in the RC trim calculation section of the Improving Performance page</li> <li>Tune the controller gains as described in the Multirotor gain tuning section of the Improving Performance page</li> </ol>"},{"location":"rosflight/user-guide/getting-started/#fixed-wing-specific-setup","title":"Fixed-Wing-Specific Setup","text":"<ol> <li>Reverse servo directions if necessary using the <code>AIL_REV</code>, <code>ELEVATOR_REV</code>, and <code>RUDDER_REV</code> parameters (<code>1</code> to reverse, <code>0</code> to keep current direction)</li> <li>You'll most likely want to set the <code>ARM_SPIN_MOTORS</code> parameter to <code>0</code> so that the prop doesn't spin at a minimum throttle setting when you arm, especially if you'll be doing hand launching</li> </ol>"},{"location":"rosflight/user-guide/hardware-setup/","title":"Hardware Setup","text":""},{"location":"rosflight/user-guide/hardware-setup/#parts-list","title":"Parts List","text":"<p>To use ROSflight to its full potential, you will need the following system components. Some components are mounted on your MAV (Miniature Aerial Vehicle), while others are on the ground. ROSflight supports both multirotor and fixed-wing vehicles.</p> <p>Mounted on the MAV</p> <ol> <li>Aircraft Frame, Motor(s), ESC(s), Battery and Propeller(s)</li> <li>Flight Controller (FC)</li> <li>Vibration Isolation for FC</li> <li>Any external sensors</li> <li>R/C Receiver</li> <li>Companion Computer</li> <li>Wi-Fi Antenna, or access of some kind to ground-station, wireless network (e.g. Ubiquiti Bullet)</li> </ol> <p>Ground Station</p> <ol> <li>Ground-Station, Wireless Network (e.g. Wi-Fi Router, Ubiquiti Rocket)</li> <li>R/C transmitter</li> <li>Laptop or base station computer</li> <li>Joystick (Xbox controller)</li> </ol>"},{"location":"rosflight/user-guide/hardware-setup/#frame-motors-escs-battery-and-propeller","title":"Frame, Motors, ESCs, Battery, and Propeller","text":"<p>We do not officially support any specific multirotor or airplane frame, motor, ESC, Battery or Propeller combination. There are a lot of great resources for building your own MAV, and there are a lot of great kits out there that have all of these parts.</p> <p>If you are designing your own multirotor or airplane, you may want to look at ecalc, an online tool which can help you design a proper ESC/Battery/Motor/Propeller system for your MAV.</p> <p>Some things to keep in mind as you design or build your MAV.</p> <ul> <li>Most kits do not include space for a companion computer, cameras, laser scanners or other sensors. Be sure to think about where these components are going to go, and how their placement will affect the CG of the MAV.</li> <li>You will likely also need to customize the power circuitry of your MAV to provide power to your companion computer at some specific voltage. Many people like to separate the power electronics (the ESCs and motors), from the computer and companion sensors. This can really come in handy if you are trying to develop code on the MAV, because you can have the computer on and sensors powered, and not worry at all about propellers turning on and causing injury as you move the aircraft about by hand. We will talk about this more when we talk about wiring up your MAV.</li> <li>Cheap propellers can cause a huge amount of vibration. Consider buying high-quality propellers, doing a propeller balance, or both. RCGroups, DIY Drones and Youtube have some awesome guides on how to do propeller balancing.</li> <li>ESCs will need to be calibrated from 2000 to 1000 us</li> </ul>"},{"location":"rosflight/user-guide/hardware-setup/#flight-controller","title":"Flight Controller","text":"<p>ROSflight is best supported on the Openpilot Revolution from hobbyking.com. It works on most variants of the Revo and Naze32 flight controller. Configuring a new board is relatively straight-forward, assuming that the board uses an STM32F4xx or STM32F1xx processor.</p> <p>Deprecation Notice</p> <p>As of June 2019, plans are to deprecate support for the F1 in the near future. If you need to use an F1, you will need to retrieve an older version of the code that supports the F1. However, if there are issues, we will not be able to help you fix them.</p> <p>Warning</p> <p>We have seen some problems using off-brand versions of flight controllers because the accelerometers are of very poor quality, which can mess with the firmware; try to avoid those if you can.</p>"},{"location":"rosflight/user-guide/hardware-setup/#external-sensors","title":"External Sensors","text":"<p>Additional Sensors you may want for your ROSflight setup include:</p> <ul> <li>Sonar - MB1242 I2CXL-MaxSonar - $40 on MaxBotix</li> <li>GPS \u2013 u-blox NEO-M8N \u2013 $35 from Drotek</li> <li>Digital Airspeed Sensor \u2013 $65 on JDrones</li> <li>Battery Monitor - $10 from RCTimer or DIY</li> </ul>"},{"location":"rosflight/user-guide/hardware-setup/#vibration-isolation","title":"Vibration Isolation","text":"<p>It is really important to isolate your flight controller from vehicle vibrations, such as those caused by propellers and motors. We recommend using small amounts of Kyosho Zeal to mount a fiberglass plate holding the FC to the MAV. You may also want to try adding mass to the flight control board. We have accomplished this by gluing steel washers to the fiberglass mounting plate.</p> <p></p> <p>You may need to experiment with the amount of gel you use, how far apart the gel is spaced, and the amount of mass added to the FC mounting plate. The interaction of these factors is difficult to predict, therefore it takes a little bit of experimentation to get it right.</p>"},{"location":"rosflight/user-guide/hardware-setup/#companion-computer","title":"Companion Computer","text":"<p>The only requirement for the companion computer is that it runs Linux (Ubuntu LTS versions 16.04 or 18.04), ROS, has at least one USB port, and can be carried by the aircraft. We have had success with the following companion computers, but by no means is this a comprehensive list; it is more by way of suggestion.</p> <ul> <li>MSI CUBI \u2013 i7-5500U \u2013 $350 on Amazon</li> <li>GIGABYTE BRIX Gaming- i7-4710HQ/GTX 760 \u2013 $850 on Amazon</li> <li>Intel NUC Skullcanyon \u2013 i7-6770HQ \u2013 $570 on Amazon</li> <li>ODROID-XU4 \u2013 Exynos5 2GHz 8-core \u2013 $77 on Ameridroid</li> <li>ODROID-C2 \u2013 Cortex A53 2GHz 4-core \u2013 $42 on Ameridroid</li> <li>Rasberry Pi 3 \u2013 Cortex A53 1.2GHz 4-core \u2013 $36 on Amazon</li> <li>NVIDIA Tegra TX1 - Cortex-A57 4-core CPU, 256-core Maxwell GPU - $435 from NVIDA (Educational Discounts Available)</li> <li>NVIDIA Tegra TX2 - 6-core ARMv8 64-bit CPU (4-core Cortex-A57, 2-core NVIDIA Denver 2), 8GB RAM, 256-core Pascal GPU - $600 from NVIDA (Educational Discounts Available)</li> </ul> <p>It is possible to pair the TX1 and TX2 with a CTI Orbitty carrier board for more compact builds.</p>"},{"location":"rosflight/user-guide/hardware-setup/#wi-fi","title":"Wi-Fi","text":"<p>You will need Wi-Fi to communicate with your MAV when it is in the air. Because ROS communicates over TCP, it is very easy to use ROS to view what is going on in your MAV while it is flying by sending commands and reading sensor data. For most applications, a standard Wi-Fi router and dongle will suffice. For long-range applications, you may want to look into Ubiquiti point-to-point Wi-Fi. (We have seen ranges over a mile with these networks.)</p>"},{"location":"rosflight/user-guide/hardware-setup/#rc-transmitter-and-receiver","title":"RC Transmitter and Receiver","text":"<p>For RC Control, you will need a transmitter with between 6 and 8 channels. Any additional channels will be wasted. We require RC control for safe operation, and only support arming and disarming via RC control.</p> <p>ROSflight only supports PPM (pulse position modulation) and SBUS receivers. Individual channel PWM outputs are not supported. A common RC setup is listed here, but is meant as an example. Any configurations with PPM or SBUS and 6-8 channels will be sufficient.</p> <ul> <li>Transmitter \u2013 FrSky Taranis QX7 ($105 on getfpv.com)</li> <li>Receiver \u2013 FrSky D4R-II (24.99 on getfpv.com)</li> </ul>"},{"location":"rosflight/user-guide/hardware-setup/#laptop-or-base-station-computer","title":"Laptop or Base Station Computer","text":"<p>You will need a laptop which can run Ubuntu 16.04 or 18.04 with ROS to communicate with the MAV over the ground station wireless network. If you are new to Linux, and want to retain access to Windows, I would recommend dual booting your computer rather than using a virtual machine. ROS networking can be problematic from a virtual environment.</p>"},{"location":"rosflight/user-guide/hardware-setup/#joystick","title":"Joystick","text":"<p>A joystick is used for software-in-the-loop (SIL) simulations. The joystick is not technically a required component because it is possible to control your MAV from the command line, but it makes things much easier. Our first recommendation is to use the same Taranis QX7 transmitter you use for hardware as a joystick by plugging it into the computer via USB. We also support RealFlight controllers and XBOX 360 controllers. Other joysticks are supported, but you may need to create custom axis and button mappings.</p>"},{"location":"rosflight/user-guide/hardware-setup/#battery-monitor","title":"Battery Monitor","text":"<p>A battery monitor is an optional analog sensor that provides battery voltage and/or battery current information. This data can be used to prevent power loss in air or to measure system load. The sensor outputs an analog voltage proportional to the battery voltage and/or current through the battery. A battery monitor can be as simple as a voltage divider, which measures only voltage. Small PCB sensors are also available that measure both voltage and current. Ensure that the monitor output does not exceed 3.3V, as this may damage the flight controller. The battery monitor connects to the \"PWR/SONAR\" port on the Revo. Battery monitors are not supported on the Naze32/Flip32.</p> <p>For ROSflight to use a battery monitor, an appropriate multiplier must be set. ROSflight multiplies the analog signal from the monitor by the multiplier to get the final reading. The monitor datasheet should contain the information needed to get the multiplier. For example, the datasheet for the AttoPilot 50V/90A sensor states that it outputs 63.69 mV / V. To get the original battery voltage, the multiplier must be 1/.06369, or 15.7. The multipliers for the voltage and current are set separately, with the <code>BATT_VOLT_MULT</code> and <code>BATT_CURR_MULT</code> parameters, respectively.</p> <p>ROSflight applies a simple low-pass filter to remove noise from the voltage and current measurements. These filters are configurable via the <code>BATT_VOLT_ALPHA</code> and <code>BATT_CURR_ALPHA</code> parameters. The alpha value for a given cutoff frequency \\(a\\), can be calulated with: \\( \\alpha =  e ^ {-.01a} \\). As battery voltages do not typically change quickly, the default of 0.995 usually suffices.</p> <p>More information on battery monitor hardware, including determinining appropriate multipliers and creating a simple DIY monitor, can be found on the OpenPilot Wiki.</p>"},{"location":"rosflight/user-guide/hardware-setup/#wiring-diagram","title":"Wiring Diagram","text":"<p>Below is an example wiring diagram for a multirotor using an MSI Cubi as a companion computer. This diagram also includes the motor power switch, which allows for the sensors, flight controller, and companion computer to be powered on while the motors are off. This is a safer way to test sensors, code, etc. as the motors are unable to spin while the switch is off.</p> <p></p> <p>Your needs will likely be slightly different than what is shown. This is meant as an example only and can be adapted to fit your needs.</p>"},{"location":"rosflight/user-guide/hardware-setup/#motor-layouts","title":"Motor Layouts","text":"<p>The desired mixer can be chosen by setting the <code>MIXER</code> parameter to the following values:</p> # Mixer 0 ESC calibration 1 Quad + 2 Quad X 3 Hex + 4 Hex X 5 Octo + 6 Octo X 7 Y6 8 X8 9 Tricopter 10 Fixed-wing (traditional AETR) <p>The associated motor layouts are shown below for each mixer. The ESC calibration mixer directly outputs the throttle command equally to each motor, and can be used for calibrating the ESCs.</p> <p></p> <p></p>"},{"location":"rosflight/user-guide/hardware-setup/#connecting-to-the-flight-controller","title":"Connecting to the Flight Controller","text":"<p>The flight controller communicates with the companion computer over a serial link. ROSflight only supports one serial connection at a time and by default should be the serial link connected to the USB connector on the board.</p>"},{"location":"rosflight/user-guide/hardware-setup/#using-secondary-serial-links","title":"Using Secondary Serial Links","text":"<p>In the case of an F4 flight controller, which has a USB peripheral, the highest bandwidth connection will be the USB connector. However, UART3 can also be used to communicate with the companion computer if you desire a more secure connection (micro USB connectors have been known to disconnect in high vibrations), or if you would like to use a telemetry radio for remote control.</p> <p>If a USB connection is detected on the USB peripheral, ROSflight will direct all communication through this port. However, if the <code>PARAM_SERIAL_DEVICE</code> parameter is set to <code>3</code> and the <code>PARAM_BAUD_RATE</code> parameter is set properly, then UART3 will be enabled when the USB connection is absent.</p> <p>We have had the most sucess with the SiK radios (AKA 3DR telemetry radios). These require a 5V supply and ground and connect directly to the UART3 pins. We like the SiK radios because they can be easily configured using the <code>AT-commands</code>, which are used by MissionPlanner (Windows only), sikset.py or with the AT-commands directly on the command line. There are a number of configuration options available which should be used to optimize the radios for their intended usage.</p> <p>This is just an example; any UART-based communication interface should be supported through this interface.</p>"},{"location":"rosflight/user-guide/improving-performance/","title":"Improving Performance","text":"<p>ROSflight supplies several methods to improve the performance of your aircraft. Tuning gains, adding feed-forward torques, and tuning the estimator are three ways to get your aircraft flying great!</p>"},{"location":"rosflight/user-guide/improving-performance/#gain-tuning","title":"Gain Tuning","text":"<p>Because there are a wide variety of multirotors out there, no one set of PID controller gains will be optimal for all vehicles. The default set of gains is relatively conservative for most platforms, and should be somewhat airworthy in most cases. However, depending on the inertia-to-torque ratio on your MAV, you may have to change these gains considerably. There are some great tutorials online on multirotor gain tuning; this is another tried-and-true method used to great effect at BYU.</p> <p>If you are unfamiliar with PIDs, you should probably go read about them before trying to tune a multirotor. Getting an understanding for what is going on will definitely guide your decision making process as you try to find better gains.</p> <p>While tuning controller gains, it is very likely that the multirotor will oscillate out of control. To handle this scenario, we generally add what we call \"training wheels\" to the multirotors we are tuning. These amount to thin carbon rods in the shape of an X zip-tied to the landing gear. This widens out the base of the multirotor so if you come down on a hard oscillation, chances are the vehicle will land upright, hopefully without a prop strike, or worse, battery damage with a thermal runaway event. If the battery is not tucked inside the main frame, it is wise to add some foam as protection to the battery.</p> <p>Here is a video of a maiden flight of ROSflight with \"training wheels\" attached.</p> <p>Now, for the procedure on tuning.</p>"},{"location":"rosflight/user-guide/improving-performance/#tuning-roll-and-pitch-angles","title":"Tuning Roll and Pitch angles","text":"<p>Here is a flowchart describing my PID tuning process for roll and pitch:</p> <p></p> <p>You may want to do another D-tuning iteration. Additionally, sometimes it is helpful to do a little tweaking on roll and pitch separately to eek out a little more performance from the differences in roll and pitch dynamics of your vehicle.</p> <p>Notice that we did not include any <code>I</code> tuning. As a general rule, try to keep the <code>I</code> gain as low as possible. It will always slow your response rate to input, and it can induce low frequency oscillations.</p> <p>You should only have <code>I</code> gain on roll and pitch if one of the following is true:</p> <ol> <li>You expect your CG to change, and/or</li> <li>You expect your rotor geometry to change</li> </ol> <p>Both of these are pretty rare. Instead, use your RC transmitter to trim the aircraft so it hovers with no stick input. In the RC trim calculation section, we will use the RC trim to calculate a feed-forward torque on the roll, pitch and yaw rates.</p>"},{"location":"rosflight/user-guide/improving-performance/#tuning-yaw-rate","title":"Tuning Yaw rate","text":"<p>Dynamically and algorithmically, using a <code>D</code> gain in yaw-rate control has no significant advantage. Controlling with derivative requires differentiating gyro measurements, which tends to be pretty noisy. In our experience, putting <code>D</code> in rate controllers on multirotors has always decreased performance.</p> <p>Tuning yaw rate is generally pretty easy. Basically, keep cranking it up until you feel like it's \"locked in\". Sometimes, a little bit of <code>I</code> (on the order of 0.1P) can help with this as well.</p> <p>The problem with too much <code>P</code> on yaw rate generally manifests itself in motor saturation. Some, especially larger, multirotors have problems getting enough control authority in yaw with the propellers being aligned flat. After you are done tuning, you might want to look at a plot of motor commands during a fairly aggressive flight. Underactuated yaw will be pretty obvious in these plots, because you will see the motor commands railing. To fix this, you can put shims between the arm mounts and the motors to tilt the motors just a little bit in the direction of yaw for that motor.</p>"},{"location":"rosflight/user-guide/improving-performance/#rc-trim","title":"RC trim","text":"<p>In the vast majority of cases, your multirotor will not be built perfectly. The CG could be slightly off, or your motors, speed controllers and propellers could be slightly different. One way to fix this is by adding an integrator. Integrators get rid of static offsets such as those just mentioned. However, as explained above, integrators also always slow vehicle response. In our case, since this offset is going to be constant, we can instead find a \"feed-forward\", or equilibrium offset, torque that you need to apply to hover without drift.</p> <p>Use the RC transmitter to find the \"equilibrium torques\" about the x, y, and z axes to keep the multirotor level. This is done by trimming the aircraft with the RC trims. These are usually the little switches next to the sticks on your transmitter. Adjust these until you can hover the multirotor without touching the sticks.</p> <p>Next, land the multirotor, disarm, center the sticks and perform a trim calibration with <code>rosservice call /calibrate_rc_trim</code>. ROSflight then uses the trim settings on your transmitter to find these feed-forward, or equilibrium, torques that need to be applied post-controller to keep the multirotor level. These torques will be applied to all future commands (both from the companion computer and RC), so you will need to zero out your transmitter trims after calibration.</p>"},{"location":"rosflight/user-guide/improving-performance/#estimator-tuning","title":"Estimator Tuning","text":"<p>ROSflight uses a non-linear complementary filter, based on the quaternion implementation of \"Non-linear complementary filters on the special orthogonal group\" by Robert Mahony1,  to estimate attitude and angular rates. The implementation has been improved with suggestions from \"Attitude Representation and Kinematic Propagation for Low-Cost UAVs\" by Robert Casey2. A write-up of the derivation and implementation details can be found in the LaTeX report in <code>reports/estimator.tex</code>. (You'll need to be able to compile LaTeX sources to view the PDF).</p> <p>In addition to the complementary filter, accelerometer and gyro measurements are filtered using a simple low-pass filter (LPF) to cut out noise from vibrations. A block diagram of the estimator is shown below for reference. y_{gyro} and y_{acc} are gyro and accelerometer measurements, respectively and \\beta_{gyro} is the estimated gyro biases.</p> <p></p>"},{"location":"rosflight/user-guide/improving-performance/#tuning-the-low-pass-filter-gains","title":"Tuning the Low-Pass Filter Gains","text":"<p>The <code>ACC_LPF_ALPHA</code> and <code>GYRO_LPF_ALPHA</code> parameters are used in the following low-pass-filter implementation (see lines <code>98-106</code> of <code>estimator.c</code>):</p> x_t = (1-\\alpha)y_t + \\alpha x_{t-1} <p>where y_t is the measurement and x_t is the filtered value. Lowering \\alpha will reduce lag in response, so if you feel like your MAV is sluggish despite all attempts at controller gain tuning, consider reducing \\alpha. Reducing \\alpha too far, however will result in a lot of noise from the sensors making its way into the motors. This can cause motors to get really hot, so make sure you check motor temperature if you are changing the low-pass filter constants.</p>"},{"location":"rosflight/user-guide/improving-performance/#tuning-the-complementary-filter","title":"Tuning the Complementary Filter","text":"<p>The complementary filter has two gains, k_p and k_i. For a complete understanding of how these work, we recommend reading the Mahony Paper, or the technical report in the reports folder. In short, k_p can be thought of as the strength of accelerometer measurements in the filter, and the k_i gain is the integral constant on the gyro bias. These values should probably not be changed. Before you go changing these values, make sure you completely understand how they work in the filter.</p> <p>If you do decide to change these values, you should stick to the following rule of thumb.</p> k_i \\approx \\tfrac{k_p}{10}."},{"location":"rosflight/user-guide/improving-performance/#external-attitude-measurements","title":"External Attitude Measurements","text":"<p>Because the onboard attitude estimator uses only inertial measurements, the estimates can deviate from truth. This is especially true during extended periods of accelerated flight, during which the gravity vector cannot be measured. Attitude measurements from an external source can be applied to the filter to help improve performance. These external attitude measurements might come from a higher-level estimator running on the companion computer that fuses additional information from GPS, vision, or a motion capture system.</p> <p>To send these updates to the flight controller, publish a <code>geometry_msgs/Quaternion</code> message to the <code>external_attitude</code> topic to which <code>rosflight_io</code> subscribes. The degree to which this update will be trusted is tuned with the <code>FILTER_KP_EXT</code> parameter.</p> <ol> <li> <p>Mahony, R., Hamel, T. and Pflimlin, J. (2008). Nonlinear Complementary Filters on the Special Orthogonal Group. IEEE Transactions on Automatic Control, 53(5), pp.1203-1218.\u00a0\u21a9</p> </li> <li> <p>Casey, R., Karpenko, M., Curry, R. and Elkaim, G. (2013). Attitude Representation and Kinematic Propagation for Low-Cost UAVs. AIAA Guidance, Navigation, and Control (GNC) Conference.\u00a0\u21a9</p> </li> </ol>"},{"location":"rosflight/user-guide/parameter-configuration/","title":"Parameters","text":"<p>The ROSflight firmware has several dozen parameters which it uses to customize performance. Parameters are considered semi-static variables. That is, parameters do not change during flight, but they may change between vehicles. Examples of parameters you may wish to change are:</p> <ul> <li>Fixed-wing vehicle flag</li> <li>PID gains</li> <li>Mixer choice</li> <li>IMU low-pass filter constant</li> <li>RC receiver type (PPM or SBUS)</li> </ul> <p>and so on. Access to all parameters is enabled via ROS services advertised by <code>rosflight_io</code> while the flight controller is connected.</p>"},{"location":"rosflight/user-guide/parameter-configuration/#parameter-interface","title":"Parameter Interface","text":""},{"location":"rosflight/user-guide/parameter-configuration/#getting-parameter-values","title":"Getting Parameter Values","text":"<p>Sometimes it is handy to ask the flight controller what the current value of a parameter is. This is accomplished using the <code>param_get</code> service. As an example, let's retrieve the roll angle controller proportional (P) gain.</p> <pre><code>rosservice call /param_get PID_ROLL_ANG_P\n</code></pre> <p>You should get a response similar to the following (this happens to be the default value with floating-point error):</p> <pre><code>exists: True\nvalue: 0.15000000596\n</code></pre>"},{"location":"rosflight/user-guide/parameter-configuration/#changing-parameters","title":"Changing Parameters","text":"<p>Parameters are changed via the <code>param_set</code> service. As an example, let's change the roll angle controller P gain. (I will assume that the flight controller is connected and <code>rosflight_io</code> is running in the root namespace.)</p> <pre><code>rosservice call /param_set PID_ROLL_ANG_P 0.08\n</code></pre> <p>You should get a prompt from <code>rosflight_io</code> saying <pre><code>[ INFO] [1491672408.585339558]: Parameter PID_ROLL_ANG_P has new value 0.08\n[ WARN] [1491672408.585508849]: There are unsaved changes to onboard parameters\n</code></pre></p> <p>Notice that the parameters have been set, but not saved. Parameter changes take effect immediately, however they will not persist over a reboot unless you write them to the non-volatile memory. This brings us to the next task.</p>"},{"location":"rosflight/user-guide/parameter-configuration/#writing-parameters","title":"Writing Parameters","text":"<p>To ensure that parameter values persist between reboots, you must write the parameters to the non-volatile memory. This is done by calling <code>param_write</code></p> <pre><code>rosservice call /param_write\n</code></pre> <p><code>rosflight_io</code> should then respond with <pre><code>[ INFO] [1491672597.123201952]: Param write succeeded\n[ INFO] [1491672597.123452908]: Onboard parameters have been saved\n</code></pre></p> <p>Important</p> <p>It is highly recommended that you write parameters before arming and flying the vehicle. Among other things, this will ensure that in the rare case that a hard fault is encountered and the flight controller must reboot during flight, the correct configuration will be loaded on reboot.</p> <p>Error</p> <p>Parameter writing can only happen if the flight controller is disarmed. If the param write failed for some reason, you may want to make sure your FC is disarmed and try again.</p>"},{"location":"rosflight/user-guide/parameter-configuration/#backing-up-and-loading-parameters-from-file","title":"Backing Up and Loading Parameters from File","text":"<p>It is good practice to backup your parameter configuration in case you have to re-flash your firmware or you want to share configurations between vehicles. We can do this via the <code>param_save_to_file</code> and <code>param_load_from_file</code> services.</p> <p>First, let's back up our current parameter configuration:</p> <pre><code>rosservice call /param_save_to_file ~/parameters.yml\n</code></pre> <p>Parameters are saved in YAML format. You must also specify the absolute file name of where you would like your parameters to be saved. The current active set of parameters will be saved, regardless of what is saved in non-volatile memory on the flight controller.</p> <p>Now, let's say we want to re-load this parameter file <pre><code>rosservice call /param_load_from_file ~/parameters.yml\n</code></pre> Again, you must specify the absolute file name of the file to be loaded.</p>"},{"location":"rosflight/user-guide/parameter-configuration/#fixed-wing-parameter-configuration","title":"Fixed-Wing Parameter Configuration","text":"<p>Because ROSflight ships with default parameters for multirotors, you will probably want to change the following parameters if you want to fly a fixed-wing aircraft.</p> Parameter Description Type Fixed-Wing Value MOTOR_PWM_UPDATE Refresh rate of motor commands to motors and servos (Hz) - See motor documentation int 50 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_PWM int false MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 ARM_CHANNEL RC switch channel mapped to arming [0 indexed, -1 to disable] int 4 FIXED_WING switches on passthrough commands for fixed-wing operation int true MIXER Which mixer to choose - See Mixer documentation int 10 ELEVATOR_REV reverses elevator servo output int 0/1 AIL_REV reverses aileron servo output int 0/1 RUDDER_REV reverses rudder servo output int 0/1 CAL_GYRO_ARM Calibrate gyros when arming - generally only for multirotors int false"},{"location":"rosflight/user-guide/parameter-configuration/#description-of-all-parameters","title":"Description of all Parameters","text":"<p>This is a list of all ROSflight parameters, including their types, default values, and minimum and maximum recommended values:</p> Parameter Description Type Default Value Min Max BAUD_RATE Baud rate of MAVlink communication with companion computer int 921600 9600 921600 SERIAL_DEVICE Serial Port (for supported devices) int 0 0 3 SYS_ID Mavlink System ID int 1 1 255 STRM_HRTBT Rate of heartbeat stream (Hz) int 1 0 1000 STRM_STATUS Rate of status stream (Hz) int 10 0 1000 STRM_ATTITUDE Rate of attitude stream (Hz) int 200 0 1000 STRM_IMU Rate of IMU stream (Hz) int 250 0 1000 STRM_MAG Rate of magnetometer stream (Hz) int 50 0 75 STRM_BARO Rate of barometer stream (Hz) int 50 0 100 STRM_AIRSPEED Rate of airspeed stream (Hz) int 50 0 50 STRM_SONAR Rate of sonar stream (Hz) int 40 0 40 STRM_SERVO Rate of raw output stream int 50 0 490 STRM_RC Rate of raw RC input stream int 50 0 50 STRM_GNSS Maximum rate of GNSS data streaming. Higher values allow for lower latency int 1000 0 1000 STRM_GNSS_FULL Maximum rate of fully detailed GNSS data streaming int 0 0 10 STRM_BATTERY Rate of battery status stream int 0 0 50 PARAM_MAX_CMD saturation point for PID controller output float 1.0 0 1.0 PID_ROLL_RATE_P Roll Rate Proportional Gain float 0.070f 0.0 1000.0 PID_ROLL_RATE_I Roll Rate Integral Gain float 0.000f 0.0 1000.0 PID_ROLL_RATE_D Roll Rate Derivative Gain float 0.000f 0.0 1000.0 PID_PITCH_RATE_P Pitch Rate Proportional Gain float 0.070f 0.0 1000.0 PID_PITCH_RATE_I Pitch Rate Integral Gain float 0.0000f 0.0 1000.0 PID_PITCH_RATE_D Pitch Rate Derivative Gain float 0.0000f 0.0 1000.0 PID_YAW_RATE_P Yaw Rate Proportional Gain float 0.25f 0.0 1000.0 PID_YAW_RATE_I Yaw Rate Integral Gain float 0.0f 0.0 1000.0 PID_YAW_RATE_D Yaw Rate Derivative Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_P Roll Angle Proportional Gain float 0.15f 0.0 1000.0 PID_ROLL_ANG_I Roll Angle Integral Gain float 0.0f 0.0 1000.0 PID_ROLL_ANG_D Roll Angle Derivative Gain float 0.05f 0.0 1000.0 PID_PITCH_ANG_P Pitch Angle Proportional Gain float 0.15f 0.0 1000.0 PID_PITCH_ANG_I Pitch Angle Integral Gain float 0.0f 0.0 1000.0 PID_PITCH_ANG_D Pitch Angle Derivative Gain float 0.05f 0.0 1000.0 X_EQ_TORQUE Equilibrium torque added to output of controller on x axis float 0.0f -1.0 1.0 Y_EQ_TORQUE Equilibrium torque added to output of controller on y axis float 0.0f -1.0 1.0 Z_EQ_TORQUE Equilibrium torque added to output of controller on z axis float 0.0f -1.0 1.0 PID_TAU Dirty Derivative time constant - See controller documentation float 0.05f 0.0 1.0 MOTOR_PWM_UPDATE Overrides default PWM rate specified by mixer if non-zero - Requires reboot to take effect int 0 0 490 MOTOR_IDLE_THR min throttle command sent to motors when armed (Set above 0.1 to spin when armed) float 0.1 0.0 1.0 FAILSAFE_THR Throttle sent to motors in failsafe condition (set just below hover throttle) float 0.3 0.0 1.0 ARM_SPIN_MOTORS Enforce MOTOR_IDLE_THR int true 0 1 FILTER_INIT_T Time in ms to initialize estimator int 3000 0 100000 FILTER_KP estimator proportional gain - See estimator documentation float 0.5f 0 10.0 FILTER_KI estimator integral gain - See estimator documentation float 0.01f 0 1.0 FILTER_KP_COR estimator proportional gain on external attitude correction - See estimator documentation float 10.0f 0 1.0 FILTER_ACCMARGIN allowable accel norm margin around 1g to determine if accel is usable float 0.1f 0 1.0 FILTER_QUAD_INT Perform a quadratic averaging of LPF gyro data prior to integration (adds ~20 us to estimation loop on F1 processors) int 1 0 1 FILTER_MAT_EXP 1 - Use matrix exponential to improve gyro integration (adds ~90 us to estimation loop in F1 processors) 0 - use euler integration int 1 0 1 FILTER_USE_ACC Use accelerometer to correct gyro integration drift (adds ~70 us to estimation loop) int 1 0 1 CAL_GYRO_ARM True if desired to calibrate gyros on arm int false 0 1 GYROXY_LPF_ALPHA Low-pass filter constant on gyro X and Y axes - See estimator documentation float 0.3f 0 1.0 GYROZ_LPF_ALPHA Low-pass filter constant on gyro Z axis - See estimator documentation float 0.3f 0 1.0 ACC_LPF_ALPHA Low-pass filter constant on all accel axes - See estimator documentation float 0.5f 0 1.0 GYRO_X_BIAS Constant x-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Y_BIAS Constant y-bias of gyroscope readings float 0.0f -1.0 1.0 GYRO_Z_BIAS Constant z-bias of gyroscope readings float 0.0f -1.0 1.0 ACC_X_BIAS Constant x-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Y_BIAS Constant y-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_Z_BIAS Constant z-bias of accelerometer readings float 0.0f -2.0 2.0 ACC_X_TEMP_COMP Linear x-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Y_TEMP_COMP Linear y-axis temperature compensation constant float 0.0f -2.0 2.0 ACC_Z_TEMP_COMP Linear z-axis temperature compensation constant float 0.0f -2.0 2.0 MAG_A11_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A12_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A13_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A21_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A22_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_A23_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A31_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A32_COMP Soft iron compensation constant float 0.0f -999.0 999.0 MAG_A33_COMP Soft iron compensation constant float 1.0f -999.0 999.0 MAG_X_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Y_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 MAG_Z_BIAS Hard iron compensation constant float 0.0f -999.0 999.0 BARO_BIAS Barometer measurement bias (Pa) float 0.0f 0 inf GROUND_LEVEL Altitude of ground level (m) float 1387.0f -1000 10000 DIFF_PRESS_BIAS Differential Pressure Bias (Pa) float 0.0f -10 10 RC_TYPE Type of RC input 0 - PPM, 1 - SBUS int 0 0 1 BATT_VOLT_MULT Battery monitor voltage multiplier float 0 0 inf BATT_CURR_MULT Battery monitor current multiplier float 0 0 inf BATT_VOLT_ALPHA Batter monitor voltage filter alpha. Values closer to 1 smooth the signal more. float 0.995 0 1 BATT_CURR_ALPHA Battery monitor current filter alpha. Values closer to 1 smooth the signal more. float 0.995 0 1 RC_X_CHN RC input channel mapped to x-axis commands [0 - indexed] int 0 0 3 RC_Y_CHN RC input channel mapped to y-axis commands [0 - indexed] int 1 0 3 RC_Z_CHN RC input channel mapped to z-axis commands [0 - indexed] int 3 0 3 RC_F_CHN RC input channel mapped to F-axis commands [0 - indexed] int 2 0 3 RC_ATT_OVRD_CHN RC switch mapped to attitude override [0 indexed, -1 to disable] int 4 4 7 RC_THR_OVRD_CHN RC switch channel mapped to throttle override [0 indexed, -1 to disable] int 4 4 7 RC_ATT_CTRL_CHN RC switch channel mapped to attitude control type [0 indexed, -1 to disable] int -1 4 7 ARM_CHANNEL RC switch channel mapped to arming (only if PARAM_ARM_STICKS is false) [0 indexed, -1 to disable] int -1 4 7 RC_NUM_CHN number of RC input channels int 6 1 8 SWITCH_5_DIR RC switch 5 toggle direction int 1 -1 1 SWITCH_6_DIR RC switch 6 toggle direction int 1 -1 1 SWITCH_7_DIR RC switch 7 toggle direction int 1 -1 1 SWITCH_8_DIR RC switch 8 toggle direction int 1 -1 1 RC_OVRD_DEV RC stick deviation from center for override float 0.1 0.0 1.0 OVRD_LAG_TIME RC stick deviation lag time before returning control (ms) int 1000 0 100000 MIN_THROTTLE Take minimum throttle between RC and computer at all times int true 0 1 RC_ATT_MODE Attitude mode for RC sticks (0: rate, 1: angle). Overridden if RC_ATT_CTRL_CHN is set. int 1 0 1 RC_MAX_ROLL Maximum roll angle command sent by full deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_PITCH Maximum pitch angle command sent by full stick deflection of RC sticks float 0.786f 0.0 3.14159 RC_MAX_ROLLRATE Maximum roll rate command sent by full stick deflection of RC sticks float 3.14159f 0.0 9.42477796077 RC_MAX_PITCHRATE Maximum pitch command sent by full stick deflection of RC sticks float 3.14159f 0.0 3.14159 RC_MAX_YAWRATE Maximum pitch command sent by full stick deflection of RC sticks float 1.507f 0.0 3.14159 MIXER Which mixer to choose - See Mixer documentation int Mixer::INVALID_MIXER 0 10 FIXED_WING switches on pass-through commands for fixed-wing operation int false 0 1 ELEVATOR_REV reverses elevator servo output int 0 0 1 AIL_REV reverses aileron servo output int 0 0 1 RUDDER_REV reverses rudder servo output int 0 0 1 FC_ROLL roll angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_PITCH pitch angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 FC_YAW yaw angle (deg) of flight controller wrt aircraft body float 0.0f 0 360 ARM_THRESHOLD RC deviation from max/min in yaw and throttle for arming and disarming check (us) float 0.15 0 500 OFFBOARD_TIMEOUT Timeout in milliseconds for offboard commands, after which RC override is activated int 100 0 100000"},{"location":"rosflight/user-guide/preflight-checks/","title":"Pre-Flight Checklist","text":"<p>This is an example of a ROSflight pre-flight checklist. You will likely need to augment this with checks specific to both (a) your hardware and (b) the code running on your companion computer.</p>"},{"location":"rosflight/user-guide/preflight-checks/#before-powering-up-motors","title":"Before powering up motors","text":"<ul> <li> ROS is running on the companion computer, communicating with the base station</li> <li> <code>rosflight_io</code> reports no errors</li> <li> Sensors are calibrated and publishing<ul> <li> IMU (re-calibrate every flight): <code>rosservice call /calibrate_imu</code></li> <li> Barometer: <code>rosservice call /calibrate_baro</code></li> <li> Sonar (if attached)</li> <li> Airspeed (if attached)</li> </ul> </li> <li> Estimated attitude is being published and looks accurate</li> <li> Published outputs look reasonable</li> <li> Parameter Check (if using a fixed-wing, there are about 8 parameters you will need to change from default)</li> <li> RC communication</li> <li> Failsafe behavior</li> <li> Arming and disarming</li> <li> RC override behavior</li> <li> RC range test</li> <li> Wire-wiggle test (wiggle all wires to look for bad connections)</li> <li> If desired, logging is turned on (e.g. recording a rosbag)</li> </ul>"},{"location":"rosflight/user-guide/preflight-checks/#after-powering-up-motors","title":"After Powering Up Motors","text":"<p>Danger</p> <p>Be sure the flight controller is disarmed before powering up motors!!!</p> <ul> <li> Arm/Disarm test</li> <li> Propeller spin test (check directions and response to stick inputs)</li> <li> Control surface test (fixed-wing)</li> <li> Response to offboard controls</li> </ul>"},{"location":"rosflight/user-guide/rc-configuration/","title":"RC Configuration","text":""},{"location":"rosflight/user-guide/rc-configuration/#binding-your-transmitter-to-your-receiver","title":"Binding your Transmitter to your Receiver","text":"<p>As of version 1.0, ROSflight only supports PPM receivers on F1 controllers, while F4 controllers support SBUS and PPM. If your transmitter/receiver setup only supports PWM output, we recommend using a PPM encoder such as the one here. Be sure to set the <code>RC_TYPE</code> parameter to <code>0</code> for PPM, or <code>1</code> for SBUS.</p> <p>Follow the instructions in your user manual to bind your transmitter to your RC receiver. You may also be able to find a guide on YouTube with instructions; just search for your particular transmitter and receiver model.</p>"},{"location":"rosflight/user-guide/rc-configuration/#rc-transmitter-calibration","title":"RC Transmitter Calibration","text":"<p>To avoid confusion and to reduce code complexity in the firmware source code, ROSflight does not perform software calibration of RC transmitters. This means that RC calibration must be done on the transmitter itself, as opposed to in software. This is pretty straight-forward for most modern transmitters.</p>"},{"location":"rosflight/user-guide/rc-configuration/#configure-the-full-stick-output-for-each-channel","title":"Configure the full stick output for each channel","text":"<p>The easiest way to do this is to enter the \"Servo Setup\" Menu (for Spektrum transmitters) and change the servo travel variable. You can watch the raw RC readings from the flight controller by echoing the rc_raw topic from <code>rosflight_io</code></p> <pre><code>rostopic echo /rc_raw\n</code></pre> <ul> <li>center both sticks on your transmitter</li> <li>Apply subtrim until the first four channels all read 1500 exactly (or as close as possible--some RC receivers are worse than others and cannot exactly output 1500 us)</li> <li>Set the channel endpoints so that maximum stick deflections result in readings of 1000 and 2000 us.</li> </ul> <p>You may want to follow this YouTube guide for channel calibration in betaflight: Calibrating RC endpoints with Taranis X9D.</p>"},{"location":"rosflight/user-guide/rc-configuration/#configure-stick-directions-for-roll-pitch-and-yaw-channels","title":"Configure stick directions for roll, pitch, and yaw channels.","text":"<p>You now have to make sure your RC transmitter is sending commands consistent with the north-east-down (NED) frame assumed by ROSflight.</p> <p>You may find this graphic helpful. It shows all the basic stick positions, and the associated output from the first four channels when looking at a raw AETR (aileron, elevator, throttle, rudder) RC signal from <code>rosflight_io</code>. Make sure that the stick output is in the correct direction.</p> <p></p> <p>It should be noted that channel assignment can be modified via the <code>RC_*_CHN</code> parameters. So, if you are using something other than AETR assignment, the channel index for each stick may be different, but the direction should be the same.</p>"},{"location":"rosflight/user-guide/rc-configuration/#switch-configuration","title":"Switch Configuration","text":"<p>Switches can be configured for the following functions. To disable a switch for a specific, default function, set the corresponding parameter to <code>-1</code>. Be sure to check that the switch directions operate as you intend, and reverse them in your transmitter if necessary.</p>"},{"location":"rosflight/user-guide/rc-configuration/#safety-pilot-configuration","title":"Safety Pilot Configuration","text":"<p>The <code>RC_ATT_OVRD_CHN</code> parameter maps a switch to override attitude commands with RC control. The <code>RC_THR_OVRD_CHN</code> parameter maps a switch to override throttle commands with RC control. To override both with a single switch, set both parameters to the same value (this is the default behavior).</p>"},{"location":"rosflight/user-guide/rc-configuration/#arming","title":"Arming","text":"<p>By default, arming is done with the sticks (left stick down and right to arm, down and left to disarm). To use a switch instead, set the <code>ARM_CHANNEL</code> parameter to the desired channel. Setting an arming switch disables arming with the sticks.</p>"},{"location":"rosflight/user-guide/rc-configuration/#flight-mode","title":"Flight Mode","text":"<p>If desired, you can map a switch to select between attitude control types (angle and rate) in flight by setting the <code>RC_ATT_CTRL_CHN</code> parameter to the desired channel. This can be useful if, for example, you are learning rate mode but want to be able to switch back to attitude mode to help stabilize the vehicle. This feature is disabled by default.</p>"},{"location":"rosflight/user-guide/ros-setup/","title":"Installing/Setting up ROS","text":"<p>You will need to install ROS on both the companion computer and the base station laptop. Check out the official ROS Installation page for details on how to do this.</p> <p>Currently only the long-term support ROS Kinetic and ROS Melodic releases are supported, with the recommended operating system being Ubuntu 16.04 and 18.04 respectively. If storage and/or hardware resources are limited on your companion computer, you can install the bare-bones ROS package (e.g. <code>ros-kinetic-ros-base</code>) instead of the full desktop version.</p>"},{"location":"rosflight/user-guide/ros-setup/#installing-rosflight","title":"Installing ROSflight","text":"<p>You will need to install the ROSflight packages on both the companion computer and the base station computer. The companion computer will run the node that actually communicates with the flight controller over a serial connection, while the base station needs the message and service definitions to be able to call services or subscribe and publish to topics.</p>"},{"location":"rosflight/user-guide/ros-setup/#from-the-apt-repository","title":"From the apt Repository","text":"<p>The recommended installation method for Ubuntu or Debian systems is to use the ROSflight packages in the official ROS apt repositories. If you have configured your system to use these repositories, as described in the ROS installation guide, you can install rosflight using the following, inserting the name of the ROS release you are using (e.g. \"kinetic\" or \"melodic\"):</p> <pre><code>sudo apt install ros-&lt;ros_release&gt;-rosflight-pkgs\n</code></pre> <p>The previous command will install all of the rosflight packages, including the Gazebo simulation packages. If installing on a companion computer with limited resources, you can instead install only <code>rosflight_io</code>:</p> <pre><code>sudo apt install ros-&lt;ros_release&gt;-rosflight\n</code></pre>"},{"location":"rosflight/user-guide/ros-setup/#from-source","title":"From Source","text":"<p>If you prefer, or if binary packages are not available for your distribution or system architecture, you can install the ROSflight packages from source instead. First, set up a <code>catkin</code> workspace by following the directions here.</p> <p>Tip</p> <p>In order to ensure that new terminal windows are configured to use this workspace, you can add the line <code>source ~/catkin_ws/devel/setup.bash</code> to your <code>~/.bashrc</code> file or its equivalent on other systems. (Change the path if your workspace is located somewhere other than  <code>~/catkin_ws</code>.)</p> <p>Next, download the source code into your workspace. Assuming that your workspace is located at <code>~/catkin_ws</code>: <pre><code>cd ~/catkin_ws/src\ngit clone https://github.com/rosflight/rosflight.git\n</code></pre> Pull down the submodules (there is a triple-layer submodule setup in the <code>rosflight</code> metapackage, so you have to remember the <code>--recursive</code> argument): <pre><code>cd rosflight\ngit submodule update --init --recursive\n</code></pre> Install dependencies: <pre><code>cd ~/catkin_ws/src\nrosdep -y install --ignore-src --from-path rosflight\n</code></pre> Finally, build the packages: <pre><code>cd ~/catkin_ws\ncatkin_make\n</code></pre></p>"},{"location":"rosflight/user-guide/ros-setup/#running-rosflight_io","title":"Running rosflight_io","text":"<p>The <code>rosflight_io</code> node is the bridge between ROS and the MAVLink communication with the flight controller. This node must be run on the computer that has the physical serial connection to your flight controller. To run this node, use something like the following command (after starting a <code>roscore</code>): <pre><code>rosrun rosflight rosflight_io _port:=/dev/ttyACM0\n</code></pre> Replace <code>/dev/ttyACM0</code> with the port your flight controller is connected to. The <code>rosflight_io</code> node could also be started from within a launch file with something like <pre><code>&lt;node pkg=\"rosflight\" type=\"rosflight_io\" name=\"rosflight_io\" output=\"screen\"&gt;\n&lt;param name=\"port\" value=\"/dev/ttyACM0\"/&gt;\n&lt;/node&gt;\n</code></pre></p> <p>Tip</p> <p>The optional (but recommended) <code>output=\"screen\"</code> option ensures that status messages from <code>rosflight_io</code> will be forwarded to the console from which you call <code>roslaunch</code>.</p> <p>For details on all parameters, topics, and services related to the <code>rosflight_io</code> node, refer to the documentation on the ROS wiki.</p>"},{"location":"rosflight/user-guide/ros-setup/#jetson-tx2","title":"Jetson TX2","text":"<p>Update</p> <p>As of Jetpack 4.2, with the CTI-L4T patch installed to use the TX2 mounted on a CTI Orbitty carrier board, the three drivers mentioned here are installed out of the box.</p> <p>It is likely that your Flip32/Naze32 board doesn't work correctly out of the box with the TX2. To fix this, you need to build some drivers in with the kernel. This process is pretty straight-forward.</p> <p>To build the kernel with additional USB drivers, follow the instructions and video found here. This video shows the CH341 module being added. However, there are a few additional drivers you will likely require. These include:</p> <ul> <li>USB Winchiphead CH341 Single Port Serial Driver</li> <li>USB Modem (CDC ACM) support</li> <li>USB CP210x family of UART Bridge Controllers</li> </ul> <p>After following the instructions to add these drivers, reboot your TX2 and your USB devices should show up in /dev/ttyUSB or /dev/ttyACM as you would expect."},{"location":"rosflight/user-guide/running-gazebo-simulation/","title":"Running Simulations in Gazebo","text":"<p>Rosflight comes with a useful tool allowing it to perform software-in-the-loop (SIL) simulations of the ROSflight firmware in gazebo.</p>"},{"location":"rosflight/user-guide/running-gazebo-simulation/#architecture-of-the-sil-simulation","title":"Architecture of the SIL Simulation","text":"<p>To best mimic the hardware experience of ROSflight, the SIL plugin for Gazebo actually implements the firmware source code as a library. We just implemented a different \"board layer\" which uses gazebo instead of hardware calls for things like <code>imu_read()</code> and <code>pwm_write()</code>. Instead of a serial link over USB to the flight controller, we use a UDP connection bouncing off of localhost to communicate between <code>rosflight_io</code> and the firmware. This means the interface to the SIL plugin is identical to that of hardware. <code>rosflight_io</code> is the main gateway to the firmware in simulation, just as it is in hardware.</p> <p>The following table summarizes the correlation between connections in hardware and simulation:</p> Connection Type Hardware Simulation Serial communications to <code>rosflight_io</code> USB / UART UDP RC PPM Receiver ROS <code>RC</code> topic (<code>rosflight_msgs/RCRaw</code>) Motors PWM Gazebo Plugin Sensors SPI/I2C Gazebo Plugin"},{"location":"rosflight/user-guide/running-gazebo-simulation/#quick-start-guide-to-sil-simulation","title":"Quick-Start Guide to SIL Simulation","text":"<ul> <li> <p>create a catkin workspace</p> </li> <li> <p>clone the <code>rosflight</code> metapackage repository from github into your workspace</p> </li> <li> <p>clone submodules of the <code>rosflight</code> metapackage: <code>git submodule update --init --recursive</code></p> </li> <li> <p>clone the <code>rosflight_joy</code> metapackage repository from github into your workspace</p> </li> <li> <p>install pygame: <code>pip install --user pygame</code></p> </li> <li> <p>Perform a <code>catkin_make</code></p> </li> <li> <p><code>roslaunch rosflight_sim multirotor.launch</code> - This will open up a gazebo simulation, and you should have the following <code>rqt_graph</code></p> </li> </ul> <p></p> <ul> <li>At this point, you can't actually do anything because there is no RC connection and no <code>rosflight_io</code> to talk to the firmware. Let's start by running a <code>rosflight_io</code> node. In a separate terminal, run <code>rosrun rosflight rosflight_io _udp:=true</code>.<ul> <li>The <code>udp</code> parameter tells <code>rosflight_io</code> to simulate a serial connection over UDP rather than using the USB connection to hardware</li> </ul> </li> </ul> <p>Your <code>rqt_graph</code> should look something like the following image. This looks funny because ROS doesn't actually know that there is a UDP connection between <code>rosflight_io</code> and gazebo. There is one, though, and you can test it by echoing any of the topics published by <code>rosflight_io</code>.</p> <p></p> <ul> <li>Spin up a simulated RC connection. The easiest way to do this is with the helper package <code>rosflight_joy</code>. Connect a joystick to the computer (or Taranis transmitter) and run <code>rosrun rosflight_joy rc_joy RC:=/multirotor/RC</code>. This simulates the RC connection in hardware. If everything is mapped correctly, you should now be able to arm, disarm and fly the aircraft in simulation!</li> </ul> <p>Note</p> <p>It is much easier to fly with a real transmitter than with an Xbox-type controller. FrSky Taranis and RealFlight transmitters and interlinks are also supported. Non-Xbox joysticks may have incorrect mappings. If your joystick does not work, and you write your own mapping, please contribute back your new joystick mapping!</p> <p>Remember, the SIL tries its best to replicate hardware. That means you have to calibrate and set parameters in the same way you do in hardware. See the Hardware Setup and Parameter Configuration pages in this documentation for instructions on how to perform all preflight configuration before the aircraft will arm.</p> <p>As a quick help, here is a roslaunch file which quickly does all the above <code>rosrun</code> steps automatically:</p> <pre><code>&lt;launch&gt;\n&lt;arg name=\"mav_name\"            value=\"multirotor\"/&gt;\n\n&lt;arg name=\"color\"               default=\"White\"/&gt;\n&lt;arg name=\"x\"                   default=\"0\"/&gt;\n&lt;arg name=\"y\"                   default=\"0\"/&gt;\n&lt;arg name=\"z\"                   default=\"0.2\"/&gt;\n&lt;arg name=\"yaw\"                 default=\"0\"/&gt;\n&lt;arg name=\"paused\"              default=\"false\"/&gt;\n&lt;arg name=\"gui\"                 default=\"true\"/&gt;\n&lt;arg name=\"verbose\"             default=\"false\"/&gt;\n&lt;arg name=\"debug\"               default=\"false\"/&gt;\n\n&lt;include file=\"$(find rosflight_sim)/launch/base.launch\"&gt;\n&lt;arg name=\"mav_name\" value=\"$(arg mav_name)\"/&gt;\n&lt;arg name=\"color\" value=\"$(arg color)\"/&gt;\n&lt;arg name=\"x\" value=\"$(arg x)\"/&gt;\n&lt;arg name=\"y\" value=\"$(arg y)\"/&gt;\n&lt;arg name=\"z\" value=\"$(arg z)\"/&gt;\n&lt;arg name=\"yaw\" value=\"$(arg yaw)\"/&gt;\n&lt;arg name=\"paused\" value=\"$(arg paused)\"/&gt;\n&lt;arg name=\"gui\" value=\"$(arg gui)\"/&gt;\n&lt;arg name=\"verbose\" value=\"$(arg verbose)\"/&gt;\n&lt;arg name=\"debug\" value=\"$(arg debug)\"/&gt;\n&lt;arg name=\"xacro_file\" value=\"$(find rosflight_sim)/xacro/multirotor.urdf.xacro\"/&gt;\n&lt;arg name=\"param_file\" value=\"$(find rosflight_sim)/params/multirotor.yaml\"/&gt;\n&lt;/include&gt;\n\n&lt;node name=\"rosflight_io\" pkg=\"rosflight\" type=\"rosflight_io\" output=\"screen\"&gt;\n&lt;param name=\"udp\" value=\"true\"/&gt;\n&lt;/node&gt;\n\n&lt;node name=\"rc_joy\" pkg=\"rosflight_joy\" type=\"rc_joy\"&gt;\n&lt;remap from=\"RC\" to=\"multirotor/RC\"/&gt;\n&lt;/node&gt;\n\n&lt;/launch&gt;\n</code></pre> <p>To simulate a fixed-wing mav, just change all instances of <code>multirotor</code> in the above steps to <code>fixedwing</code>.</p>"},{"location":"rosplane/overview/","title":"ROSplane Overview","text":""}]}